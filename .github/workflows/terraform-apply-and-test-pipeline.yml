name: Terraform apply and Test Pipeline

on:
  workflow_dispatch:
    inputs:
      environment:
        required: false
        type: string
      node_version:
        required: true
        type: string
        default: '22'
      aws_deploy_role:
        required: true
        type: string
      secrets_repository:
        required: true
        type: string
      run_automated_tests:
        description: 'Run automated tests'
        required: false
        type: boolean
        default: true
      run_ehr_e2e:
        description: 'Run EHR E2E tests'
        required: false
        type: boolean
        default: true
      run_intake_e2e:
        description: 'Run Intake E2E tests'
        required: false
        type: boolean
        default: true
      skip_terraform_apply:
        description: 'Skip Terraform Apply (run jobs in parallel without apply)'
        required: false
        type: boolean
        default: false
  push:
    branches: [main, develop]
    paths:
      - "apps/ehr/**"
      - "apps/intake/**"
      - "packages/zambdas/**"
      - "packages/utils/**"
      - "packages/ui-components/**"
      - "scripts/**"
      - ".github/**"
      - ".prettierignore"
      - "package.json"
      - "config/**"
  pull_request:
    branches: [main, develop, 'release/**']
    paths:
      - "apps/ehr/**"
      - "apps/intake/**"
      - "packages/zambdas/**"
      - "packages/utils/**"
      - "packages/ui-components/**"
      - "scripts/**"
      - ".github/**"
      - ".prettierignore"
      - "package.json"
      - "config/**"


env:
  NODE_VERSION: 22
  NODE_OPTIONS: "--max_old_space_size=8192"
  AWS_DEPLOY_ROLE: ${{ vars.AWS_DEPLOY_ROLE }}
  SECRETS_REPOSITORY: ${{ vars.SECRETS_REPOSITORY }}

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should-run-apply: ${{ steps.check.outputs.should-run-apply }}
      concurrency-group: ${{ steps.concurrency.outputs.group }}
    steps:
      - name: Determine Environment
        id: env
        run: |
          INPUT_ENV="${{ inputs.environment }}"
          if [ -n "$INPUT_ENV" ]; then
            ENV="$INPUT_ENV"
          elif [ "${{ github.repository }}" == "masslight/ottehr" ]; then
            ENV="e2e"
          else
            ENV="local"
          fi
          
          # Safety check: only allow local and e2e environments
          if [[ "$ENV" != "local" && "$ENV" != "e2e" ]]; then
            echo "Error: Environment must be 'local' or 'e2e' for this workflow. Got: $ENV"
            exit 1
          fi
          
          echo "Deployment environment: $ENV"
          echo "environment=$ENV" >> $GITHUB_OUTPUT

      - name: Checkout repository
        uses: actions/checkout@f43a0e5ff2bd294095638e18286ca9a3d1956744 # v3 (3.6.0)
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ inputs.node_version || env.NODE_VERSION }}

      - name: Check if Terraform Apply is needed
        id: check
        run: |
          ENV="${{ steps.env.outputs.environment }}"
          
          # For local environment, always skip apply
          if [[ "$ENV" == "local" ]]; then
            echo "Local environment detected - skipping Terraform Apply"
            echo "should-run-apply=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # For workflow_dispatch on e2e environment, check skip_terraform_apply input
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            if [ "${{ inputs.skip_terraform_apply }}" == "true" ]; then
              echo "Skip Terraform Apply input is true - skipping Terraform Apply"
              echo "should-run-apply=false" >> $GITHUB_OUTPUT
            else
              echo "Workflow dispatch without skip flag - running Terraform Apply"
              echo "should-run-apply=true" >> $GITHUB_OUTPUT
            fi
            exit 0
          fi
          
          # Check for force run command in PR description
          if [ "${{ contains(github.event.pull_request.body || '', '/run-terraform-apply') }}" == "true" ]; then
            echo "Force run enabled via PR command /run-terraform-apply"
            echo "should-run-apply=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # For push/pull_request, check changed files
          TRACKED_FILES=$(node -e "
            const config = require('./.github/trigger-paths.js');
            console.log(config.getTerraformApplyPaths().join(' '));
          ")
          
          # Get changed files
          # For PRs: compare base vs head to see all PR changes
          # For push: use before/after SHA to capture all changes in the push
          #   (works for merge commits, squash merges, fast-forward, direct pushes)
          CHANGED_FILES=""
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
            CHANGED_FILES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" 2>/dev/null || echo "")
          else
            # For push events, get all files in the push
            # Works for merge commits, squash merges, and direct pushes
            BEFORE_SHA="${{ github.event.before }}"
            AFTER_SHA="${{ github.event.after }}"
            
            if [ -n "$BEFORE_SHA" ] && [ "$BEFORE_SHA" != "0000000000000000000000000000000000000000" ]; then
              CHANGED_FILES=$(git diff --name-only "$BEFORE_SHA" "$AFTER_SHA" 2>/dev/null || echo "")
            else
              # Fallback for first push or if before SHA is unavailable
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
            fi
          fi
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No changed files detected - skipping Terraform Apply"
            echo "should-run-apply=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          echo ""
          echo "Tracking paths: $TRACKED_FILES"
          
          # Check if any changed file matches tracked paths
          HAS_RELEVANT_CHANGES=false
          while IFS= read -r file; do
            if [ -z "$file" ]; then
              continue
            fi
            for pattern in $TRACKED_FILES; do
              if [[ "$file" == "$pattern"* ]]; then
                echo "Found relevant change: $file matches pattern $pattern"
                HAS_RELEVANT_CHANGES=true
                break
              fi
            done
            if [ "$HAS_RELEVANT_CHANGES" == "true" ]; then
              break
            fi
          done <<< "$CHANGED_FILES"
          
          if [ "$HAS_RELEVANT_CHANGES" == "true" ]; then
            echo "Relevant changes found - running Terraform Apply"
            echo "should-run-apply=true" >> $GITHUB_OUTPUT
          else
            echo "No relevant changes - skipping Terraform Apply"
            echo "should-run-apply=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine Concurrency Group
        id: concurrency
        run: |
          ENV="${{ steps.env.outputs.environment }}"
          SHOULD_RUN_APPLY="${{ steps.check.outputs.should-run-apply }}"
          
          if [ "$SHOULD_RUN_APPLY" == "true" ]; then
            # Sequential group for PRs that need terraform apply
            GROUP="terraform-pipeline-${ENV}-sequential"
            echo "Using sequential concurrency group: $GROUP"
          else
            # Unique group for parallel execution (each workflow run gets its own group)
            GROUP="terraform-pipeline-${ENV}-parallel-${{ github.run_id }}"
            echo "Using parallel concurrency group: $GROUP"
          fi
          
          echo "group=$GROUP" >> $GITHUB_OUTPUT

  # Wrapper job that holds concurrency lock and runs entire pipeline (deploy + tests)
  run-pipeline:
    needs: determine-environment
    concurrency:
      group: ${{ needs.determine-environment.outputs.concurrency-group }}
      cancel-in-progress: false
    uses: ./.github/workflows/deploy-and-test-reusable.yml
    secrets: inherit
    with:
      environment: ${{ needs.determine-environment.outputs.environment }}
      should_run_deploy: ${{ needs.determine-environment.outputs.should-run-apply == 'true' }}
      node_version: ${{ inputs.node_version || '22' }}
      aws_deploy_role: ${{ inputs.aws_deploy_role || vars.AWS_DEPLOY_ROLE }}
      secrets_repository: ${{ inputs.secrets_repository || vars.SECRETS_REPOSITORY }}
      run_automated_tests: ${{ github.event.inputs.run_automated_tests != 'false' || github.event_name != 'workflow_dispatch' }}
      run_ehr_e2e: ${{ github.event.inputs.run_ehr_e2e != 'false' || github.event_name != 'workflow_dispatch' }}
      run_intake_e2e: ${{ github.event.inputs.run_intake_e2e != 'false' || github.event_name != 'workflow_dispatch' }}
      pr_body: ${{ github.event.pull_request.body || '' }}
      github_ref: ${{ github.ref }}
      is_pull_request: ${{ github.event_name == 'pull_request' }}