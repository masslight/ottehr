name: Terraform apply and Test Pipeline

on:
  workflow_dispatch:
    inputs:
      environment:
        required: false
        type: string
      node_version:
        required: true
        type: string
        default: '22'
      aws_deploy_role:
        required: true
        type: string
      secrets_repository:
        required: true
        type: string
      run_automated_tests:
        description: 'Run automated tests'
        required: false
        type: boolean
        default: true
      run_ehr_e2e:
        description: 'Run EHR E2E tests'
        required: false
        type: boolean
        default: true
      run_intake_e2e:
        description: 'Run Intake E2E tests'
        required: false
        type: boolean
        default: true
      skip_terraform_apply:
        description: 'Skip Terraform Apply (run jobs in parallel without apply)'
        required: false
        type: boolean
        default: false
  push:
    branches: [main]
    paths:
      - "apps/ehr/**"
      - "apps/intake/**"
      - "packages/zambdas/**"
      - "packages/utils/**"
      - "packages/ui-components/**"
      - packages/spec/**
      - "scripts/**"
      - ".github/**"
      - ".prettierignore"
      - "package.json"
      - "config/**"
  pull_request:
    branches: [main, develop, 'release/**']
    paths:
      - "apps/ehr/**"
      - "apps/intake/**"
      - "packages/zambdas/**"
      - "packages/utils/**"
      - "packages/ui-components/**"
      - packages/spec/**
      - "scripts/**"
      - ".github/**"
      - ".prettierignore"
      - "package.json"
      - "config/**"


env:
  NODE_VERSION: 22
  NODE_OPTIONS: "--max_old_space_size=8192"
  AWS_DEPLOY_ROLE: ${{ vars.AWS_DEPLOY_ROLE }}
  SECRETS_REPOSITORY: ${{ vars.SECRETS_REPOSITORY }}

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      environment: ${{ steps.finalize-env.outputs.environment }}
      should-run-apply: ${{ steps.check.outputs.should-run-apply }}
      concurrency-group: ${{ steps.concurrency.outputs.group }}
    steps:
      - name: Determine Environment
        id: env
        run: |
          echo "========================================="
          echo "STEP 1: Initial Environment Determination"
          echo "========================================="
          echo "Repository: ${{ github.repository }}"
          echo "Event: ${{ github.event_name }}"
          echo "Run ID: ${{ github.run_id }}"
          echo "Run Number: ${{ github.run_number }}"
          
          INPUT_ENV="${{ inputs.environment }}"
          echo "Manual input environment: '${INPUT_ENV}'"
          
          if [ -n "$INPUT_ENV" ]; then
            ENV="$INPUT_ENV"
            echo "[OK] Using manually specified environment: $ENV"
          elif [ "${{ github.repository }}" != "masslight/ottehr" ]; then
            # Downstream repositories use local environment
            ENV="local"
            echo "[OK] Downstream repository detected - using local environment"
          else
            # For masslight/ottehr, use load balancing to select least loaded environment
            # This will be set in the next step
            ENV=""
            echo "[OK] masslight/ottehr detected - will use load balancing"
          fi
          
          # Safety check: only allow local, e2e, and e2e2 environments
          if [ -n "$ENV" ]; then
            if [[ "$ENV" != "local" && "$ENV" != "e2e" && "$ENV" != "e2e2" ]]; then
              echo "[ERROR] Environment must be 'local', 'e2e', or 'e2e2' for this workflow. Got: $ENV"
              exit 1
            fi
            echo "[OK] Environment validation passed: $ENV"
            echo "environment=$ENV" >> $GITHUB_OUTPUT
          else
            echo "[INFO] Environment will be determined by load balancing step"
          fi
          echo "========================================="

      - name: Select Least Loaded Environment
        if: steps.env.outputs.environment == ''
        id: load-balance
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "========================================="
          echo "STEP 2: Load Balancing Analysis"
          echo "========================================="
          echo "Analyzing active workflow runs to select least loaded environment..."
          
          # Get all queued and in_progress runs for this workflow, excluding current run
          CURRENT_RUN_ID="${{ github.run_id }}"
          echo "Current run ID: $CURRENT_RUN_ID"
          
          # Fetch active runs
          echo ""
          echo "[API] Fetching active/queued runs from GitHub API..."
          RUNS_DATA=$(gh api "repos/${{ github.repository }}/actions/workflows/terraform-apply-and-test-pipeline.yml/runs?status=queued&status=in_progress&per_page=100")
          
          TOTAL_RUNS=$(echo "$RUNS_DATA" | jq '.workflow_runs | length')
          echo "[OK] Found $TOTAL_RUNS total active/queued runs (including current)"
          
          # Initialize counters
          E2E_COUNT=0
          E2E2_COUNT=0
          
          # Get list of run IDs
          RUN_IDS=$(echo "$RUNS_DATA" | jq -r '.workflow_runs[] | select(.id != '$CURRENT_RUN_ID') | .id')
          OTHER_RUNS_COUNT=$(echo "$RUN_IDS" | wc -w | tr -d ' ')
          echo "[INFO] Analyzing $OTHER_RUNS_COUNT other runs (excluding current)"
          echo ""
          
          if [ -z "$RUN_IDS" ]; then
            echo "[INFO] No other active runs detected"
          else
            echo "[ANALYSIS] Analyzing each run to estimate environment distribution:"
            echo "---"
            
            # Check each run's jobs to determine which environment it's using
            for RUN_ID in $RUN_IDS; do
              echo "  Run #$RUN_ID:"
              
              # Get job details - specifically looking for the run-pipeline job which has concurrency
              JOBS_JSON=$(gh api "repos/${{ github.repository }}/actions/runs/${RUN_ID}/jobs" 2>/dev/null || echo '{"jobs":[]}')
              
              # Look for run-pipeline job to see if it's running or queued
              RUN_PIPELINE_STATUS=$(echo "$JOBS_JSON" | jq -r '.jobs[] | select(.name == "run-pipeline") | .status' 2>/dev/null | head -1)
              
              if [ -n "$RUN_PIPELINE_STATUS" ] && [ "$RUN_PIPELINE_STATUS" != "null" ]; then
                echo "    - run-pipeline status: $RUN_PIPELINE_STATUS"
                
                # Check the determine-environment job to see what environment was selected
                DETERMINE_JOB=$(echo "$JOBS_JSON" | jq -r '.jobs[] | select(.name == "determine-environment")' 2>/dev/null)
                
                if [ -n "$DETERMINE_JOB" ] && [ "$DETERMINE_JOB" != "null" ]; then
                  # Get run metadata for heuristic
                  RUN_NUMBER=$(echo "$RUNS_DATA" | jq -r '.workflow_runs[] | select(.id == '$RUN_ID') | .run_number')
                  RUN_URL=$(echo "$RUNS_DATA" | jq -r '.workflow_runs[] | select(.id == '$RUN_ID') | .html_url')
                  
                  # Use heuristic: run_number modulo 2 to estimate environment distribution
                  # (We can't easily access job outputs via API, so we use this approximation)
                  if [ $((RUN_NUMBER % 2)) -eq 0 ]; then
                    E2E_COUNT=$((E2E_COUNT + 1))
                    echo "    - run_number: $RUN_NUMBER (even) -> estimated environment: e2e"
                  else
                    E2E2_COUNT=$((E2E2_COUNT + 1))
                    echo "    - run_number: $RUN_NUMBER (odd) -> estimated environment: e2e2"
                  fi
                  echo "    - url: $RUN_URL"
                else
                  echo "    - determine-environment job not found or not completed yet"
                fi
              else
                echo "    - run-pipeline job not started yet (skipping)"
              fi
            done
            echo "---"
          fi
          
          echo ""
          echo "[SUMMARY] Load Distribution Summary:"
          echo "   e2e environment:  $E2E_COUNT active/queued runs"
          echo "   e2e2 environment: $E2E2_COUNT active/queued runs"
          echo ""
          
          # Select least loaded environment
          if [ $E2E_COUNT -le $E2E2_COUNT ]; then
            ENV="e2e"
            echo "[DECISION] Selected 'e2e' (has $E2E_COUNT runs vs e2e2 with $E2E2_COUNT runs)"
            [ $E2E_COUNT -eq $E2E2_COUNT ] && echo "   (Equal load - defaulting to e2e)"
          else
            ENV="e2e2"
            echo "[DECISION] Selected 'e2e2' (has $E2E2_COUNT runs vs e2e with $E2E_COUNT runs)"
          fi
          
          echo ""
          echo "[RESULT] Selected environment: $ENV"
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "========================================="

      - name: Finalize Environment Selection
        id: finalize-env
        run: |
          echo "========================================="
          echo "STEP 3: Finalize Environment Selection"
          echo "========================================="
          
          LOAD_BALANCED_ENV="${{ steps.load-balance.outputs.environment }}"
          INITIAL_ENV="${{ steps.env.outputs.environment }}"
          
          echo "Initial environment: '${INITIAL_ENV}'"
          echo "Load-balanced environment: '${LOAD_BALANCED_ENV}'"
          
          # Use load-balanced environment if available, otherwise use the one from initial determination
          if [ -n "$LOAD_BALANCED_ENV" ]; then
            ENV="$LOAD_BALANCED_ENV"
            echo "[OK] Using load-balanced environment"
          else
            ENV="$INITIAL_ENV"
            echo "[OK] Using initial environment (manual or downstream)"
          fi
          
          echo ""
          echo "[FINAL] FINAL ENVIRONMENT: $ENV"
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "========================================="

      - name: Checkout repository
        uses: actions/checkout@f43a0e5ff2bd294095638e18286ca9a3d1956744 # v3 (3.6.0)
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ inputs.node_version || env.NODE_VERSION }}

      - name: Check if Terraform Apply is needed
        id: check
        run: |
          ENV="${{ steps.finalize-env.outputs.environment }}"
          # For workflow_dispatch on e2e environment, check skip_terraform_apply input
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            if [ "${{ inputs.skip_terraform_apply }}" == "true" ]; then
              echo "Skip Terraform Apply input is true - skipping Terraform Apply"
              echo "should-run-apply=false" >> $GITHUB_OUTPUT
            else
              echo "Workflow dispatch without skip flag - running Terraform Apply"
              echo "should-run-apply=true" >> $GITHUB_OUTPUT
            fi
            exit 0
          fi
          
          # Check for skip command in PR description
          if [ "${{ contains(github.event.pull_request.body || '', '/skip-terraform-apply') }}" == "true" ]; then
            echo "Skipping Terraform Apply via PR command /skip-terraform-apply"
            echo "should-run-apply=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Default: run Terraform Apply for all push/pull_request events
          echo "Running Terraform Apply by default"
          echo "should-run-apply=true" >> $GITHUB_OUTPUT

      - name: Determine Concurrency Group
        id: concurrency
        run: |
          echo "========================================="
          echo "STEP 4: Determine Concurrency Group"
          echo "========================================="
          
          ENV="${{ steps.finalize-env.outputs.environment }}"
          SHOULD_RUN_APPLY="${{ steps.check.outputs.should-run-apply }}"
          
          echo "Environment: $ENV"
          echo "Should run apply: $SHOULD_RUN_APPLY"
          echo ""
          
          if [ "$SHOULD_RUN_APPLY" == "true" ]; then
            # Sequential group for PRs that need terraform apply
            GROUP="terraform-pipeline-${ENV}-sequential"
            echo "[MODE] SEQUENTIAL (will queue behind other deployments on $ENV)"
            echo "   Concurrency group: $GROUP"
            echo ""
            echo "   This means:"
            echo "   - Only one deployment per environment at a time"
            echo "   - Ensures safe sequential deployments"
            echo "   - Each environment (e2e/e2e2) has independent queue"
          else
            # Unique group for parallel execution (each workflow run gets its own group)
            GROUP="terraform-pipeline-${ENV}-parallel-${{ github.run_id }}"
            echo "[MODE] PARALLEL (will run immediately, no queueing)"
            echo "   Concurrency group: $GROUP"
            echo ""
            echo "   This means:"
            echo "   - Skips terraform apply"
            echo "   - Can run multiple test-only jobs in parallel"
            echo "   - Each run has unique concurrency group"
          fi
          
          echo ""
          echo "[RESULT] Final concurrency group: $GROUP"
          echo "group=$GROUP" >> $GITHUB_OUTPUT
          echo "========================================="

      - name: Summary
        run: |
          echo ""
          echo "========================================"
          echo "  ENVIRONMENT DETERMINATION COMPLETE"
          echo "========================================"
          echo ""
          echo "[CONFIGURATION] Configuration Summary:"
          echo "   - Repository: ${{ github.repository }}"
          echo "   - Event: ${{ github.event_name }}"
          echo "   - Run ID: ${{ github.run_id }}"
          echo "   - Run Number: ${{ github.run_number }}"
          echo ""
          echo "[SELECTED] Selected Configuration:"
          echo "   - Environment: ${{ steps.finalize-env.outputs.environment }}"
          echo "   - Concurrency Group: ${{ steps.concurrency.outputs.group }}"
          echo "   - Will Deploy: ${{ steps.check.outputs.should-run-apply }}"
          echo ""
          echo "[NEXT STEPS] Next Steps:"
          echo "   - run-pipeline job will use this configuration"
          echo "   - Check concurrency queue for selected environment"
          echo "   - Deploy and run tests on: ${{ steps.finalize-env.outputs.environment }}"
          echo ""
          echo "========================================"

  # Wrapper job that holds concurrency lock and runs entire pipeline (deploy + tests)
  run-pipeline:
    needs: determine-environment
    concurrency:
      group: ${{ needs.determine-environment.outputs.concurrency-group }}
      cancel-in-progress: false
    uses: ./.github/workflows/deploy-and-test-reusable.yml
    secrets: inherit
    with:
      environment: ${{ needs.determine-environment.outputs.environment }}
      should_run_deploy: ${{ needs.determine-environment.outputs.should-run-apply == 'true' }}
      node_version: ${{ inputs.node_version || '22' }}
      aws_deploy_role: ${{ inputs.aws_deploy_role || vars.AWS_DEPLOY_ROLE }}
      secrets_repository: ${{ inputs.secrets_repository || vars.SECRETS_REPOSITORY }}
      run_automated_tests: ${{ github.event.inputs.run_automated_tests != 'false' || github.event_name != 'workflow_dispatch' }}
      run_ehr_e2e: ${{ github.event.inputs.run_ehr_e2e != 'false' || github.event_name != 'workflow_dispatch' }}
      run_intake_e2e: ${{ github.event.inputs.run_intake_e2e != 'false' || github.event_name != 'workflow_dispatch' }}
      pr_body: ${{ github.event.pull_request.body || '' }}
      github_ref: ${{ github.ref }}
      is_pull_request: ${{ github.event_name == 'pull_request' }}