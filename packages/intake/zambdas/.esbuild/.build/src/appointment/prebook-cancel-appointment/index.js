"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../../node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/typeof.js"(exports, module2) {
    function _typeof4(o) {
      "@babel/helpers - typeof";
      return module2.exports = _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof4(o);
    }
    module2.exports = _typeof4, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module2) {
    var _typeof4 = require_typeof()["default"];
    function toPrimitive2(t2, r) {
      if ("object" != _typeof4(t2) || !t2)
        return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t2, r || "default");
        if ("object" != _typeof4(i))
          return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t2);
    }
    module2.exports = toPrimitive2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module2) {
    var _typeof4 = require_typeof()["default"];
    var toPrimitive2 = require_toPrimitive();
    function toPropertyKey2(t2) {
      var i = toPrimitive2(t2, "string");
      return "symbol" == _typeof4(i) ? i : i + "";
    }
    module2.exports = toPropertyKey2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module2) {
    var toPropertyKey2 = require_toPropertyKey();
    function _defineProperty8(e, r, t2) {
      return (r = toPropertyKey2(r)) in e ? Object.defineProperty(e, r, {
        value: t2,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t2, e;
    }
    module2.exports = _defineProperty8, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
var require_objectWithoutPropertiesLoose = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module2) {
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r)
        return {};
      var t2 = {};
      for (var n2 in r)
        if ({}.hasOwnProperty.call(r, n2)) {
          if (e.includes(n2))
            continue;
          t2[n2] = r[n2];
        }
      return t2;
    }
    module2.exports = _objectWithoutPropertiesLoose, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var require_objectWithoutProperties = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports, module2) {
    var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
    function _objectWithoutProperties6(e, t2) {
      if (null == e)
        return {};
      var o, r, i = objectWithoutPropertiesLoose(e, t2);
      if (Object.getOwnPropertySymbols) {
        var s2 = Object.getOwnPropertySymbols(e);
        for (r = 0; r < s2.length; r++)
          o = s2[r], t2.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    module2.exports = _objectWithoutProperties6, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "../../../node_modules/react/cjs/react.production.min.js"(exports) {
    "use strict";
    var l2 = Symbol.for("react.element");
    var n2 = Symbol.for("react.portal");
    var p = Symbol.for("react.fragment");
    var q = Symbol.for("react.strict_mode");
    var r = Symbol.for("react.profiler");
    var t2 = Symbol.for("react.provider");
    var u = Symbol.for("react.context");
    var v = Symbol.for("react.forward_ref");
    var w = Symbol.for("react.suspense");
    var x = Symbol.for("react.memo");
    var y = Symbol.for("react.lazy");
    var z = Symbol.iterator;
    function A(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = z && a[z] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } };
    var C = Object.assign;
    var D = {};
    function E(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    var H = G.prototype = new F();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = true;
    var I = Array.isArray;
    var J = Object.prototype.hasOwnProperty;
    var K = { current: null };
    var L = { key: true, ref: true, __self: true, __source: true };
    function M(a, b, e) {
      var d, c = {}, k = null, h = null;
      if (null != b)
        for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b)
          J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (1 === g)
        c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++)
          f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps)
        for (d in g = a.defaultProps, g)
          void 0 === c[d] && (c[d] = g[d]);
      return { $$typeof: l2, type: a, key: k, ref: h, props: c, _owner: K.current };
    }
    function N(a, b) {
      return { $$typeof: l2, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l2;
    }
    function escape2(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g;
    function Q(a, b) {
      return "object" === typeof a && null !== a && null != a.key ? escape2("" + a.key) : b.toString(36);
    }
    function R(a, b, e, d, c) {
      var k = typeof a;
      if ("undefined" === k || "boolean" === k)
        a = null;
      var h = false;
      if (null === a)
        h = true;
      else
        switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l2:
              case n2:
                h = true;
            }
        }
      if (h)
        return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      h = 0;
      d = "" === d ? "." : d + ":";
      if (I(a))
        for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
      else if (f = A(a), "function" === typeof f)
        for (a = f.call(a), g = 0; !(k = a.next()).done; )
          k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
      else if ("object" === k)
        throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    function S(a, b, e) {
      if (null == a)
        return a;
      var d = [], c = 0;
      R(a, d, "", "", function(a2) {
        return b.call(e, a2, c++);
      });
      return d;
    }
    function T(a) {
      if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(b2) {
          if (0 === a._status || -1 === a._status)
            a._status = 1, a._result = b2;
        }, function(b2) {
          if (0 === a._status || -1 === a._status)
            a._status = 2, a._result = b2;
        });
        -1 === a._status && (a._status = 0, a._result = b);
      }
      if (1 === a._status)
        return a._result.default;
      throw a._result;
    }
    var U = { current: null };
    var V = { transition: null };
    var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    exports.Children = { map: S, forEach: function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a) {
      var b = 0;
      S(a, function() {
        b++;
      });
      return b;
    }, toArray: function(a) {
      return S(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    exports.Component = E;
    exports.Fragment = p;
    exports.Profiler = r;
    exports.PureComponent = G;
    exports.StrictMode = q;
    exports.Suspense = w;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    exports.cloneElement = function(a, b, e) {
      if (null === a || void 0 === a)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (null != b) {
        void 0 !== b.ref && (k = b.ref, h = K.current);
        void 0 !== b.key && (c = "" + b.key);
        if (a.type && a.type.defaultProps)
          var g = a.type.defaultProps;
        for (f in b)
          J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (1 === f)
        d.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++)
          g[m] = arguments[m + 2];
        d.children = g;
      }
      return { $$typeof: l2, type: a.type, key: c, ref: k, props: d, _owner: h };
    };
    exports.createContext = function(a) {
      a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t2, _context: a };
      return a.Consumer = a;
    };
    exports.createElement = M;
    exports.createFactory = function(a) {
      var b = M.bind(null, a);
      b.type = a;
      return b;
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    exports.isValidElement = O;
    exports.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    exports.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
    };
    exports.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    exports.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    exports.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    exports.useContext = function(a) {
      return U.current.useContext(a);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    exports.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    exports.useId = function() {
      return U.current.useId();
    };
    exports.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    exports.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    exports.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    exports.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    exports.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    exports.useRef = function(a) {
      return U.current.useRef(a);
    };
    exports.useState = function(a) {
      return U.current.useState(a);
    };
    exports.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    exports.useTransition = function() {
      return U.current.useTransition();
    };
    exports.version = "18.2.0";
  }
});

// ../../../node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "../../../node_modules/react/cjs/react.development.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV !== "production") {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.2.0";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn2(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn2("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init3(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty2.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty2.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement5(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement2(element, config, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement2(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape2(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match2) {
            return escaperLookup[match2];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index2) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape2("" + element.key);
          }
          return index2.toString(36);
        }
        function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array2, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement2(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array2.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n2 = 0;
          mapChildren(children, function() {
            n2++;
          });
          return n2;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement2(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext2(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn2("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy2(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!render.name && !render.displayName) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!type.name && !type.displayName) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext4(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState2(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init3) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init3);
        }
        function useRef2(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect2(create3, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create3, deps);
        }
        function useInsertionEffect(create3, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create3, deps);
        }
        function useLayoutEffect(create3, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create3, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo3(create3, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create3, deps);
        }
        function useImperativeHandle(ref, create3, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create3, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match2 = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match2 && match2[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s2 = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]) {
                c--;
              }
              for (; s2 >= 1 && c >= 0; s2--, c--) {
                if (sampleLines[s2] !== controlLines[c]) {
                  if (s2 !== 1 || c !== 1) {
                    do {
                      s2--;
                      c--;
                      if (c < 0 || sampleLines[s2] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s2 >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty2);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement5.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn2("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn2("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement2.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn2("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module2 && module2[requireString];
              enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error2) {
              popActScope(prevActScopeDepth);
              throw error2;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                    } else {
                      resolve(returnValue2);
                    }
                  }, function(error2) {
                    popActScope(prevActScopeDepth);
                    reject(error2);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    } else {
                      resolve(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve, reject) {
                    resolve(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  }
                });
              } catch (error2) {
                reject(error2);
              }
            } else {
              resolve(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i = 0;
              try {
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error2) {
                queue = queue.slice(i + 1);
                throw error2;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext2;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement2;
        exports.lazy = lazy2;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback;
        exports.useContext = useContext4;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect2;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo3;
        exports.useReducer = useReducer;
        exports.useRef = useRef2;
        exports.useState = useState2;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../../../node_modules/react/index.js
var require_react = __commonJS({
  "../../../node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_production_min();
    } else {
      module2.exports = require_react_development();
    }
  }
});

// ../../../node_modules/void-elements/index.js
var require_void_elements = __commonJS({
  "../../../node_modules/void-elements/index.js"(exports, module2) {
    module2.exports = {
      "area": true,
      "base": true,
      "br": true,
      "col": true,
      "embed": true,
      "hr": true,
      "img": true,
      "input": true,
      "link": true,
      "meta": true,
      "param": true,
      "source": true,
      "track": true,
      "wbr": true
    };
  }
});

// ../../../node_modules/html-parse-stringify/dist/html-parse-stringify.js
var require_html_parse_stringify = __commonJS({
  "../../../node_modules/html-parse-stringify/dist/html-parse-stringify.js"(exports, module2) {
    var e;
    var t2 = (e = require_void_elements()) && "object" == typeof e && "default" in e ? e.default : e;
    var n2 = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
    function r(e2) {
      var r2 = { type: "tag", name: "", voidElement: false, attrs: {}, children: [] }, i2 = e2.match(/<\/?([^\s]+?)[/\s>]/);
      if (i2 && (r2.name = i2[1], (t2[i2[1]] || "/" === e2.charAt(e2.length - 2)) && (r2.voidElement = true), r2.name.startsWith("!--"))) {
        var s3 = e2.indexOf("-->");
        return { type: "comment", comment: -1 !== s3 ? e2.slice(4, s3) : "" };
      }
      for (var c2 = new RegExp(n2), a2 = null; null !== (a2 = c2.exec(e2)); )
        if (a2[0].trim())
          if (a2[1]) {
            var o = a2[1].trim(), u = [o, ""];
            o.indexOf("=") > -1 && (u = o.split("=")), r2.attrs[u[0]] = u[1], c2.lastIndex--;
          } else
            a2[2] && (r2.attrs[a2[2]] = a2[3].trim().substring(1, a2[3].length - 1));
      return r2;
    }
    var i = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g;
    var s2 = /^\s*$/;
    var c = /* @__PURE__ */ Object.create(null);
    function a(e2, t3) {
      switch (t3.type) {
        case "text":
          return e2 + t3.content;
        case "tag":
          return e2 += "<" + t3.name + (t3.attrs ? function(e3) {
            var t4 = [];
            for (var n3 in e3)
              t4.push(n3 + '="' + e3[n3] + '"');
            return t4.length ? " " + t4.join(" ") : "";
          }(t3.attrs) : "") + (t3.voidElement ? "/>" : ">"), t3.voidElement ? e2 : e2 + t3.children.reduce(a, "") + "</" + t3.name + ">";
        case "comment":
          return e2 + "<!--" + t3.comment + "-->";
      }
    }
    module2.exports = { parse: function(e2, t3) {
      t3 || (t3 = {}), t3.components || (t3.components = c);
      var n3, a2 = [], o = [], u = -1, l2 = false;
      if (0 !== e2.indexOf("<")) {
        var m = e2.indexOf("<");
        a2.push({ type: "text", content: -1 === m ? e2 : e2.substring(0, m) });
      }
      return e2.replace(i, function(i2, c2) {
        if (l2) {
          if (i2 !== "</" + n3.name + ">")
            return;
          l2 = false;
        }
        var m2, d = "/" !== i2.charAt(1), f = i2.startsWith("<!--"), h = c2 + i2.length, p = e2.charAt(h);
        if (f) {
          var v = r(i2);
          return u < 0 ? (a2.push(v), a2) : ((m2 = o[u]).children.push(v), a2);
        }
        if (d && (u++, "tag" === (n3 = r(i2)).type && t3.components[n3.name] && (n3.type = "component", l2 = true), n3.voidElement || l2 || !p || "<" === p || n3.children.push({ type: "text", content: e2.slice(h, e2.indexOf("<", h)) }), 0 === u && a2.push(n3), (m2 = o[u - 1]) && m2.children.push(n3), o[u] = n3), (!d || n3.voidElement) && (u > -1 && (n3.voidElement || n3.name === i2.slice(2, -1)) && (u--, n3 = -1 === u ? a2 : o[u]), !l2 && "<" !== p && p)) {
          m2 = -1 === u ? a2 : o[u].children;
          var x = e2.indexOf("<", h), g = e2.slice(h, -1 === x ? void 0 : x);
          s2.test(g) && (g = " "), (x > -1 && u + m2.length >= 0 || " " !== g) && m2.push({ type: "text", content: g });
        }
      }), a2;
    }, stringify: function(e2) {
      return e2.reduce(function(e3, t3) {
        return e3 + a("", t3);
      }, "");
    } };
  }
});

// ../../../node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module2) {
    function _classCallCheck3(a, n2) {
      if (!(a instanceof n2))
        throw new TypeError("Cannot call a class as a function");
    }
    module2.exports = _classCallCheck3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/createClass.js"(exports, module2) {
    var toPropertyKey2 = require_toPropertyKey();
    function _defineProperties2(e, r) {
      for (var t2 = 0; t2 < r.length; t2++) {
        var o = r[t2];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey2(o.key), o);
      }
    }
    function _createClass3(e, r, t2) {
      return r && _defineProperties2(e.prototype, r), t2 && _defineProperties2(e, t2), Object.defineProperty(e, "prototype", {
        writable: false
      }), e;
    }
    module2.exports = _createClass3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module2) {
    function _arrayWithHoles(r) {
      if (Array.isArray(r))
        return r;
    }
    module2.exports = _arrayWithHoles, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
var require_iterableToArrayLimit = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports, module2) {
    function _iterableToArrayLimit(r, l2) {
      var t2 = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t2) {
        var e, n2, i, u, a = [], f = true, o = false;
        try {
          if (i = (t2 = t2.call(r)).next, 0 === l2) {
            if (Object(t2) !== t2)
              return;
            f = false;
          } else
            for (; !(f = (e = i.call(t2)).done) && (a.push(e.value), a.length !== l2); f = true)
              ;
        } catch (r2) {
          o = true, n2 = r2;
        } finally {
          try {
            if (!f && null != t2["return"] && (u = t2["return"](), Object(u) !== u))
              return;
          } finally {
            if (o)
              throw n2;
          }
        }
        return a;
      }
    }
    module2.exports = _iterableToArrayLimit, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module2) {
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n2 = Array(a); e < a; e++)
        n2[e] = r[e];
      return n2;
    }
    module2.exports = _arrayLikeToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module2) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r)
          return arrayLikeToArray(r, a);
        var t2 = {}.toString.call(r).slice(8, -1);
        return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? arrayLikeToArray(r, a) : void 0;
      }
    }
    module2.exports = _unsupportedIterableToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module2) {
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module2.exports = _nonIterableRest, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/@babel/runtime/helpers/slicedToArray.js
var require_slicedToArray = __commonJS({
  "../../../node_modules/@babel/runtime/helpers/slicedToArray.js"(exports, module2) {
    var arrayWithHoles = require_arrayWithHoles();
    var iterableToArrayLimit = require_iterableToArrayLimit();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableRest = require_nonIterableRest();
    function _slicedToArray4(r, e) {
      return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();
    }
    module2.exports = _slicedToArray4, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// ../../../node_modules/property-expr/index.js
var require_property_expr = __commonJS({
  "../../../node_modules/property-expr/index.js"(exports, module2) {
    "use strict";
    function Cache(maxSize) {
      this._maxSize = maxSize;
      this.clear();
    }
    Cache.prototype.clear = function() {
      this._size = 0;
      this._values = /* @__PURE__ */ Object.create(null);
    };
    Cache.prototype.get = function(key) {
      return this._values[key];
    };
    Cache.prototype.set = function(key, value) {
      this._size >= this._maxSize && this.clear();
      if (!(key in this._values))
        this._size++;
      return this._values[key] = value;
    };
    var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
    var DIGIT_REGEX = /^\d+$/;
    var LEAD_DIGIT_REGEX = /^\d/;
    var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
    var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
    var MAX_CACHE_SIZE = 512;
    var pathCache = new Cache(MAX_CACHE_SIZE);
    var setCache = new Cache(MAX_CACHE_SIZE);
    var getCache = new Cache(MAX_CACHE_SIZE);
    module2.exports = {
      Cache,
      split,
      normalizePath,
      setter: function(path2) {
        var parts = normalizePath(path2);
        return setCache.get(path2) || setCache.set(path2, function setter(obj, value) {
          var index2 = 0;
          var len = parts.length;
          var data = obj;
          while (index2 < len - 1) {
            var part = parts[index2];
            if (part === "__proto__" || part === "constructor" || part === "prototype") {
              return obj;
            }
            data = data[parts[index2++]];
          }
          data[parts[index2]] = value;
        });
      },
      getter: function(path2, safe) {
        var parts = normalizePath(path2);
        return getCache.get(path2) || getCache.set(path2, function getter(data) {
          var index2 = 0, len = parts.length;
          while (index2 < len) {
            if (data != null || !safe)
              data = data[parts[index2++]];
            else
              return;
          }
          return data;
        });
      },
      join: function(segments) {
        return segments.reduce(function(path2, part) {
          return path2 + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path2 ? "." : "") + part);
        }, "");
      },
      forEach: function(path2, cb, thisArg) {
        forEach(Array.isArray(path2) ? path2 : split(path2), cb, thisArg);
      }
    };
    function normalizePath(path2) {
      return pathCache.get(path2) || pathCache.set(
        path2,
        split(path2).map(function(part) {
          return part.replace(CLEAN_QUOTES_REGEX, "$2");
        })
      );
    }
    function split(path2) {
      return path2.match(SPLIT_REGEX) || [""];
    }
    function forEach(parts, iter, thisArg) {
      var len = parts.length, part, idx, isArray, isBracket;
      for (idx = 0; idx < len; idx++) {
        part = parts[idx];
        if (part) {
          if (shouldBeQuoted(part)) {
            part = '"' + part + '"';
          }
          isBracket = isQuoted(part);
          isArray = !isBracket && /^\d+$/.test(part);
          iter.call(thisArg, part, isBracket, isArray, idx, parts);
        }
      }
    }
    function isQuoted(str) {
      return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
    }
    function hasLeadingNumber(part) {
      return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
    }
    function hasSpecialChars(part) {
      return SPEC_CHAR_REGEX.test(part);
    }
    function shouldBeQuoted(part) {
      return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
    }
  }
});

// ../../../node_modules/tiny-case/index.js
var require_tiny_case = __commonJS({
  "../../../node_modules/tiny-case/index.js"(exports, module2) {
    var reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
    var words = (str) => str.match(reWords) || [];
    var upperFirst = (str) => str[0].toUpperCase() + str.slice(1);
    var join = (str, d) => words(str).join(d).toLowerCase();
    var camelCase = (str) => words(str).reduce(
      (acc, next) => `${acc}${!acc ? next.toLowerCase() : next[0].toUpperCase() + next.slice(1).toLowerCase()}`,
      ""
    );
    var pascalCase = (str) => upperFirst(camelCase(str));
    var snakeCase = (str) => join(str, "_");
    var kebabCase = (str) => join(str, "-");
    var sentenceCase = (str) => upperFirst(join(str, " "));
    var titleCase = (str) => words(str).map(upperFirst).join(" ");
    module2.exports = {
      words,
      upperFirst,
      camelCase,
      pascalCase,
      snakeCase,
      kebabCase,
      sentenceCase,
      titleCase
    };
  }
});

// ../../../node_modules/toposort/index.js
var require_toposort = __commonJS({
  "../../../node_modules/toposort/index.js"(exports, module2) {
    module2.exports = function(edges) {
      return toposort(uniqueNodes(edges), edges);
    };
    module2.exports.array = toposort;
    function toposort(nodes, edges) {
      var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
      edges.forEach(function(edge) {
        if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
          throw new Error("Unknown node. There is an unknown node in the supplied edges.");
        }
      });
      while (i--) {
        if (!visited[i])
          visit(nodes[i], i, /* @__PURE__ */ new Set());
      }
      return sorted;
      function visit(node, i2, predecessors) {
        if (predecessors.has(node)) {
          var nodeRep;
          try {
            nodeRep = ", node was:" + JSON.stringify(node);
          } catch (e) {
            nodeRep = "";
          }
          throw new Error("Cyclic dependency" + nodeRep);
        }
        if (!nodesHash.has(node)) {
          throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
        }
        if (visited[i2])
          return;
        visited[i2] = true;
        var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
        outgoing = Array.from(outgoing);
        if (i2 = outgoing.length) {
          predecessors.add(node);
          do {
            var child = outgoing[--i2];
            visit(child, nodesHash.get(child), predecessors);
          } while (i2);
          predecessors.delete(node);
        }
        sorted[--cursor] = node;
      }
    }
    function uniqueNodes(arr2) {
      var res = /* @__PURE__ */ new Set();
      for (var i = 0, len = arr2.length; i < len; i++) {
        var edge = arr2[i];
        res.add(edge[0]);
        res.add(edge[1]);
      }
      return Array.from(res);
    }
    function makeOutgoingEdges(arr2) {
      var edges = /* @__PURE__ */ new Map();
      for (var i = 0, len = arr2.length; i < len; i++) {
        var edge = arr2[i];
        if (!edges.has(edge[0]))
          edges.set(edge[0], /* @__PURE__ */ new Set());
        if (!edges.has(edge[1]))
          edges.set(edge[1], /* @__PURE__ */ new Set());
        edges.get(edge[0]).add(edge[1]);
      }
      return edges;
    }
    function makeNodesHash(arr2) {
      var res = /* @__PURE__ */ new Map();
      for (var i = 0, len = arr2.length; i < len; i++) {
        res.set(arr2[i], i);
      }
      return res;
    }
  }
});

// ../../../node_modules/yup/index.js
var require_yup = __commonJS({
  "../../../node_modules/yup/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var propertyExpr = require_property_expr();
    var tinyCase = require_tiny_case();
    var toposort = require_toposort();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var toposort__default = /* @__PURE__ */ _interopDefaultLegacy(toposort);
    var toString = Object.prototype.toString;
    var errorToString = Error.prototype.toString;
    var regExpToString = RegExp.prototype.toString;
    var symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
    var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
    function printNumber(val) {
      if (val != +val)
        return "NaN";
      const isNegativeZero = val === 0 && 1 / val < 0;
      return isNegativeZero ? "-0" : "" + val;
    }
    function printSimpleValue(val, quoteStrings = false) {
      if (val == null || val === true || val === false)
        return "" + val;
      const typeOf = typeof val;
      if (typeOf === "number")
        return printNumber(val);
      if (typeOf === "string")
        return quoteStrings ? `"${val}"` : val;
      if (typeOf === "function")
        return "[Function " + (val.name || "anonymous") + "]";
      if (typeOf === "symbol")
        return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
      const tag = toString.call(val).slice(8, -1);
      if (tag === "Date")
        return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
      if (tag === "Error" || val instanceof Error)
        return "[" + errorToString.call(val) + "]";
      if (tag === "RegExp")
        return regExpToString.call(val);
      return null;
    }
    function printValue(value, quoteStrings) {
      let result = printSimpleValue(value, quoteStrings);
      if (result !== null)
        return result;
      return JSON.stringify(value, function(key, value2) {
        let result2 = printSimpleValue(this[key], quoteStrings);
        if (result2 !== null)
          return result2;
        return value2;
      }, 2);
    }
    function toArray(value) {
      return value == null ? [] : [].concat(value);
    }
    var _Symbol$toStringTag;
    var _Symbol$hasInstance;
    var _Symbol$toStringTag2;
    var strReg = /\$\{\s*(\w+)\s*\}/g;
    _Symbol$toStringTag = Symbol.toStringTag;
    var ValidationErrorNoStack = class {
      constructor(errorOrErrors, value, field, type) {
        this.name = void 0;
        this.message = void 0;
        this.value = void 0;
        this.path = void 0;
        this.type = void 0;
        this.params = void 0;
        this.errors = void 0;
        this.inner = void 0;
        this[_Symbol$toStringTag] = "Error";
        this.name = "ValidationError";
        this.value = value;
        this.path = field;
        this.type = type;
        this.errors = [];
        this.inner = [];
        toArray(errorOrErrors).forEach((err) => {
          if (ValidationError.isError(err)) {
            this.errors.push(...err.errors);
            const innerErrors = err.inner.length ? err.inner : [err];
            this.inner.push(...innerErrors);
          } else {
            this.errors.push(err);
          }
        });
        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
      }
    };
    _Symbol$hasInstance = Symbol.hasInstance;
    _Symbol$toStringTag2 = Symbol.toStringTag;
    var ValidationError = class _ValidationError extends Error {
      static formatError(message, params) {
        const path2 = params.label || params.path || "this";
        if (path2 !== params.path)
          params = Object.assign({}, params, {
            path: path2
          });
        if (typeof message === "string")
          return message.replace(strReg, (_, key) => printValue(params[key]));
        if (typeof message === "function")
          return message(params);
        return message;
      }
      static isError(err) {
        return err && err.name === "ValidationError";
      }
      constructor(errorOrErrors, value, field, type, disableStack) {
        const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);
        if (disableStack) {
          return errorNoStack;
        }
        super();
        this.value = void 0;
        this.path = void 0;
        this.type = void 0;
        this.params = void 0;
        this.errors = [];
        this.inner = [];
        this[_Symbol$toStringTag2] = "Error";
        this.name = errorNoStack.name;
        this.message = errorNoStack.message;
        this.type = errorNoStack.type;
        this.value = errorNoStack.value;
        this.path = errorNoStack.path;
        this.errors = errorNoStack.errors;
        this.inner = errorNoStack.inner;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _ValidationError);
        }
      }
      static [_Symbol$hasInstance](inst) {
        return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
      }
    };
    var mixed2 = {
      default: "${path} is invalid",
      required: "${path} is a required field",
      defined: "${path} must be defined",
      notNull: "${path} cannot be null",
      oneOf: "${path} must be one of the following values: ${values}",
      notOneOf: "${path} must not be one of the following values: ${values}",
      notType: ({
        path: path2,
        type,
        value,
        originalValue
      }) => {
        const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".";
        return type !== "mixed" ? `${path2} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path2} must match the configured type. The validated value was: \`${printValue(value, true)}\`` + castMsg;
      }
    };
    var string2 = {
      length: "${path} must be exactly ${length} characters",
      min: "${path} must be at least ${min} characters",
      max: "${path} must be at most ${max} characters",
      matches: '${path} must match the following: "${regex}"',
      email: "${path} must be a valid email",
      url: "${path} must be a valid URL",
      uuid: "${path} must be a valid UUID",
      datetime: "${path} must be a valid ISO date-time",
      datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
      datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
      trim: "${path} must be a trimmed string",
      lowercase: "${path} must be a lowercase string",
      uppercase: "${path} must be a upper case string"
    };
    var number = {
      min: "${path} must be greater than or equal to ${min}",
      max: "${path} must be less than or equal to ${max}",
      lessThan: "${path} must be less than ${less}",
      moreThan: "${path} must be greater than ${more}",
      positive: "${path} must be a positive number",
      negative: "${path} must be a negative number",
      integer: "${path} must be an integer"
    };
    var date = {
      min: "${path} field must be later than ${min}",
      max: "${path} field must be at earlier than ${max}"
    };
    var boolean2 = {
      isValue: "${path} field must be ${value}"
    };
    var object2 = {
      noUnknown: "${path} field has unspecified keys: ${unknown}"
    };
    var array2 = {
      min: "${path} field must have at least ${min} items",
      max: "${path} field must have less than or equal to ${max} items",
      length: "${path} must have ${length} items"
    };
    var tuple = {
      notType: (params) => {
        const {
          path: path2,
          value,
          spec
        } = params;
        const typeLen = spec.types.length;
        if (Array.isArray(value)) {
          if (value.length < typeLen)
            return `${path2} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
          if (value.length > typeLen)
            return `${path2} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
        }
        return ValidationError.formatError(mixed2.notType, params);
      }
    };
    var locale = Object.assign(/* @__PURE__ */ Object.create(null), {
      mixed: mixed2,
      string: string2,
      number,
      date,
      object: object2,
      array: array2,
      boolean: boolean2,
      tuple
    });
    var isSchema = (obj) => obj && obj.__isYupSchema__;
    var Condition = class _Condition {
      static fromOptions(refs, config) {
        if (!config.then && !config.otherwise)
          throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
        let {
          is,
          then,
          otherwise
        } = config;
        let check = typeof is === "function" ? is : (...values) => values.every((value) => value === is);
        return new _Condition(refs, (values, schema) => {
          var _branch;
          let branch = check(...values) ? then : otherwise;
          return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
        });
      }
      constructor(refs, builder) {
        this.fn = void 0;
        this.refs = refs;
        this.refs = refs;
        this.fn = builder;
      }
      resolve(base, options) {
        let values = this.refs.map((ref) => (
          // TODO: ? operator here?
          ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context)
        ));
        let schema = this.fn(values, base, options);
        if (schema === void 0 || // @ts-ignore this can be base
        schema === base) {
          return base;
        }
        if (!isSchema(schema))
          throw new TypeError("conditions must return a schema object");
        return schema.resolve(options);
      }
    };
    var prefixes = {
      context: "$",
      value: "."
    };
    function create$9(key, options) {
      return new Reference(key, options);
    }
    var Reference = class {
      constructor(key, options = {}) {
        this.key = void 0;
        this.isContext = void 0;
        this.isValue = void 0;
        this.isSibling = void 0;
        this.path = void 0;
        this.getter = void 0;
        this.map = void 0;
        if (typeof key !== "string")
          throw new TypeError("ref must be a string, got: " + key);
        this.key = key.trim();
        if (key === "")
          throw new TypeError("ref must be a non-empty string");
        this.isContext = this.key[0] === prefixes.context;
        this.isValue = this.key[0] === prefixes.value;
        this.isSibling = !this.isContext && !this.isValue;
        let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
        this.path = this.key.slice(prefix.length);
        this.getter = this.path && propertyExpr.getter(this.path, true);
        this.map = options.map;
      }
      getValue(value, parent, context) {
        let result = this.isContext ? context : this.isValue ? value : parent;
        if (this.getter)
          result = this.getter(result || {});
        if (this.map)
          result = this.map(result);
        return result;
      }
      /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {Object=} options.context
       * @param {Object=} options.parent
       */
      cast(value, options) {
        return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
      }
      resolve() {
        return this;
      }
      describe() {
        return {
          type: "ref",
          key: this.key
        };
      }
      toString() {
        return `Ref(${this.key})`;
      }
      static isRef(value) {
        return value && value.__isYupRef;
      }
    };
    Reference.prototype.__isYupRef = true;
    var isAbsent = (value) => value == null;
    function createValidation(config) {
      function validate({
        value,
        path: path2 = "",
        options,
        originalValue,
        schema
      }, panic, next) {
        const {
          name,
          test,
          params,
          message,
          skipAbsent
        } = config;
        let {
          parent,
          context,
          abortEarly = schema.spec.abortEarly,
          disableStackTrace = schema.spec.disableStackTrace
        } = options;
        function resolve(item) {
          return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
        }
        function createError(overrides = {}) {
          const nextParams = Object.assign({
            value,
            originalValue,
            label: schema.spec.label,
            path: overrides.path || path2,
            spec: schema.spec,
            disableStackTrace: overrides.disableStackTrace || disableStackTrace
          }, params, overrides.params);
          for (const key of Object.keys(nextParams))
            nextParams[key] = resolve(nextParams[key]);
          const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
          error.params = nextParams;
          return error;
        }
        const invalid = abortEarly ? panic : next;
        let ctx = {
          path: path2,
          parent,
          type: name,
          from: options.from,
          createError,
          resolve,
          options,
          originalValue,
          schema
        };
        const handleResult = (validOrError) => {
          if (ValidationError.isError(validOrError))
            invalid(validOrError);
          else if (!validOrError)
            invalid(createError());
          else
            next(null);
        };
        const handleError = (err) => {
          if (ValidationError.isError(err))
            invalid(err);
          else
            panic(err);
        };
        const shouldSkip = skipAbsent && isAbsent(value);
        if (shouldSkip) {
          return handleResult(true);
        }
        let result;
        try {
          var _result;
          result = test.call(ctx, value, ctx);
          if (typeof ((_result = result) == null ? void 0 : _result.then) === "function") {
            if (options.sync) {
              throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
            }
            return Promise.resolve(result).then(handleResult, handleError);
          }
        } catch (err) {
          handleError(err);
          return;
        }
        handleResult(result);
      }
      validate.OPTIONS = config;
      return validate;
    }
    function getIn(schema, path2, value, context = value) {
      let parent, lastPart, lastPartDebug;
      if (!path2)
        return {
          parent,
          parentPath: path2,
          schema
        };
      propertyExpr.forEach(path2, (_part, isBracket, isArray) => {
        let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
        schema = schema.resolve({
          context,
          parent,
          value
        });
        let isTuple = schema.type === "tuple";
        let idx = isArray ? parseInt(part, 10) : 0;
        if (schema.innerType || isTuple) {
          if (isTuple && !isArray)
            throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
          if (value && idx >= value.length) {
            throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path2}. because there is no value at that index. `);
          }
          parent = value;
          value = value && value[idx];
          schema = isTuple ? schema.spec.types[idx] : schema.innerType;
        }
        if (!isArray) {
          if (!schema.fields || !schema.fields[part])
            throw new Error(`The schema does not contain the path: ${path2}. (failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
          parent = value;
          value = value && value[part];
          schema = schema.fields[part];
        }
        lastPart = part;
        lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
      });
      return {
        schema,
        parent,
        parentPath: lastPart
      };
    }
    function reach(obj, path2, value, context) {
      return getIn(obj, path2, value, context).schema;
    }
    var ReferenceSet = class _ReferenceSet extends Set {
      describe() {
        const description = [];
        for (const item of this.values()) {
          description.push(Reference.isRef(item) ? item.describe() : item);
        }
        return description;
      }
      resolveAll(resolve) {
        let result = [];
        for (const item of this.values()) {
          result.push(resolve(item));
        }
        return result;
      }
      clone() {
        return new _ReferenceSet(this.values());
      }
      merge(newItems, removeItems) {
        const next = this.clone();
        newItems.forEach((value) => next.add(value));
        removeItems.forEach((value) => next.delete(value));
        return next;
      }
    };
    function clone3(src, seen = /* @__PURE__ */ new Map()) {
      if (isSchema(src) || !src || typeof src !== "object")
        return src;
      if (seen.has(src))
        return seen.get(src);
      let copy2;
      if (src instanceof Date) {
        copy2 = new Date(src.getTime());
        seen.set(src, copy2);
      } else if (src instanceof RegExp) {
        copy2 = new RegExp(src);
        seen.set(src, copy2);
      } else if (Array.isArray(src)) {
        copy2 = new Array(src.length);
        seen.set(src, copy2);
        for (let i = 0; i < src.length; i++)
          copy2[i] = clone3(src[i], seen);
      } else if (src instanceof Map) {
        copy2 = /* @__PURE__ */ new Map();
        seen.set(src, copy2);
        for (const [k, v] of src.entries())
          copy2.set(k, clone3(v, seen));
      } else if (src instanceof Set) {
        copy2 = /* @__PURE__ */ new Set();
        seen.set(src, copy2);
        for (const v of src)
          copy2.add(clone3(v, seen));
      } else if (src instanceof Object) {
        copy2 = {};
        seen.set(src, copy2);
        for (const [k, v] of Object.entries(src))
          copy2[k] = clone3(v, seen);
      } else {
        throw Error(`Unable to clone ${src}`);
      }
      return copy2;
    }
    var Schema = class {
      constructor(options) {
        this.type = void 0;
        this.deps = [];
        this.tests = void 0;
        this.transforms = void 0;
        this.conditions = [];
        this._mutate = void 0;
        this.internalTests = {};
        this._whitelist = new ReferenceSet();
        this._blacklist = new ReferenceSet();
        this.exclusiveTests = /* @__PURE__ */ Object.create(null);
        this._typeCheck = void 0;
        this.spec = void 0;
        this.tests = [];
        this.transforms = [];
        this.withMutation(() => {
          this.typeError(mixed2.notType);
        });
        this.type = options.type;
        this._typeCheck = options.check;
        this.spec = Object.assign({
          strip: false,
          strict: false,
          abortEarly: true,
          recursive: true,
          disableStackTrace: false,
          nullable: false,
          optional: true,
          coerce: true
        }, options == null ? void 0 : options.spec);
        this.withMutation((s2) => {
          s2.nonNullable();
        });
      }
      // TODO: remove
      get _type() {
        return this.type;
      }
      clone(spec) {
        if (this._mutate) {
          if (spec)
            Object.assign(this.spec, spec);
          return this;
        }
        const next = Object.create(Object.getPrototypeOf(this));
        next.type = this.type;
        next._typeCheck = this._typeCheck;
        next._whitelist = this._whitelist.clone();
        next._blacklist = this._blacklist.clone();
        next.internalTests = Object.assign({}, this.internalTests);
        next.exclusiveTests = Object.assign({}, this.exclusiveTests);
        next.deps = [...this.deps];
        next.conditions = [...this.conditions];
        next.tests = [...this.tests];
        next.transforms = [...this.transforms];
        next.spec = clone3(Object.assign({}, this.spec, spec));
        return next;
      }
      label(label) {
        let next = this.clone();
        next.spec.label = label;
        return next;
      }
      meta(...args) {
        if (args.length === 0)
          return this.spec.meta;
        let next = this.clone();
        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
        return next;
      }
      withMutation(fn) {
        let before = this._mutate;
        this._mutate = true;
        let result = fn(this);
        this._mutate = before;
        return result;
      }
      concat(schema) {
        if (!schema || schema === this)
          return this;
        if (schema.type !== this.type && this.type !== "mixed")
          throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
        let base = this;
        let combined = schema.clone();
        const mergedSpec = Object.assign({}, base.spec, combined.spec);
        combined.spec = mergedSpec;
        combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);
        combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
        combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
        combined.tests = base.tests;
        combined.exclusiveTests = base.exclusiveTests;
        combined.withMutation((next) => {
          schema.tests.forEach((fn) => {
            next.test(fn.OPTIONS);
          });
        });
        combined.transforms = [...base.transforms, ...combined.transforms];
        return combined;
      }
      isType(v) {
        if (v == null) {
          if (this.spec.nullable && v === null)
            return true;
          if (this.spec.optional && v === void 0)
            return true;
          return false;
        }
        return this._typeCheck(v);
      }
      resolve(options) {
        let schema = this;
        if (schema.conditions.length) {
          let conditions = schema.conditions;
          schema = schema.clone();
          schema.conditions = [];
          schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
          schema = schema.resolve(options);
        }
        return schema;
      }
      resolveOptions(options) {
        var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
        return Object.assign({}, options, {
          from: options.from || [],
          strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
          abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
          recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
          disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
        });
      }
      /**
       * Run the configured transform pipeline over an input value.
       */
      cast(value, options = {}) {
        let resolvedSchema = this.resolve(Object.assign({
          value
        }, options));
        let allowOptionality = options.assert === "ignore-optionality";
        let result = resolvedSchema._cast(value, options);
        if (options.assert !== false && !resolvedSchema.isType(result)) {
          if (allowOptionality && isAbsent(result)) {
            return result;
          }
          let formattedValue = printValue(value);
          let formattedResult = printValue(result);
          throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema.type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
        }
        return result;
      }
      _cast(rawValue, options) {
        let value = rawValue === void 0 ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);
        if (value === void 0) {
          value = this.getDefault(options);
        }
        return value;
      }
      _validate(_value, options = {}, panic, next) {
        let {
          path: path2,
          originalValue = _value,
          strict = this.spec.strict
        } = options;
        let value = _value;
        if (!strict) {
          value = this._cast(value, Object.assign({
            assert: false
          }, options));
        }
        let initialTests = [];
        for (let test of Object.values(this.internalTests)) {
          if (test)
            initialTests.push(test);
        }
        this.runTests({
          path: path2,
          value,
          originalValue,
          options,
          tests: initialTests
        }, panic, (initialErrors) => {
          if (initialErrors.length) {
            return next(initialErrors, value);
          }
          this.runTests({
            path: path2,
            value,
            originalValue,
            options,
            tests: this.tests
          }, panic, next);
        });
      }
      /**
       * Executes a set of validations, either schema, produced Tests or a nested
       * schema validate result.
       */
      runTests(runOptions, panic, next) {
        let fired = false;
        let {
          tests,
          value,
          originalValue,
          path: path2,
          options
        } = runOptions;
        let panicOnce = (arg) => {
          if (fired)
            return;
          fired = true;
          panic(arg, value);
        };
        let nextOnce = (arg) => {
          if (fired)
            return;
          fired = true;
          next(arg, value);
        };
        let count = tests.length;
        let nestedErrors = [];
        if (!count)
          return nextOnce([]);
        let args = {
          value,
          originalValue,
          path: path2,
          options,
          schema: this
        };
        for (let i = 0; i < tests.length; i++) {
          const test = tests[i];
          test(args, panicOnce, function finishTestRun(err) {
            if (err) {
              Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
            }
            if (--count <= 0) {
              nextOnce(nestedErrors);
            }
          });
        }
      }
      asNestedTest({
        key,
        index: index2,
        parent,
        parentPath,
        originalParent,
        options
      }) {
        const k = key != null ? key : index2;
        if (k == null) {
          throw TypeError("Must include `key` or `index` for nested validations");
        }
        const isIndex = typeof k === "number";
        let value = parent[k];
        const testOptions = Object.assign({}, options, {
          // Nested validations fields are always strict:
          //    1. parent isn't strict so the casting will also have cast inner values
          //    2. parent is strict in which case the nested values weren't cast either
          strict: true,
          parent,
          value,
          originalValue: originalParent[k],
          // FIXME: tests depend on `index` being passed around deeply,
          //   we should not let the options.key/index bleed through
          key: void 0,
          // index: undefined,
          [isIndex ? "index" : "key"]: k,
          path: isIndex || k.includes(".") ? `${parentPath || ""}[${isIndex ? k : `"${k}"`}]` : (parentPath ? `${parentPath}.` : "") + key
        });
        return (_, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);
      }
      validate(value, options) {
        var _options$disableStack2;
        let schema = this.resolve(Object.assign({}, options, {
          value
        }));
        let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
        return new Promise((resolve, reject) => schema._validate(value, options, (error, parsed) => {
          if (ValidationError.isError(error))
            error.value = parsed;
          reject(error);
        }, (errors, validated) => {
          if (errors.length)
            reject(new ValidationError(errors, validated, void 0, void 0, disableStackTrace));
          else
            resolve(validated);
        }));
      }
      validateSync(value, options) {
        var _options$disableStack3;
        let schema = this.resolve(Object.assign({}, options, {
          value
        }));
        let result;
        let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
        schema._validate(value, Object.assign({}, options, {
          sync: true
        }), (error, parsed) => {
          if (ValidationError.isError(error))
            error.value = parsed;
          throw error;
        }, (errors, validated) => {
          if (errors.length)
            throw new ValidationError(errors, value, void 0, void 0, disableStackTrace);
          result = validated;
        });
        return result;
      }
      isValid(value, options) {
        return this.validate(value, options).then(() => true, (err) => {
          if (ValidationError.isError(err))
            return false;
          throw err;
        });
      }
      isValidSync(value, options) {
        try {
          this.validateSync(value, options);
          return true;
        } catch (err) {
          if (ValidationError.isError(err))
            return false;
          throw err;
        }
      }
      _getDefault(options) {
        let defaultValue = this.spec.default;
        if (defaultValue == null) {
          return defaultValue;
        }
        return typeof defaultValue === "function" ? defaultValue.call(this, options) : clone3(defaultValue);
      }
      getDefault(options) {
        let schema = this.resolve(options || {});
        return schema._getDefault(options);
      }
      default(def) {
        if (arguments.length === 0) {
          return this._getDefault();
        }
        let next = this.clone({
          default: def
        });
        return next;
      }
      strict(isStrict = true) {
        return this.clone({
          strict: isStrict
        });
      }
      nullability(nullable, message) {
        const next = this.clone({
          nullable
        });
        next.internalTests.nullable = createValidation({
          message,
          name: "nullable",
          test(value) {
            return value === null ? this.schema.spec.nullable : true;
          }
        });
        return next;
      }
      optionality(optional, message) {
        const next = this.clone({
          optional
        });
        next.internalTests.optionality = createValidation({
          message,
          name: "optionality",
          test(value) {
            return value === void 0 ? this.schema.spec.optional : true;
          }
        });
        return next;
      }
      optional() {
        return this.optionality(true);
      }
      defined(message = mixed2.defined) {
        return this.optionality(false, message);
      }
      nullable() {
        return this.nullability(true);
      }
      nonNullable(message = mixed2.notNull) {
        return this.nullability(false, message);
      }
      required(message = mixed2.required) {
        return this.clone().withMutation((next) => next.nonNullable(message).defined(message));
      }
      notRequired() {
        return this.clone().withMutation((next) => next.nullable().optional());
      }
      transform(fn) {
        let next = this.clone();
        next.transforms.push(fn);
        return next;
      }
      /**
       * Adds a test function to the schema's queue of tests.
       * tests can be exclusive or non-exclusive.
       *
       * - exclusive tests, will replace any existing tests of the same name.
       * - non-exclusive: can be stacked
       *
       * If a non-exclusive test is added to a schema with an exclusive test of the same name
       * the exclusive test is removed and further tests of the same name will be stacked.
       *
       * If an exclusive test is added to a schema with non-exclusive tests of the same name
       * the previous tests are removed and further tests of the same name will replace each other.
       */
      test(...args) {
        let opts;
        if (args.length === 1) {
          if (typeof args[0] === "function") {
            opts = {
              test: args[0]
            };
          } else {
            opts = args[0];
          }
        } else if (args.length === 2) {
          opts = {
            name: args[0],
            test: args[1]
          };
        } else {
          opts = {
            name: args[0],
            message: args[1],
            test: args[2]
          };
        }
        if (opts.message === void 0)
          opts.message = mixed2.default;
        if (typeof opts.test !== "function")
          throw new TypeError("`test` is a required parameters");
        let next = this.clone();
        let validate = createValidation(opts);
        let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
        if (opts.exclusive) {
          if (!opts.name)
            throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
        }
        if (opts.name)
          next.exclusiveTests[opts.name] = !!opts.exclusive;
        next.tests = next.tests.filter((fn) => {
          if (fn.OPTIONS.name === opts.name) {
            if (isExclusive)
              return false;
            if (fn.OPTIONS.test === validate.OPTIONS.test)
              return false;
          }
          return true;
        });
        next.tests.push(validate);
        return next;
      }
      when(keys, options) {
        if (!Array.isArray(keys) && typeof keys !== "string") {
          options = keys;
          keys = ".";
        }
        let next = this.clone();
        let deps = toArray(keys).map((key) => new Reference(key));
        deps.forEach((dep) => {
          if (dep.isSibling)
            next.deps.push(dep.key);
        });
        next.conditions.push(typeof options === "function" ? new Condition(deps, options) : Condition.fromOptions(deps, options));
        return next;
      }
      typeError(message) {
        let next = this.clone();
        next.internalTests.typeError = createValidation({
          message,
          name: "typeError",
          skipAbsent: true,
          test(value) {
            if (!this.schema._typeCheck(value))
              return this.createError({
                params: {
                  type: this.schema.type
                }
              });
            return true;
          }
        });
        return next;
      }
      oneOf(enums, message = mixed2.oneOf) {
        let next = this.clone();
        enums.forEach((val) => {
          next._whitelist.add(val);
          next._blacklist.delete(val);
        });
        next.internalTests.whiteList = createValidation({
          message,
          name: "oneOf",
          skipAbsent: true,
          test(value) {
            let valids = this.schema._whitelist;
            let resolved = valids.resolveAll(this.resolve);
            return resolved.includes(value) ? true : this.createError({
              params: {
                values: Array.from(valids).join(", "),
                resolved
              }
            });
          }
        });
        return next;
      }
      notOneOf(enums, message = mixed2.notOneOf) {
        let next = this.clone();
        enums.forEach((val) => {
          next._blacklist.add(val);
          next._whitelist.delete(val);
        });
        next.internalTests.blacklist = createValidation({
          message,
          name: "notOneOf",
          test(value) {
            let invalids = this.schema._blacklist;
            let resolved = invalids.resolveAll(this.resolve);
            if (resolved.includes(value))
              return this.createError({
                params: {
                  values: Array.from(invalids).join(", "),
                  resolved
                }
              });
            return true;
          }
        });
        return next;
      }
      strip(strip = true) {
        let next = this.clone();
        next.spec.strip = strip;
        return next;
      }
      /**
       * Return a serialized description of the schema including validations, flags, types etc.
       *
       * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
       */
      describe(options) {
        const next = (options ? this.resolve(options) : this).clone();
        const {
          label,
          meta,
          optional,
          nullable
        } = next.spec;
        const description = {
          meta,
          label,
          optional,
          nullable,
          default: next.getDefault(options),
          type: next.type,
          oneOf: next._whitelist.describe(),
          notOneOf: next._blacklist.describe(),
          tests: next.tests.map((fn) => ({
            name: fn.OPTIONS.name,
            params: fn.OPTIONS.params
          })).filter((n2, idx, list) => list.findIndex((c) => c.name === n2.name) === idx)
        };
        return description;
      }
    };
    Schema.prototype.__isYupSchema__ = true;
    for (const method of ["validate", "validateSync"])
      Schema.prototype[`${method}At`] = function(path2, value, options = {}) {
        const {
          parent,
          parentPath,
          schema
        } = getIn(this, path2, value, options.context);
        return schema[method](parent && parent[parentPath], Object.assign({}, options, {
          parent,
          path: path2
        }));
      };
    for (const alias of ["equals", "is"])
      Schema.prototype[alias] = Schema.prototype.oneOf;
    for (const alias of ["not", "nope"])
      Schema.prototype[alias] = Schema.prototype.notOneOf;
    var returnsTrue = () => true;
    function create$8(spec) {
      return new MixedSchema(spec);
    }
    var MixedSchema = class extends Schema {
      constructor(spec) {
        super(typeof spec === "function" ? {
          type: "mixed",
          check: spec
        } : Object.assign({
          type: "mixed",
          check: returnsTrue
        }, spec));
      }
    };
    create$8.prototype = MixedSchema.prototype;
    function create$7() {
      return new BooleanSchema();
    }
    var BooleanSchema = class extends Schema {
      constructor() {
        super({
          type: "boolean",
          check(v) {
            if (v instanceof Boolean)
              v = v.valueOf();
            return typeof v === "boolean";
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (ctx.spec.coerce && !ctx.isType(value)) {
              if (/^(true|1)$/i.test(String(value)))
                return true;
              if (/^(false|0)$/i.test(String(value)))
                return false;
            }
            return value;
          });
        });
      }
      isTrue(message = boolean2.isValue) {
        return this.test({
          message,
          name: "is-value",
          exclusive: true,
          params: {
            value: "true"
          },
          test(value) {
            return isAbsent(value) || value === true;
          }
        });
      }
      isFalse(message = boolean2.isValue) {
        return this.test({
          message,
          name: "is-value",
          exclusive: true,
          params: {
            value: "false"
          },
          test(value) {
            return isAbsent(value) || value === false;
          }
        });
      }
      default(def) {
        return super.default(def);
      }
      defined(msg) {
        return super.defined(msg);
      }
      optional() {
        return super.optional();
      }
      required(msg) {
        return super.required(msg);
      }
      notRequired() {
        return super.notRequired();
      }
      nullable() {
        return super.nullable();
      }
      nonNullable(msg) {
        return super.nonNullable(msg);
      }
      strip(v) {
        return super.strip(v);
      }
    };
    create$7.prototype = BooleanSchema.prototype;
    var isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
    function parseIsoDate(date2) {
      const struct = parseDateStruct(date2);
      if (!struct)
        return Date.parse ? Date.parse(date2) : Number.NaN;
      if (struct.z === void 0 && struct.plusMinus === void 0) {
        return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
      }
      let totalMinutesOffset = 0;
      if (struct.z !== "Z" && struct.plusMinus !== void 0) {
        totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
        if (struct.plusMinus === "+")
          totalMinutesOffset = 0 - totalMinutesOffset;
      }
      return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
    }
    function parseDateStruct(date2) {
      var _regexResult$7$length, _regexResult$;
      const regexResult = isoReg.exec(date2);
      if (!regexResult)
        return null;
      return {
        year: toNumber(regexResult[1]),
        month: toNumber(regexResult[2], 1) - 1,
        day: toNumber(regexResult[3], 1),
        hour: toNumber(regexResult[4]),
        minute: toNumber(regexResult[5]),
        second: toNumber(regexResult[6]),
        millisecond: regexResult[7] ? (
          // allow arbitrary sub-second precision beyond milliseconds
          toNumber(regexResult[7].substring(0, 3))
        ) : 0,
        precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : void 0,
        z: regexResult[8] || void 0,
        plusMinus: regexResult[9] || void 0,
        hourOffset: toNumber(regexResult[10]),
        minuteOffset: toNumber(regexResult[11])
      };
    }
    function toNumber(str, defaultValue = 0) {
      return Number(str) || defaultValue;
    }
    var rEmail = (
      // eslint-disable-next-line
      /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
    );
    var rUrl = (
      // eslint-disable-next-line
      /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
    );
    var rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    var yearMonthDay = "^\\d{4}-\\d{2}-\\d{2}";
    var hourMinuteSecond = "\\d{2}:\\d{2}:\\d{2}";
    var zOrOffset = "(([+-]\\d{2}(:?\\d{2})?)|Z)";
    var rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`);
    var isTrimmed = (value) => isAbsent(value) || value === value.trim();
    var objStringTag = {}.toString();
    function create$6() {
      return new StringSchema();
    }
    var StringSchema = class extends Schema {
      constructor() {
        super({
          type: "string",
          check(value) {
            if (value instanceof String)
              value = value.valueOf();
            return typeof value === "string";
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce || ctx.isType(value))
              return value;
            if (Array.isArray(value))
              return value;
            const strValue = value != null && value.toString ? value.toString() : value;
            if (strValue === objStringTag)
              return value;
            return strValue;
          });
        });
      }
      required(message) {
        return super.required(message).withMutation((schema) => schema.test({
          message: message || mixed2.required,
          name: "required",
          skipAbsent: true,
          test: (value) => !!value.length
        }));
      }
      notRequired() {
        return super.notRequired().withMutation((schema) => {
          schema.tests = schema.tests.filter((t2) => t2.OPTIONS.name !== "required");
          return schema;
        });
      }
      length(length, message = string2.length) {
        return this.test({
          message,
          name: "length",
          exclusive: true,
          params: {
            length
          },
          skipAbsent: true,
          test(value) {
            return value.length === this.resolve(length);
          }
        });
      }
      min(min, message = string2.min) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          test(value) {
            return value.length >= this.resolve(min);
          }
        });
      }
      max(max, message = string2.max) {
        return this.test({
          name: "max",
          exclusive: true,
          message,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value.length <= this.resolve(max);
          }
        });
      }
      matches(regex, options) {
        let excludeEmptyString = false;
        let message;
        let name;
        if (options) {
          if (typeof options === "object") {
            ({
              excludeEmptyString = false,
              message,
              name
            } = options);
          } else {
            message = options;
          }
        }
        return this.test({
          name: name || "matches",
          message: message || string2.matches,
          params: {
            regex
          },
          skipAbsent: true,
          test: (value) => value === "" && excludeEmptyString || value.search(regex) !== -1
        });
      }
      email(message = string2.email) {
        return this.matches(rEmail, {
          name: "email",
          message,
          excludeEmptyString: true
        });
      }
      url(message = string2.url) {
        return this.matches(rUrl, {
          name: "url",
          message,
          excludeEmptyString: true
        });
      }
      uuid(message = string2.uuid) {
        return this.matches(rUUID, {
          name: "uuid",
          message,
          excludeEmptyString: false
        });
      }
      datetime(options) {
        let message = "";
        let allowOffset;
        let precision;
        if (options) {
          if (typeof options === "object") {
            ({
              message = "",
              allowOffset = false,
              precision = void 0
            } = options);
          } else {
            message = options;
          }
        }
        return this.matches(rIsoDateTime, {
          name: "datetime",
          message: message || string2.datetime,
          excludeEmptyString: true
        }).test({
          name: "datetime_offset",
          message: message || string2.datetime_offset,
          params: {
            allowOffset
          },
          skipAbsent: true,
          test: (value) => {
            if (!value || allowOffset)
              return true;
            const struct = parseDateStruct(value);
            if (!struct)
              return false;
            return !!struct.z;
          }
        }).test({
          name: "datetime_precision",
          message: message || string2.datetime_precision,
          params: {
            precision
          },
          skipAbsent: true,
          test: (value) => {
            if (!value || precision == void 0)
              return true;
            const struct = parseDateStruct(value);
            if (!struct)
              return false;
            return struct.precision === precision;
          }
        });
      }
      //-- transforms --
      ensure() {
        return this.default("").transform((val) => val === null ? "" : val);
      }
      trim(message = string2.trim) {
        return this.transform((val) => val != null ? val.trim() : val).test({
          message,
          name: "trim",
          test: isTrimmed
        });
      }
      lowercase(message = string2.lowercase) {
        return this.transform((value) => !isAbsent(value) ? value.toLowerCase() : value).test({
          message,
          name: "string_case",
          exclusive: true,
          skipAbsent: true,
          test: (value) => isAbsent(value) || value === value.toLowerCase()
        });
      }
      uppercase(message = string2.uppercase) {
        return this.transform((value) => !isAbsent(value) ? value.toUpperCase() : value).test({
          message,
          name: "string_case",
          exclusive: true,
          skipAbsent: true,
          test: (value) => isAbsent(value) || value === value.toUpperCase()
        });
      }
    };
    create$6.prototype = StringSchema.prototype;
    var isNaN$1 = (value) => value != +value;
    function create$5() {
      return new NumberSchema();
    }
    var NumberSchema = class extends Schema {
      constructor() {
        super({
          type: "number",
          check(value) {
            if (value instanceof Number)
              value = value.valueOf();
            return typeof value === "number" && !isNaN$1(value);
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce)
              return value;
            let parsed = value;
            if (typeof parsed === "string") {
              parsed = parsed.replace(/\s/g, "");
              if (parsed === "")
                return NaN;
              parsed = +parsed;
            }
            if (ctx.isType(parsed) || parsed === null)
              return parsed;
            return parseFloat(parsed);
          });
        });
      }
      min(min, message = number.min) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          test(value) {
            return value >= this.resolve(min);
          }
        });
      }
      max(max, message = number.max) {
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value <= this.resolve(max);
          }
        });
      }
      lessThan(less, message = number.lessThan) {
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            less
          },
          skipAbsent: true,
          test(value) {
            return value < this.resolve(less);
          }
        });
      }
      moreThan(more, message = number.moreThan) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            more
          },
          skipAbsent: true,
          test(value) {
            return value > this.resolve(more);
          }
        });
      }
      positive(msg = number.positive) {
        return this.moreThan(0, msg);
      }
      negative(msg = number.negative) {
        return this.lessThan(0, msg);
      }
      integer(message = number.integer) {
        return this.test({
          name: "integer",
          message,
          skipAbsent: true,
          test: (val) => Number.isInteger(val)
        });
      }
      truncate() {
        return this.transform((value) => !isAbsent(value) ? value | 0 : value);
      }
      round(method) {
        var _method;
        let avail = ["ceil", "floor", "round", "trunc"];
        method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
        if (method === "trunc")
          return this.truncate();
        if (avail.indexOf(method.toLowerCase()) === -1)
          throw new TypeError("Only valid options for round() are: " + avail.join(", "));
        return this.transform((value) => !isAbsent(value) ? Math[method](value) : value);
      }
    };
    create$5.prototype = NumberSchema.prototype;
    var invalidDate = /* @__PURE__ */ new Date("");
    var isDate2 = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
    function create$4() {
      return new DateSchema();
    }
    var DateSchema = class _DateSchema extends Schema {
      constructor() {
        super({
          type: "date",
          check(v) {
            return isDate2(v) && !isNaN(v.getTime());
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce || ctx.isType(value) || value === null)
              return value;
            value = parseIsoDate(value);
            return !isNaN(value) ? new Date(value) : _DateSchema.INVALID_DATE;
          });
        });
      }
      prepareParam(ref, name) {
        let param;
        if (!Reference.isRef(ref)) {
          let cast = this.cast(ref);
          if (!this._typeCheck(cast))
            throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
          param = cast;
        } else {
          param = ref;
        }
        return param;
      }
      min(min, message = date.min) {
        let limit = this.prepareParam(min, "min");
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          test(value) {
            return value >= this.resolve(limit);
          }
        });
      }
      max(max, message = date.max) {
        let limit = this.prepareParam(max, "max");
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value <= this.resolve(limit);
          }
        });
      }
    };
    DateSchema.INVALID_DATE = invalidDate;
    create$4.prototype = DateSchema.prototype;
    create$4.INVALID_DATE = invalidDate;
    function sortFields(fields, excludedEdges = []) {
      let edges = [];
      let nodes = /* @__PURE__ */ new Set();
      let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));
      function addNode(depPath, key) {
        let node = propertyExpr.split(depPath)[0];
        nodes.add(node);
        if (!excludes.has(`${key}-${node}`))
          edges.push([key, node]);
      }
      for (const key of Object.keys(fields)) {
        let value = fields[key];
        nodes.add(key);
        if (Reference.isRef(value) && value.isSibling)
          addNode(value.path, key);
        else if (isSchema(value) && "deps" in value)
          value.deps.forEach((path2) => addNode(path2, key));
      }
      return toposort__default["default"].array(Array.from(nodes), edges).reverse();
    }
    function findIndex(arr2, err) {
      let idx = Infinity;
      arr2.some((key, ii) => {
        var _err$path;
        if ((_err$path = err.path) != null && _err$path.includes(key)) {
          idx = ii;
          return true;
        }
      });
      return idx;
    }
    function sortByKeyOrder(keys) {
      return (a, b) => {
        return findIndex(keys, a) - findIndex(keys, b);
      };
    }
    var parseJson = (value, _, ctx) => {
      if (typeof value !== "string") {
        return value;
      }
      let parsed = value;
      try {
        parsed = JSON.parse(value);
      } catch (err) {
      }
      return ctx.isType(parsed) ? parsed : value;
    };
    function deepPartial(schema) {
      if ("fields" in schema) {
        const partial = {};
        for (const [key, fieldSchema] of Object.entries(schema.fields)) {
          partial[key] = deepPartial(fieldSchema);
        }
        return schema.setFields(partial);
      }
      if (schema.type === "array") {
        const nextArray = schema.optional();
        if (nextArray.innerType)
          nextArray.innerType = deepPartial(nextArray.innerType);
        return nextArray;
      }
      if (schema.type === "tuple") {
        return schema.optional().clone({
          types: schema.spec.types.map(deepPartial)
        });
      }
      if ("optional" in schema) {
        return schema.optional();
      }
      return schema;
    }
    var deepHas = (obj, p) => {
      const path2 = [...propertyExpr.normalizePath(p)];
      if (path2.length === 1)
        return path2[0] in obj;
      let last = path2.pop();
      let parent = propertyExpr.getter(propertyExpr.join(path2), true)(obj);
      return !!(parent && last in parent);
    };
    var isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
    function unknown(ctx, value) {
      let known = Object.keys(ctx.fields);
      return Object.keys(value).filter((key) => known.indexOf(key) === -1);
    }
    var defaultSort = sortByKeyOrder([]);
    function create$3(spec) {
      return new ObjectSchema(spec);
    }
    var ObjectSchema = class extends Schema {
      constructor(spec) {
        super({
          type: "object",
          check(value) {
            return isObject(value) || typeof value === "function";
          }
        });
        this.fields = /* @__PURE__ */ Object.create(null);
        this._sortErrors = defaultSort;
        this._nodes = [];
        this._excludedEdges = [];
        this.withMutation(() => {
          if (spec) {
            this.shape(spec);
          }
        });
      }
      _cast(_value, options = {}) {
        var _options$stripUnknown;
        let value = super._cast(_value, options);
        if (value === void 0)
          return this.getDefault(options);
        if (!this._typeCheck(value))
          return value;
        let fields = this.fields;
        let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
        let props = [].concat(this._nodes, Object.keys(value).filter((v) => !this._nodes.includes(v)));
        let intermediateValue = {};
        let innerOptions = Object.assign({}, options, {
          parent: intermediateValue,
          __validating: options.__validating || false
        });
        let isChanged = false;
        for (const prop of props) {
          let field = fields[prop];
          let exists2 = prop in value;
          if (field) {
            let fieldValue;
            let inputValue = value[prop];
            innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
            field = field.resolve({
              value: inputValue,
              context: options.context,
              parent: intermediateValue
            });
            let fieldSpec = field instanceof Schema ? field.spec : void 0;
            let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
            if (fieldSpec != null && fieldSpec.strip) {
              isChanged = isChanged || prop in value;
              continue;
            }
            fieldValue = !options.__validating || !strict ? (
              // TODO: use _cast, this is double resolving
              field.cast(value[prop], innerOptions)
            ) : value[prop];
            if (fieldValue !== void 0) {
              intermediateValue[prop] = fieldValue;
            }
          } else if (exists2 && !strip) {
            intermediateValue[prop] = value[prop];
          }
          if (exists2 !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
            isChanged = true;
          }
        }
        return isChanged ? intermediateValue : value;
      }
      _validate(_value, options = {}, panic, next) {
        let {
          from = [],
          originalValue = _value,
          recursive = this.spec.recursive
        } = options;
        options.from = [{
          schema: this,
          value: originalValue
        }, ...from];
        options.__validating = true;
        options.originalValue = originalValue;
        super._validate(_value, options, panic, (objectErrors, value) => {
          if (!recursive || !isObject(value)) {
            next(objectErrors, value);
            return;
          }
          originalValue = originalValue || value;
          let tests = [];
          for (let key of this._nodes) {
            let field = this.fields[key];
            if (!field || Reference.isRef(field)) {
              continue;
            }
            tests.push(field.asNestedTest({
              options,
              key,
              parent: value,
              parentPath: options.path,
              originalParent: originalValue
            }));
          }
          this.runTests({
            tests,
            value,
            originalValue,
            options
          }, panic, (fieldErrors) => {
            next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
          });
        });
      }
      clone(spec) {
        const next = super.clone(spec);
        next.fields = Object.assign({}, this.fields);
        next._nodes = this._nodes;
        next._excludedEdges = this._excludedEdges;
        next._sortErrors = this._sortErrors;
        return next;
      }
      concat(schema) {
        let next = super.concat(schema);
        let nextFields = next.fields;
        for (let [field, schemaOrRef] of Object.entries(this.fields)) {
          const target = nextFields[field];
          nextFields[field] = target === void 0 ? schemaOrRef : target;
        }
        return next.withMutation((s2) => (
          // XXX: excludes here is wrong
          s2.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges])
        ));
      }
      _getDefault(options) {
        if ("default" in this.spec) {
          return super._getDefault(options);
        }
        if (!this._nodes.length) {
          return void 0;
        }
        let dft = {};
        this._nodes.forEach((key) => {
          var _innerOptions;
          const field = this.fields[key];
          let innerOptions = options;
          if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[key]
            });
          }
          dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : void 0;
        });
        return dft;
      }
      setFields(shape, excludedEdges) {
        let next = this.clone();
        next.fields = shape;
        next._nodes = sortFields(shape, excludedEdges);
        next._sortErrors = sortByKeyOrder(Object.keys(shape));
        if (excludedEdges)
          next._excludedEdges = excludedEdges;
        return next;
      }
      shape(additions, excludes = []) {
        return this.clone().withMutation((next) => {
          let edges = next._excludedEdges;
          if (excludes.length) {
            if (!Array.isArray(excludes[0]))
              excludes = [excludes];
            edges = [...next._excludedEdges, ...excludes];
          }
          return next.setFields(Object.assign(next.fields, additions), edges);
        });
      }
      partial() {
        const partial = {};
        for (const [key, schema] of Object.entries(this.fields)) {
          partial[key] = "optional" in schema && schema.optional instanceof Function ? schema.optional() : schema;
        }
        return this.setFields(partial);
      }
      deepPartial() {
        const next = deepPartial(this);
        return next;
      }
      pick(keys) {
        const picked = {};
        for (const key of keys) {
          if (this.fields[key])
            picked[key] = this.fields[key];
        }
        return this.setFields(picked, this._excludedEdges.filter(([a, b]) => keys.includes(a) && keys.includes(b)));
      }
      omit(keys) {
        const remaining = [];
        for (const key of Object.keys(this.fields)) {
          if (keys.includes(key))
            continue;
          remaining.push(key);
        }
        return this.pick(remaining);
      }
      from(from, to, alias) {
        let fromGetter = propertyExpr.getter(from, true);
        return this.transform((obj) => {
          if (!obj)
            return obj;
          let newObj = obj;
          if (deepHas(obj, from)) {
            newObj = Object.assign({}, obj);
            if (!alias)
              delete newObj[from];
            newObj[to] = fromGetter(obj);
          }
          return newObj;
        });
      }
      /** Parse an input JSON string to an object */
      json() {
        return this.transform(parseJson);
      }
      noUnknown(noAllow = true, message = object2.noUnknown) {
        if (typeof noAllow !== "boolean") {
          message = noAllow;
          noAllow = true;
        }
        let next = this.test({
          name: "noUnknown",
          exclusive: true,
          message,
          test(value) {
            if (value == null)
              return true;
            const unknownKeys = unknown(this.schema, value);
            return !noAllow || unknownKeys.length === 0 || this.createError({
              params: {
                unknown: unknownKeys.join(", ")
              }
            });
          }
        });
        next.spec.noUnknown = noAllow;
        return next;
      }
      unknown(allow = true, message = object2.noUnknown) {
        return this.noUnknown(!allow, message);
      }
      transformKeys(fn) {
        return this.transform((obj) => {
          if (!obj)
            return obj;
          const result = {};
          for (const key of Object.keys(obj))
            result[fn(key)] = obj[key];
          return result;
        });
      }
      camelCase() {
        return this.transformKeys(tinyCase.camelCase);
      }
      snakeCase() {
        return this.transformKeys(tinyCase.snakeCase);
      }
      constantCase() {
        return this.transformKeys((key) => tinyCase.snakeCase(key).toUpperCase());
      }
      describe(options) {
        const next = (options ? this.resolve(options) : this).clone();
        const base = super.describe(options);
        base.fields = {};
        for (const [key, value] of Object.entries(next.fields)) {
          var _innerOptions2;
          let innerOptions = options;
          if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[key]
            });
          }
          base.fields[key] = value.describe(innerOptions);
        }
        return base;
      }
    };
    create$3.prototype = ObjectSchema.prototype;
    function create$2(type) {
      return new ArraySchema(type);
    }
    var ArraySchema = class extends Schema {
      constructor(type) {
        super({
          type: "array",
          spec: {
            types: type
          },
          check(v) {
            return Array.isArray(v);
          }
        });
        this.innerType = void 0;
        this.innerType = type;
      }
      _cast(_value, _opts) {
        const value = super._cast(_value, _opts);
        if (!this._typeCheck(value) || !this.innerType) {
          return value;
        }
        let isChanged = false;
        const castArray = value.map((v, idx) => {
          const castElement = this.innerType.cast(v, Object.assign({}, _opts, {
            path: `${_opts.path || ""}[${idx}]`
          }));
          if (castElement !== v) {
            isChanged = true;
          }
          return castElement;
        });
        return isChanged ? castArray : value;
      }
      _validate(_value, options = {}, panic, next) {
        var _options$recursive;
        let innerType = this.innerType;
        let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
        options.originalValue != null ? options.originalValue : _value;
        super._validate(_value, options, panic, (arrayErrors, value) => {
          var _options$originalValu2;
          if (!recursive || !innerType || !this._typeCheck(value)) {
            next(arrayErrors, value);
            return;
          }
          let tests = new Array(value.length);
          for (let index2 = 0; index2 < value.length; index2++) {
            var _options$originalValu;
            tests[index2] = innerType.asNestedTest({
              options,
              index: index2,
              parent: value,
              parentPath: options.path,
              originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
            });
          }
          this.runTests({
            value,
            tests,
            originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
            options
          }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(arrayErrors), value));
        });
      }
      clone(spec) {
        const next = super.clone(spec);
        next.innerType = this.innerType;
        return next;
      }
      /** Parse an input JSON string to an object */
      json() {
        return this.transform(parseJson);
      }
      concat(schema) {
        let next = super.concat(schema);
        next.innerType = this.innerType;
        if (schema.innerType)
          next.innerType = next.innerType ? (
            // @ts-expect-error Lazy doesn't have concat and will break
            next.innerType.concat(schema.innerType)
          ) : schema.innerType;
        return next;
      }
      of(schema) {
        let next = this.clone();
        if (!isSchema(schema))
          throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
        next.innerType = schema;
        next.spec = Object.assign({}, next.spec, {
          types: schema
        });
        return next;
      }
      length(length, message = array2.length) {
        return this.test({
          message,
          name: "length",
          exclusive: true,
          params: {
            length
          },
          skipAbsent: true,
          test(value) {
            return value.length === this.resolve(length);
          }
        });
      }
      min(min, message) {
        message = message || array2.min;
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          // FIXME(ts): Array<typeof T>
          test(value) {
            return value.length >= this.resolve(min);
          }
        });
      }
      max(max, message) {
        message = message || array2.max;
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value.length <= this.resolve(max);
          }
        });
      }
      ensure() {
        return this.default(() => []).transform((val, original) => {
          if (this._typeCheck(val))
            return val;
          return original == null ? [] : [].concat(original);
        });
      }
      compact(rejector) {
        let reject = !rejector ? (v) => !!v : (v, i, a) => !rejector(v, i, a);
        return this.transform((values) => values != null ? values.filter(reject) : values);
      }
      describe(options) {
        const next = (options ? this.resolve(options) : this).clone();
        const base = super.describe(options);
        if (next.innerType) {
          var _innerOptions;
          let innerOptions = options;
          if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[0]
            });
          }
          base.innerType = next.innerType.describe(innerOptions);
        }
        return base;
      }
    };
    create$2.prototype = ArraySchema.prototype;
    function create$1(schemas) {
      return new TupleSchema(schemas);
    }
    var TupleSchema = class extends Schema {
      constructor(schemas) {
        super({
          type: "tuple",
          spec: {
            types: schemas
          },
          check(v) {
            const types2 = this.spec.types;
            return Array.isArray(v) && v.length === types2.length;
          }
        });
        this.withMutation(() => {
          this.typeError(tuple.notType);
        });
      }
      _cast(inputValue, options) {
        const {
          types: types2
        } = this.spec;
        const value = super._cast(inputValue, options);
        if (!this._typeCheck(value)) {
          return value;
        }
        let isChanged = false;
        const castArray = types2.map((type, idx) => {
          const castElement = type.cast(value[idx], Object.assign({}, options, {
            path: `${options.path || ""}[${idx}]`
          }));
          if (castElement !== value[idx])
            isChanged = true;
          return castElement;
        });
        return isChanged ? castArray : value;
      }
      _validate(_value, options = {}, panic, next) {
        let itemTypes = this.spec.types;
        super._validate(_value, options, panic, (tupleErrors, value) => {
          var _options$originalValu2;
          if (!this._typeCheck(value)) {
            next(tupleErrors, value);
            return;
          }
          let tests = [];
          for (let [index2, itemSchema] of itemTypes.entries()) {
            var _options$originalValu;
            tests[index2] = itemSchema.asNestedTest({
              options,
              index: index2,
              parent: value,
              parentPath: options.path,
              originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
            });
          }
          this.runTests({
            value,
            tests,
            originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
            options
          }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(tupleErrors), value));
        });
      }
      describe(options) {
        const next = (options ? this.resolve(options) : this).clone();
        const base = super.describe(options);
        base.innerType = next.spec.types.map((schema, index2) => {
          var _innerOptions;
          let innerOptions = options;
          if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[index2]
            });
          }
          return schema.describe(innerOptions);
        });
        return base;
      }
    };
    create$1.prototype = TupleSchema.prototype;
    function create3(builder) {
      return new Lazy(builder);
    }
    var Lazy = class _Lazy {
      constructor(builder) {
        this.type = "lazy";
        this.__isYupSchema__ = true;
        this.spec = void 0;
        this._resolve = (value, options = {}) => {
          let schema = this.builder(value, options);
          if (!isSchema(schema))
            throw new TypeError("lazy() functions must return a valid schema");
          if (this.spec.optional)
            schema = schema.optional();
          return schema.resolve(options);
        };
        this.builder = builder;
        this.spec = {
          meta: void 0,
          optional: false
        };
      }
      clone(spec) {
        const next = new _Lazy(this.builder);
        next.spec = Object.assign({}, this.spec, spec);
        return next;
      }
      optionality(optional) {
        const next = this.clone({
          optional
        });
        return next;
      }
      optional() {
        return this.optionality(true);
      }
      resolve(options) {
        return this._resolve(options.value, options);
      }
      cast(value, options) {
        return this._resolve(value, options).cast(value, options);
      }
      asNestedTest(config) {
        let {
          key,
          index: index2,
          parent,
          options
        } = config;
        let value = parent[index2 != null ? index2 : key];
        return this._resolve(value, Object.assign({}, options, {
          value,
          parent
        })).asNestedTest(config);
      }
      validate(value, options) {
        return this._resolve(value, options).validate(value, options);
      }
      validateSync(value, options) {
        return this._resolve(value, options).validateSync(value, options);
      }
      validateAt(path2, value, options) {
        return this._resolve(value, options).validateAt(path2, value, options);
      }
      validateSyncAt(path2, value, options) {
        return this._resolve(value, options).validateSyncAt(path2, value, options);
      }
      isValid(value, options) {
        return this._resolve(value, options).isValid(value, options);
      }
      isValidSync(value, options) {
        return this._resolve(value, options).isValidSync(value, options);
      }
      describe(options) {
        return options ? this.resolve(options).describe(options) : {
          type: "lazy",
          meta: this.spec.meta,
          label: void 0
        };
      }
      meta(...args) {
        if (args.length === 0)
          return this.spec.meta;
        let next = this.clone();
        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
        return next;
      }
    };
    function setLocale(custom) {
      Object.keys(custom).forEach((type) => {
        Object.keys(custom[type]).forEach((method) => {
          locale[type][method] = custom[type][method];
        });
      });
    }
    function addMethod(schemaType, name, fn) {
      if (!schemaType || !isSchema(schemaType.prototype))
        throw new TypeError("You must provide a yup schema constructor function");
      if (typeof name !== "string")
        throw new TypeError("A Method name must be provided");
      if (typeof fn !== "function")
        throw new TypeError("Method function must be provided");
      schemaType.prototype[name] = fn;
    }
    exports.ArraySchema = ArraySchema;
    exports.BooleanSchema = BooleanSchema;
    exports.DateSchema = DateSchema;
    exports.MixedSchema = MixedSchema;
    exports.NumberSchema = NumberSchema;
    exports.ObjectSchema = ObjectSchema;
    exports.Schema = Schema;
    exports.StringSchema = StringSchema;
    exports.TupleSchema = TupleSchema;
    exports.ValidationError = ValidationError;
    exports.addMethod = addMethod;
    exports.array = create$2;
    exports.bool = create$7;
    exports.boolean = create$7;
    exports.date = create$4;
    exports.defaultLocale = locale;
    exports.getIn = getIn;
    exports.isSchema = isSchema;
    exports.lazy = create3;
    exports.mixed = create$8;
    exports.number = create$5;
    exports.object = create$3;
    exports.printValue = printValue;
    exports.reach = reach;
    exports.ref = create$9;
    exports.setLocale = setLocale;
    exports.string = create$6;
    exports.tuple = create$1;
  }
});

// ../../../node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter2,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s2, e) {
  var t2 = {};
  for (var p in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
      t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
        t2[p[i]] = s2[p[i]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports) {
  for (var p in m)
    if (p !== "default" && !exports.hasOwnProperty(p))
      exports[p] = m[p];
}
function __values(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n2) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i = 0, il = arguments.length; i < il; i++)
    s2 += arguments[i].length;
  for (var r = Array(s2), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g[n2])
      i[n2] = function(v) {
        return new Promise(function(a, b) {
          q.push([n2, v, a, b]) > 1 || resume(n2, v);
        });
      };
  }
  function resume(n2, v) {
    try {
      step(g[n2](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n2, f) {
    i[n2] = o[n2] ? function(v) {
      return (p = !p) ? { value: __await(o[n2](v)), done: n2 === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o[n2] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n2](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (Object.hasOwnProperty.call(mod, k))
        result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "../../../node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t2) {
        for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
          s2 = arguments[i];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t2[p] = s2[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/base64.js
var require_base64 = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeFromBase64DataUri = exports.decodeFromBase64 = exports.encodeToBase64 = void 0;
    var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup9 = new Uint8Array(256);
    for (i = 0; i < chars2.length; i++) {
      lookup9[chars2.charCodeAt(i)] = i;
    }
    var i;
    exports.encodeToBase64 = function(bytes) {
      var base64 = "";
      var len = bytes.length;
      for (var i2 = 0; i2 < len; i2 += 3) {
        base64 += chars2[bytes[i2] >> 2];
        base64 += chars2[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
        base64 += chars2[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
        base64 += chars2[bytes[i2 + 2] & 63];
      }
      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    exports.decodeFromBase64 = function(base64) {
      var bufferLength = base64.length * 0.75;
      var len = base64.length;
      var i2;
      var p = 0;
      var encoded1;
      var encoded2;
      var encoded3;
      var encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      var bytes = new Uint8Array(bufferLength);
      for (i2 = 0; i2 < len; i2 += 4) {
        encoded1 = lookup9[base64.charCodeAt(i2)];
        encoded2 = lookup9[base64.charCodeAt(i2 + 1)];
        encoded3 = lookup9[base64.charCodeAt(i2 + 2)];
        encoded4 = lookup9[base64.charCodeAt(i2 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return bytes;
    };
    var DATA_URI_PREFIX_REGEX = /^(data)?:?([\w\/\+]+)?;?(charset=[\w-]+|base64)?.*,/i;
    exports.decodeFromBase64DataUri = function(dataUri) {
      var trimmedUri = dataUri.trim();
      var prefix = trimmedUri.substring(0, 100);
      var res = prefix.match(DATA_URI_PREFIX_REGEX);
      if (!res)
        return exports.decodeFromBase64(trimmedUri);
      var fullMatch = res[0];
      var data = trimmedUri.substring(fullMatch.length);
      return exports.decodeFromBase64(data);
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/strings.js
var require_strings = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findLastMatch = exports.parseDate = exports.breakTextIntoLines = exports.charSplit = exports.charAtIndex = exports.mergeLines = exports.lineSplit = exports.isNewlineChar = exports.newlineChars = exports.escapedNewlineChars = exports.cleanText = exports.escapeRegExp = exports.addRandomSuffix = exports.copyStringIntoBuffer = exports.padStart = exports.charFromHexCode = exports.charFromCode = exports.toHexString = exports.toHexStringOfMinLength = exports.toCodePoint = exports.toCharCode = void 0;
    exports.toCharCode = function(character) {
      return character.charCodeAt(0);
    };
    exports.toCodePoint = function(character) {
      return character.codePointAt(0);
    };
    exports.toHexStringOfMinLength = function(num, minLength) {
      return exports.padStart(num.toString(16), minLength, "0").toUpperCase();
    };
    exports.toHexString = function(num) {
      return exports.toHexStringOfMinLength(num, 2);
    };
    exports.charFromCode = function(code) {
      return String.fromCharCode(code);
    };
    exports.charFromHexCode = function(hex) {
      return exports.charFromCode(parseInt(hex, 16));
    };
    exports.padStart = function(value, length, padChar) {
      var padding = "";
      for (var idx = 0, len = length - value.length; idx < len; idx++) {
        padding += padChar;
      }
      return padding + value;
    };
    exports.copyStringIntoBuffer = function(str, buffer, offset2) {
      var length = str.length;
      for (var idx = 0; idx < length; idx++) {
        buffer[offset2++] = str.charCodeAt(idx);
      }
      return length;
    };
    exports.addRandomSuffix = function(prefix, suffixLength) {
      if (suffixLength === void 0) {
        suffixLength = 4;
      }
      return prefix + "-" + Math.floor(Math.random() * Math.pow(10, suffixLength));
    };
    exports.escapeRegExp = function(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    };
    exports.cleanText = function(text) {
      return text.replace(/\t|\u0085|\u2028|\u2029/g, "    ").replace(/[\b\v]/g, "");
    };
    exports.escapedNewlineChars = ["\\n", "\\f", "\\r", "\\u000B"];
    exports.newlineChars = ["\n", "\f", "\r", "\v"];
    exports.isNewlineChar = function(text) {
      return /^[\n\f\r\u000B]$/.test(text);
    };
    exports.lineSplit = function(text) {
      return text.split(/[\n\f\r\u000B]/);
    };
    exports.mergeLines = function(text) {
      return text.replace(/[\n\f\r\u000B]/g, " ");
    };
    exports.charAtIndex = function(text, index2) {
      var cuFirst = text.charCodeAt(index2);
      var cuSecond;
      var nextIndex = index2 + 1;
      var length = 1;
      if (
        // Check if it's the start of a surrogate pair.
        cuFirst >= 55296 && cuFirst <= 56319 && // high surrogate
        text.length > nextIndex
      ) {
        cuSecond = text.charCodeAt(nextIndex);
        if (cuSecond >= 56320 && cuSecond <= 57343)
          length = 2;
      }
      return [text.slice(index2, index2 + length), length];
    };
    exports.charSplit = function(text) {
      var chars2 = [];
      for (var idx = 0, len = text.length; idx < len; ) {
        var _a = exports.charAtIndex(text, idx), c = _a[0], cLen = _a[1];
        chars2.push(c);
        idx += cLen;
      }
      return chars2;
    };
    var buildWordBreakRegex = function(wordBreaks) {
      var newlineCharUnion = exports.escapedNewlineChars.join("|");
      var escapedRules = ["$"];
      for (var idx = 0, len = wordBreaks.length; idx < len; idx++) {
        var wordBreak = wordBreaks[idx];
        if (exports.isNewlineChar(wordBreak)) {
          throw new TypeError("`wordBreak` must not include " + newlineCharUnion);
        }
        escapedRules.push(wordBreak === "" ? "." : exports.escapeRegExp(wordBreak));
      }
      var breakRules = escapedRules.join("|");
      return new RegExp("(" + newlineCharUnion + ")|((.*?)(" + breakRules + "))", "gm");
    };
    exports.breakTextIntoLines = function(text, wordBreaks, maxWidth, computeWidthOfText) {
      var regex = buildWordBreakRegex(wordBreaks);
      var words = exports.cleanText(text).match(regex);
      var currLine = "";
      var currWidth = 0;
      var lines = [];
      var pushCurrLine = function() {
        if (currLine !== "")
          lines.push(currLine);
        currLine = "";
        currWidth = 0;
      };
      for (var idx = 0, len = words.length; idx < len; idx++) {
        var word = words[idx];
        if (exports.isNewlineChar(word)) {
          pushCurrLine();
        } else {
          var width = computeWidthOfText(word);
          if (currWidth + width > maxWidth)
            pushCurrLine();
          currLine += word;
          currWidth += width;
        }
      }
      pushCurrLine();
      return lines;
    };
    var dateRegex = /^D:(\d\d\d\d)(\d\d)?(\d\d)?(\d\d)?(\d\d)?(\d\d)?([+\-Z])?(\d\d)?'?(\d\d)?'?$/;
    exports.parseDate = function(dateStr) {
      var match2 = dateStr.match(dateRegex);
      if (!match2)
        return void 0;
      var year = match2[1], _a = match2[2], month = _a === void 0 ? "01" : _a, _b = match2[3], day = _b === void 0 ? "01" : _b, _c = match2[4], hours = _c === void 0 ? "00" : _c, _d = match2[5], mins = _d === void 0 ? "00" : _d, _e = match2[6], secs = _e === void 0 ? "00" : _e, _f = match2[7], offsetSign = _f === void 0 ? "Z" : _f, _g = match2[8], offsetHours = _g === void 0 ? "00" : _g, _h = match2[9], offsetMins = _h === void 0 ? "00" : _h;
      var tzOffset = offsetSign === "Z" ? "Z" : "" + offsetSign + offsetHours + ":" + offsetMins;
      var date = /* @__PURE__ */ new Date(year + "-" + month + "-" + day + "T" + hours + ":" + mins + ":" + secs + tzOffset);
      return date;
    };
    exports.findLastMatch = function(value, regex) {
      var _a;
      var position = 0;
      var lastMatch;
      while (position < value.length) {
        var match2 = value.substring(position).match(regex);
        if (!match2)
          return { match: lastMatch, pos: position };
        lastMatch = match2;
        position += ((_a = match2.index) !== null && _a !== void 0 ? _a : 0) + match2[0].length;
      }
      return { match: lastMatch, pos: position };
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/arrays.js
var require_arrays = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/arrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUint8Array = exports.canBeConvertedToUint8Array = exports.pluckIndices = exports.range = exports.sum = exports.reverseArray = exports.sortedUniq = exports.byAscendingId = exports.arrayAsString = exports.mergeUint8Arrays = exports.mergeIntoTypedArray = exports.typedArrayFor = exports.last = void 0;
    var base64_1 = require_base64();
    var strings_1 = require_strings();
    exports.last = function(array2) {
      return array2[array2.length - 1];
    };
    exports.typedArrayFor = function(value) {
      if (value instanceof Uint8Array)
        return value;
      var length = value.length;
      var typedArray = new Uint8Array(length);
      for (var idx = 0; idx < length; idx++) {
        typedArray[idx] = value.charCodeAt(idx);
      }
      return typedArray;
    };
    exports.mergeIntoTypedArray = function() {
      var arrays = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arrays[_i] = arguments[_i];
      }
      var arrayCount = arrays.length;
      var typedArrays = [];
      for (var idx = 0; idx < arrayCount; idx++) {
        var element = arrays[idx];
        typedArrays[idx] = element instanceof Uint8Array ? element : exports.typedArrayFor(element);
      }
      var totalSize = 0;
      for (var idx = 0; idx < arrayCount; idx++) {
        totalSize += arrays[idx].length;
      }
      var merged = new Uint8Array(totalSize);
      var offset2 = 0;
      for (var arrIdx = 0; arrIdx < arrayCount; arrIdx++) {
        var arr2 = typedArrays[arrIdx];
        for (var byteIdx = 0, arrLen = arr2.length; byteIdx < arrLen; byteIdx++) {
          merged[offset2++] = arr2[byteIdx];
        }
      }
      return merged;
    };
    exports.mergeUint8Arrays = function(arrays) {
      var totalSize = 0;
      for (var idx = 0, len = arrays.length; idx < len; idx++) {
        totalSize += arrays[idx].length;
      }
      var mergedBuffer = new Uint8Array(totalSize);
      var offset2 = 0;
      for (var idx = 0, len = arrays.length; idx < len; idx++) {
        var array2 = arrays[idx];
        mergedBuffer.set(array2, offset2);
        offset2 += array2.length;
      }
      return mergedBuffer;
    };
    exports.arrayAsString = function(array2) {
      var str = "";
      for (var idx = 0, len = array2.length; idx < len; idx++) {
        str += strings_1.charFromCode(array2[idx]);
      }
      return str;
    };
    exports.byAscendingId = function(a, b) {
      return a.id - b.id;
    };
    exports.sortedUniq = function(array2, indexer) {
      var uniq = [];
      for (var idx = 0, len = array2.length; idx < len; idx++) {
        var curr = array2[idx];
        var prev = array2[idx - 1];
        if (idx === 0 || indexer(curr) !== indexer(prev)) {
          uniq.push(curr);
        }
      }
      return uniq;
    };
    exports.reverseArray = function(array2) {
      var arrayLen = array2.length;
      for (var idx = 0, len = Math.floor(arrayLen / 2); idx < len; idx++) {
        var leftIdx = idx;
        var rightIdx = arrayLen - idx - 1;
        var temp = array2[idx];
        array2[leftIdx] = array2[rightIdx];
        array2[rightIdx] = temp;
      }
      return array2;
    };
    exports.sum = function(array2) {
      var total = 0;
      for (var idx = 0, len = array2.length; idx < len; idx++) {
        total += array2[idx];
      }
      return total;
    };
    exports.range = function(start, end) {
      var arr2 = new Array(end - start);
      for (var idx = 0, len = arr2.length; idx < len; idx++) {
        arr2[idx] = start + idx;
      }
      return arr2;
    };
    exports.pluckIndices = function(arr2, indices) {
      var plucked = new Array(indices.length);
      for (var idx = 0, len = indices.length; idx < len; idx++) {
        plucked[idx] = arr2[indices[idx]];
      }
      return plucked;
    };
    exports.canBeConvertedToUint8Array = function(input) {
      return input instanceof Uint8Array || input instanceof ArrayBuffer || typeof input === "string";
    };
    exports.toUint8Array = function(input) {
      if (typeof input === "string") {
        return base64_1.decodeFromBase64DataUri(input);
      } else if (input instanceof ArrayBuffer) {
        return new Uint8Array(input);
      } else if (input instanceof Uint8Array) {
        return input;
      } else {
        throw new TypeError("`input` must be one of `string | ArrayBuffer | Uint8Array`");
      }
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/async.js
var require_async = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.waitForTick = void 0;
    exports.waitForTick = function() {
      return new Promise(function(resolve) {
        setTimeout(function() {
          return resolve();
        }, 0);
      });
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/unicode.js
var require_unicode = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/unicode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasUtf16BOM = exports.utf16Decode = exports.lowSurrogate = exports.highSurrogate = exports.hasSurrogates = exports.isWithinBMP = exports.utf16Encode = exports.utf8Encode = void 0;
    var strings_1 = require_strings();
    exports.utf8Encode = function(input, byteOrderMark) {
      if (byteOrderMark === void 0) {
        byteOrderMark = true;
      }
      var encoded = [];
      if (byteOrderMark)
        encoded.push(239, 187, 191);
      for (var idx = 0, len = input.length; idx < len; ) {
        var codePoint = input.codePointAt(idx);
        if (codePoint < 128) {
          var byte1 = codePoint & 127;
          encoded.push(byte1);
          idx += 1;
        } else if (codePoint < 2048) {
          var byte1 = codePoint >> 6 & 31 | 192;
          var byte2 = codePoint & 63 | 128;
          encoded.push(byte1, byte2);
          idx += 1;
        } else if (codePoint < 65536) {
          var byte1 = codePoint >> 12 & 15 | 224;
          var byte2 = codePoint >> 6 & 63 | 128;
          var byte3 = codePoint & 63 | 128;
          encoded.push(byte1, byte2, byte3);
          idx += 1;
        } else if (codePoint < 1114112) {
          var byte1 = codePoint >> 18 & 7 | 240;
          var byte2 = codePoint >> 12 & 63 | 128;
          var byte3 = codePoint >> 6 & 63 | 128;
          var byte4 = codePoint >> 0 & 63 | 128;
          encoded.push(byte1, byte2, byte3, byte4);
          idx += 2;
        } else
          throw new Error("Invalid code point: 0x" + strings_1.toHexString(codePoint));
      }
      return new Uint8Array(encoded);
    };
    exports.utf16Encode = function(input, byteOrderMark) {
      if (byteOrderMark === void 0) {
        byteOrderMark = true;
      }
      var encoded = [];
      if (byteOrderMark)
        encoded.push(65279);
      for (var idx = 0, len = input.length; idx < len; ) {
        var codePoint = input.codePointAt(idx);
        if (codePoint < 65536) {
          encoded.push(codePoint);
          idx += 1;
        } else if (codePoint < 1114112) {
          encoded.push(exports.highSurrogate(codePoint), exports.lowSurrogate(codePoint));
          idx += 2;
        } else
          throw new Error("Invalid code point: 0x" + strings_1.toHexString(codePoint));
      }
      return new Uint16Array(encoded);
    };
    exports.isWithinBMP = function(codePoint) {
      return codePoint >= 0 && codePoint <= 65535;
    };
    exports.hasSurrogates = function(codePoint) {
      return codePoint >= 65536 && codePoint <= 1114111;
    };
    exports.highSurrogate = function(codePoint) {
      return Math.floor((codePoint - 65536) / 1024) + 55296;
    };
    exports.lowSurrogate = function(codePoint) {
      return (codePoint - 65536) % 1024 + 56320;
    };
    var ByteOrder;
    (function(ByteOrder2) {
      ByteOrder2["BigEndian"] = "BigEndian";
      ByteOrder2["LittleEndian"] = "LittleEndian";
    })(ByteOrder || (ByteOrder = {}));
    var REPLACEMENT = "\uFFFD".codePointAt(0);
    exports.utf16Decode = function(input, byteOrderMark) {
      if (byteOrderMark === void 0) {
        byteOrderMark = true;
      }
      if (input.length <= 1)
        return String.fromCodePoint(REPLACEMENT);
      var byteOrder = byteOrderMark ? readBOM(input) : ByteOrder.BigEndian;
      var idx = byteOrderMark ? 2 : 0;
      var codePoints = [];
      while (input.length - idx >= 2) {
        var first = decodeValues(input[idx++], input[idx++], byteOrder);
        if (isHighSurrogate(first)) {
          if (input.length - idx < 2) {
            codePoints.push(REPLACEMENT);
          } else {
            var second = decodeValues(input[idx++], input[idx++], byteOrder);
            if (isLowSurrogate(second)) {
              codePoints.push(first, second);
            } else {
              codePoints.push(REPLACEMENT);
            }
          }
        } else if (isLowSurrogate(first)) {
          idx += 2;
          codePoints.push(REPLACEMENT);
        } else {
          codePoints.push(first);
        }
      }
      if (idx < input.length)
        codePoints.push(REPLACEMENT);
      return String.fromCodePoint.apply(String, codePoints);
    };
    var isHighSurrogate = function(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    };
    var isLowSurrogate = function(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    };
    var decodeValues = function(first, second, byteOrder) {
      if (byteOrder === ByteOrder.LittleEndian)
        return second << 8 | first;
      if (byteOrder === ByteOrder.BigEndian)
        return first << 8 | second;
      throw new Error("Invalid byteOrder: " + byteOrder);
    };
    var readBOM = function(bytes) {
      return hasUtf16BigEndianBOM(bytes) ? ByteOrder.BigEndian : hasUtf16LittleEndianBOM(bytes) ? ByteOrder.LittleEndian : ByteOrder.BigEndian;
    };
    var hasUtf16BigEndianBOM = function(bytes) {
      return bytes[0] === 254 && bytes[1] === 255;
    };
    var hasUtf16LittleEndianBOM = function(bytes) {
      return bytes[0] === 255 && bytes[1] === 254;
    };
    exports.hasUtf16BOM = function(bytes) {
      return hasUtf16BigEndianBOM(bytes) || hasUtf16LittleEndianBOM(bytes);
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/numbers.js
var require_numbers = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/numbers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesFor = exports.sizeInBytes = exports.numberToString = void 0;
    exports.numberToString = function(num) {
      var numStr = String(num);
      if (Math.abs(num) < 1) {
        var e = parseInt(num.toString().split("e-")[1]);
        if (e) {
          var negative = num < 0;
          if (negative)
            num *= -1;
          num *= Math.pow(10, e - 1);
          numStr = "0." + new Array(e).join("0") + num.toString().substring(2);
          if (negative)
            numStr = "-" + numStr;
        }
      } else {
        var e = parseInt(num.toString().split("+")[1]);
        if (e > 20) {
          e -= 20;
          num /= Math.pow(10, e);
          numStr = num.toString() + new Array(e + 1).join("0");
        }
      }
      return numStr;
    };
    exports.sizeInBytes = function(n2) {
      return Math.ceil(n2.toString(2).length / 8);
    };
    exports.bytesFor = function(n2) {
      var bytes = new Uint8Array(exports.sizeInBytes(n2));
      for (var i = 1; i <= bytes.length; i++) {
        bytes[i - 1] = n2 >> (bytes.length - i) * 8;
      }
      return bytes;
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/errors.js
var require_errors = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.error = void 0;
    exports.error = function(msg) {
      throw new Error(msg);
    };
  }
});

// ../../../node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "../../../node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l2, len, pos, chunk, result;
        len = 0;
        for (i = 0, l2 = chunks.length; i < l2; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l2 = chunks.length; i < l2; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// ../../../node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../../node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s2, w) {
      s2.pending_buf[s2.pending++] = w & 255;
      s2.pending_buf[s2.pending++] = w >>> 8 & 255;
    }
    function send_bits(s2, value, length) {
      if (s2.bi_valid > Buf_size - length) {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        put_short(s2, s2.bi_buf);
        s2.bi_buf = value >> Buf_size - s2.bi_valid;
        s2.bi_valid += length - Buf_size;
      } else {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        s2.bi_valid += length;
      }
    }
    function send_code(s2, c, tree) {
      send_bits(
        s2,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s2) {
      if (s2.bi_valid === 16) {
        put_short(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    }
    function gen_bitlen(s2, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n2, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h = s2.heap_max + 1; h < HEAP_SIZE; h++) {
        n2 = s2.heap[h];
        bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n2 * 2 + 1] = bits;
        if (n2 > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n2 >= base) {
          xbits = extra[n2 - base];
        }
        f = tree[n2 * 2];
        s2.opt_len += f * (bits + xbits);
        if (has_stree) {
          s2.static_len += f * (stree[n2 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n2 = s2.bl_count[bits];
        while (n2 !== 0) {
          m = s2.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n2--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n2;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        var len = tree[n2 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n2 * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n2;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n2 = 0;
      while (n2 <= 143) {
        static_ltree[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      while (n2 <= 255) {
        static_ltree[n2 * 2 + 1] = 9;
        n2++;
        bl_count[9]++;
      }
      while (n2 <= 279) {
        static_ltree[n2 * 2 + 1] = 7;
        n2++;
        bl_count[7]++;
      }
      while (n2 <= 287) {
        static_ltree[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n2 = 0; n2 < D_CODES; n2++) {
        static_dtree[n2 * 2 + 1] = 5;
        static_dtree[n2 * 2] = bi_reverse(n2, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s2) {
      var n2;
      for (n2 = 0; n2 < L_CODES; n2++) {
        s2.dyn_ltree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < D_CODES; n2++) {
        s2.dyn_dtree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < BL_CODES; n2++) {
        s2.bl_tree[n2 * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.last_lit = s2.matches = 0;
    }
    function bi_windup(s2) {
      if (s2.bi_valid > 8) {
        put_short(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    }
    function copy_block(s2, buf, len, header) {
      bi_windup(s2);
      if (header) {
        put_short(s2, len);
        put_short(s2, ~len);
      }
      utils.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
      s2.pending += len;
    }
    function smaller(tree, n2, m, depth) {
      var _n2 = n2 * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
    }
    function pqdownheap(s2, tree, k) {
      var v = s2.heap[k];
      var j = k << 1;
      while (j <= s2.heap_len) {
        if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
          j++;
        }
        if (smaller(tree, v, s2.heap[j], s2.depth)) {
          break;
        }
        s2.heap[k] = s2.heap[j];
        k = j;
        j <<= 1;
      }
      s2.heap[k] = v;
    }
    function compress_block(s2, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s2.last_lit !== 0) {
        do {
          dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
          lc = s2.pending_buf[s2.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s2, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s2, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s2, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s2, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s2, dist, extra);
            }
          }
        } while (lx < s2.last_lit);
      }
      send_code(s2, END_BLOCK, ltree);
    }
    function build_tree(s2, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n2, m;
      var max_code = -1;
      var node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE;
      for (n2 = 0; n2 < elems; n2++) {
        if (tree[n2 * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n2;
          s2.depth[n2] = 0;
        } else {
          tree[n2 * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
        pqdownheap(s2, tree, n2);
      }
      node = elems;
      do {
        n2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n2;
        s2.heap[--s2.heap_max] = m;
        tree[node * 2] = tree[n2 * 2] + tree[m * 2];
        s2.depth[node] = (s2.depth[n2] >= s2.depth[m] ? s2.depth[n2] : s2.depth[m]) + 1;
        tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s2, desc);
      gen_codes(tree, max_code, s2.bl_count);
    }
    function scan_tree(s2, tree, max_code) {
      var n2;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s2, tree, max_code) {
      var n2;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code(s2, REP_3_6, s2.bl_tree);
          send_bits(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code(s2, REPZ_3_10, s2.bl_tree);
          send_bits(s2, count - 3, 3);
        } else {
          send_code(s2, REPZ_11_138, s2.bl_tree);
          send_bits(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s2) {
      var max_blindex;
      scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree(s2, s2.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s2, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s2, lcodes - 257, 5);
      send_bits(s2, dcodes - 1, 5);
      send_bits(s2, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s2, s2.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s2, s2.dyn_ltree, lcodes - 1);
      send_tree(s2, s2.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s2) {
      var black_mask = 4093624447;
      var n2;
      for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
        if (black_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n2 = 32; n2 < LITERALS; n2++) {
        if (s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s2) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
      s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
      s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block(s2);
    }
    function _tr_stored_block(s2, buf, stored_len, last) {
      send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s2, buf, stored_len, true);
    }
    function _tr_align(s2) {
      send_bits(s2, STATIC_TREES << 1, 3);
      send_code(s2, END_BLOCK, static_ltree);
      bi_flush(s2);
    }
    function _tr_flush_block(s2, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN) {
          s2.strm.data_type = detect_data_type(s2);
        }
        build_tree(s2, s2.l_desc);
        build_tree(s2, s2.d_desc);
        max_blindex = build_bl_tree(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s2, buf, stored_len, last);
      } else if (s2.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s2, static_ltree, static_dtree);
      } else {
        send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block(s2);
      if (last) {
        bi_windup(s2);
      }
    }
    function _tr_tally(s2, dist, lc) {
      s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
      s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
      s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
      s2.last_lit++;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s2.dyn_dtree[d_code(dist) * 2]++;
      }
      return s2.last_lit === s2.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// ../../../node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../../node_modules/pako/lib/zlib/adler32.js"(exports, module2) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
      while (len !== 0) {
        n2 = len > 2e3 ? 2e3 : len;
        len -= n2;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n2);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// ../../../node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "../../../node_modules/pako/lib/zlib/crc32.js"(exports, module2) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n2 = 0; n2 < 256; n2++) {
        c = n2;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n2] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t2 = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// ../../../node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../../node_modules/pako/lib/zlib/messages.js"(exports, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../../node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../../node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s2 = strm.state;
      var len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    }
    function flush_block_only(s2, last) {
      trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
      s2.block_start = s2.strstart;
      flush_pending(s2.strm);
    }
    function put_byte(s2, b) {
      s2.pending_buf[s2.pending++] = b;
    }
    function putShortMSB(s2, b) {
      s2.pending_buf[s2.pending++] = b >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s2, cur_match) {
      var chain_length = s2.max_chain_length;
      var scan = s2.strstart;
      var match2;
      var len;
      var best_len = s2.prev_length;
      var nice_match = s2.nice_match;
      var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s2.window;
      var wmask = s2.w_mask;
      var prev = s2.prev;
      var strend = s2.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match2 = cur_match;
        if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match2++;
        do {
        } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    }
    function fill_window(s2) {
      var _w_size = s2.w_size;
      var p, n2, m, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          n2 = s2.hash_size;
          p = n2;
          do {
            m = s2.head[--p];
            s2.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n2);
          n2 = _w_size;
          p = n2;
          do {
            m = s2.prev[--p];
            s2.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n2);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n2;
        if (s2.lookahead + s2.insert >= MIN_MATCH) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
          while (s2.insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
    }
    function deflate_stored(s2, flush2) {
      var max_block_size = 65535;
      if (max_block_size > s2.pending_buf_size - 5) {
        max_block_size = s2.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s2.lookahead <= 1) {
          fill_window(s2);
          if (s2.lookahead === 0 && flush2 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.strstart += s2.lookahead;
        s2.lookahead = 0;
        var max_start = s2.block_start + max_block_size;
        if (s2.strstart === 0 || s2.strstart >= max_start) {
          s2.lookahead = s2.strstart - max_start;
          s2.strstart = max_start;
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush2 === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.strstart > s2.block_start) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s2, flush2) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush2 === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s2, flush2) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s2.match_available) {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush2 === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s2, flush2) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH) {
          fill_window(s2);
          if (s2.lookahead <= MAX_MATCH && flush2 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush2 === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s2, flush2) {
      var bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window(s2);
          if (s2.lookahead === 0) {
            if (flush2 === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush2 === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s2) {
      s2.window_size = 2 * s2.w_size;
      zero(s2.head);
      s2.max_lazy_match = configuration_table[s2.level].max_lazy;
      s2.good_match = configuration_table[s2.level].good_length;
      s2.nice_match = configuration_table[s2.level].nice_length;
      s2.max_chain_length = configuration_table[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s2;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = Z_NO_FLUSH;
      trees._tr_init(s2);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s2 = new DeflateState();
      strm.state = s2;
      s2.strm = strm;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s2.window = new utils.Buf8(s2.w_size * 2);
      s2.head = new utils.Buf16(s2.hash_size);
      s2.prev = new utils.Buf16(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new utils.Buf8(s2.pending_buf_size);
      s2.d_buf = 1 * s2.lit_bufsize;
      s2.l_buf = (1 + 2) * s2.lit_bufsize;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush2) {
      var old_flush, s2;
      var beg, val;
      if (!strm || !strm.state || flush2 > Z_BLOCK || flush2 < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s2 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush2 !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s2.strm = strm;
      old_flush = s2.last_flush;
      s2.last_flush = flush2;
      if (s2.status === INIT_STATE) {
        if (s2.wrap === 2) {
          strm.adler = 0;
          put_byte(s2, 31);
          put_byte(s2, 139);
          put_byte(s2, 8);
          if (!s2.gzhead) {
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, OS_CODE);
            s2.status = BUSY_STATE;
          } else {
            put_byte(
              s2,
              (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
            );
            put_byte(s2, s2.gzhead.time & 255);
            put_byte(s2, s2.gzhead.time >> 8 & 255);
            put_byte(s2, s2.gzhead.time >> 16 & 255);
            put_byte(s2, s2.gzhead.time >> 24 & 255);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, s2.gzhead.os & 255);
            if (s2.gzhead.extra && s2.gzhead.extra.length) {
              put_byte(s2, s2.gzhead.extra.length & 255);
              put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
            }
            if (s2.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending, 0);
            }
            s2.gzindex = 0;
            s2.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
            level_flags = 0;
          } else if (s2.level < 6) {
            level_flags = 1;
          } else if (s2.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s2.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s2.status = BUSY_STATE;
          putShortMSB(s2, header);
          if (s2.strstart !== 0) {
            putShortMSB(s2, strm.adler >>> 16);
            putShortMSB(s2, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s2.status === EXTRA_STATE) {
        if (s2.gzhead.extra) {
          beg = s2.pending;
          while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                break;
              }
            }
            put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
            s2.gzindex++;
          }
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (s2.gzindex === s2.gzhead.extra.length) {
            s2.gzindex = 0;
            s2.status = NAME_STATE;
          }
        } else {
          s2.status = NAME_STATE;
        }
      }
      if (s2.status === NAME_STATE) {
        if (s2.gzhead.name) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.gzindex = 0;
            s2.status = COMMENT_STATE;
          }
        } else {
          s2.status = COMMENT_STATE;
        }
      }
      if (s2.status === COMMENT_STATE) {
        if (s2.gzhead.comment) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.status = HCRC_STATE;
          }
        } else {
          s2.status = HCRC_STATE;
        }
      }
      if (s2.status === HCRC_STATE) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending(strm);
          }
          if (s2.pending + 2 <= s2.pending_buf_size) {
            put_byte(s2, strm.adler & 255);
            put_byte(s2, strm.adler >> 8 & 255);
            strm.adler = 0;
            s2.status = BUSY_STATE;
          }
        } else {
          s2.status = BUSY_STATE;
        }
      }
      if (s2.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush2) <= rank(old_flush) && flush2 !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush2 !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
        var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush2) : s2.strategy === Z_RLE ? deflate_rle(s2, flush2) : configuration_table[s2.level].func(s2, flush2);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s2.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush2 === Z_PARTIAL_FLUSH) {
            trees._tr_align(s2);
          } else if (flush2 !== Z_BLOCK) {
            trees._tr_stored_block(s2, 0, 0, false);
            if (flush2 === Z_FULL_FLUSH) {
              zero(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush2 !== Z_FINISH) {
        return Z_OK;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s2.wrap === 2) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        put_byte(s2, strm.adler >> 16 & 255);
        put_byte(s2, strm.adler >> 24 & 255);
        put_byte(s2, strm.total_in & 255);
        put_byte(s2, strm.total_in >> 8 & 255);
        put_byte(s2, strm.total_in >> 16 & 255);
        put_byte(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s2;
      var str, n2;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s2 = strm.state;
      wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        tmpDict = new utils.Buf8(s2.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s2);
      while (s2.lookahead >= MIN_MATCH) {
        str = s2.strstart;
        n2 = s2.lookahead - (MIN_MATCH - 1);
        do {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n2);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH - 1;
        fill_window(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../../node_modules/pako/lib/utils/strings.js
var require_strings2 = __commonJS({
  "../../../node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// ../../../node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../../node_modules/pako/lib/zlib/zstream.js"(exports, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// ../../../node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "../../../node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings2();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// ../../../node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../../node_modules/pako/lib/zlib/inffast.js"(exports, module2) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// ../../../node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../../node_modules/pako/lib/zlib/inftrees.js"(exports, module2) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// ../../../node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../../node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy2) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy2 >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy2) {
          dist = copy2;
        }
        utils.arraySet(state.window, src, end - copy2, dist, state.wnext);
        copy2 -= dist;
        if (copy2) {
          utils.arraySet(state.window, src, end - copy2, copy2, 0);
          state.wnext = copy2;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush2) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy2;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n2;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy2 = state.length;
                if (copy2 > have) {
                  copy2 = have;
                }
                if (copy2) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy2,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy2, next);
                  }
                  have -= copy2;
                  next += copy2;
                  state.length -= copy2;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy2 = 0;
                do {
                  len = input[next + copy2++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy2 < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy2, next);
                }
                have -= copy2;
                next += copy2;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy2 = 0;
                do {
                  len = input[next + copy2++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy2 < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy2, next);
                }
                have -= copy2;
                next += copy2;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush2 === Z_BLOCK || flush2 === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush2 === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush2 === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy2 = state.length;
              if (copy2) {
                if (copy2 > have) {
                  copy2 = have;
                }
                if (copy2 > left) {
                  copy2 = left;
                }
                if (copy2 === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy2, put);
                have -= copy2;
                next += copy2;
                left -= copy2;
                put += copy2;
                state.length -= copy2;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n2 = here_bits + 2;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy2 = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n2 = here_bits + 3;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy2 = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n2 = here_bits + 7;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy2 = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy2 > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy2--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush2 === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy2 = _out - left;
              if (state.offset > copy2) {
                copy2 = state.offset - copy2;
                if (copy2 > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy2 > state.wnext) {
                  copy2 -= state.wnext;
                  from = state.wsize - copy2;
                } else {
                  from = state.wnext - copy2;
                }
                if (copy2 > state.length) {
                  copy2 = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy2 = state.length;
              }
              if (copy2 > left) {
                copy2 = left;
              }
              left -= copy2;
              state.length -= copy2;
              do {
                output[put++] = from_source[from++];
              } while (--copy2);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush2 !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush2 === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../../../node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../../../node_modules/pako/lib/zlib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// ../../../node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "../../../node_modules/pako/lib/zlib/gzheader.js"(exports, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// ../../../node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "../../../node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings2();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// ../../../node_modules/pako/index.js
var require_pako = __commonJS({
  "../../../node_modules/pako/index.js"(exports, module2) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module2.exports = pako;
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/utils.js
var require_utils = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/utils.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var pako_1 = __importDefault2(require_pako());
    var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup9 = new Uint8Array(256);
    for (i = 0; i < chars2.length; i++) {
      lookup9[chars2.charCodeAt(i)] = i;
    }
    var i;
    exports.decodeFromBase64 = function(base64) {
      var bufferLength = base64.length * 0.75;
      var len = base64.length;
      var i2;
      var p = 0;
      var encoded1;
      var encoded2;
      var encoded3;
      var encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      var bytes = new Uint8Array(bufferLength);
      for (i2 = 0; i2 < len; i2 += 4) {
        encoded1 = lookup9[base64.charCodeAt(i2)];
        encoded2 = lookup9[base64.charCodeAt(i2 + 1)];
        encoded3 = lookup9[base64.charCodeAt(i2 + 2)];
        encoded4 = lookup9[base64.charCodeAt(i2 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return bytes;
    };
    var arrayToString = function(array2) {
      var str = "";
      for (var i2 = 0; i2 < array2.length; i2++) {
        str += String.fromCharCode(array2[i2]);
      }
      return str;
    };
    exports.decompressJson = function(compressedJson) {
      return arrayToString(pako_1.default.inflate(exports.decodeFromBase64(compressedJson)));
    };
    exports.padStart = function(value, length, padChar) {
      var padding = "";
      for (var idx = 0, len = length - value.length; idx < len; idx++) {
        padding += padChar;
      }
      return padding + value;
    };
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Courier-Bold.compressed.json
var require_Courier_Bold_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Courier-Bold.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Courier-BoldOblique.compressed.json
var require_Courier_BoldOblique_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Courier-BoldOblique.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Courier-Oblique.compressed.json
var require_Courier_Oblique_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Courier-Oblique.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Courier.compressed.json
var require_Courier_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Courier.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Helvetica-Bold.compressed.json
var require_Helvetica_Bold_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Helvetica-Bold.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Helvetica-BoldOblique.compressed.json
var require_Helvetica_BoldOblique_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Helvetica-BoldOblique.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Helvetica-Oblique.compressed.json
var require_Helvetica_Oblique_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Helvetica-Oblique.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Helvetica.compressed.json
var require_Helvetica_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Helvetica.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Times-Bold.compressed.json
var require_Times_Bold_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Times-Bold.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Times-BoldItalic.compressed.json
var require_Times_BoldItalic_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Times-BoldItalic.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Times-Italic.compressed.json
var require_Times_Italic_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Times-Italic.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Times-Roman.compressed.json
var require_Times_Roman_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Times-Roman.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Symbol.compressed.json
var require_Symbol_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Symbol.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/ZapfDingbats.compressed.json
var require_ZapfDingbats_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/ZapfDingbats.compressed.json"(exports, module2) {
    module2.exports = "eJxtmNtu20YQhl+F4FULyMGeD7pz3AY1ChtG7NpFA18w1NomIlECSRcxgrx7SVk7+wOdG8H5OJydf2Z2d5gf9cV+t0v9VK/r+6vXsXlOlbHe28paq229qj/t++m62aXZ4J/m8PRb1z9/baZxefK63Z6eXN5dVMvTCh83u277xr/6kLrnl2XNq7TpXnczuZyabdee98/b2VzM/x4/dd/T5qab2pd6PQ2vaVVfvDRD005puE3Lu7eH1HbN9hTjx4/77/X6y5lcnUmjVzHIVVDicVX/1W/SsO36dLMfu6nb9/X6TAoBD+5euvZbn8axXtuZ36dhPJrVQqgPQoh5hev91LWLkIv94W1Ygq9+aX+tZAx2tfz64284/sblN/rqfLP/mqrbt3FKu7G67Nv9cNgPzZQ2H6rz7bb6vLgZq89pTMO/M/xfEqturJpqSM/d7GJIm2oamk3aNcO3av80O5xh3yyKmm1193ZIT02bqovTKjP+MAf++7zsZvZ3276kYyWWXB0z99S18/PbafPHQ71W4fjn/fxnFO+ZvkrT0LVzTr78qB/+nk38bHM9exgP8zr1z9U7jt6840YW5uSJKcZOCaBBnKgm5mU8MVNYyMwWFvO7Ukagkmgg6sDWQ5yFFqjzUrLEaQ3BEmiwNsMSaZS0vgWfOkPHWQowNeTUc0kumnxZvsgPxlGai6VTGUqAVCTQ6QkWnc77DKEiLktSUBJKqHIQZ86d8gCpHYoiEzMsb1ubYy8vW50DChB5ZhGqrijD0EqUIeiaEHIfCg5Kpuu0ApiToaGPSY0uaQsyr65L2oKi1yFt1PLaQ3lzfXTgXodGoJYzglndSLDMPg1sTPJpQJHJigw0QrGERqD9YhyTOgONQDUyuF1zaxuokc/BW2ztXCMrGZ9WMW1oQZHIXWNBkSCfRZEL5BMUiZw6CzVSFCfUSGZFNjIldoKDkonTKQiJIGzWmFd3BizJJ9SINoLDriOfUCOZS+zg+KGD1qGiLNMLxtJD1/ns00ON6EzyUCM6vbxhoBKaqbG3DFQCNiL1iHccBPV0DHhQH/JW8EW90dkyFKGywCJU0WkVSvSGeiSUODWFFD0HYdPQVoiRgfPMA+/nnRgiAyNYSjpWNQcNSMrtFCUH4ZIRpSCWocFCSuhCEY6hoUClc0WC52BJlCYYLQdhN+hygRRRlo5BKRRLS6oihSqh+ZzzRGG1Mo4Iz1LoP0qsxDGFzk0JE42ji0jCPejomJKCuwil4m5CiRMEUMVSzVLDUstSx1Juc0oVWMpqY295qVltmtWmWW2a1aZZbZrVplltmtWmWW2G1WZYbYbVZlhthtVmWG2G1WZYbYbVZlhtltVmWW2W1WZZbZbVZlltltVmWW2W1QYjQCh7E2aAQHeGhCFgPoNoy8KNb2wxBhmGKBxoUZXlLGsLI6AsftEDHV0wIURVbANLcTKlGGBIKPOAxCmhePCKUwFzAmpDFRQvjA9R06Hq8TONvshgKDCuRAZTXigUxjxNFfKRo3CLhnIJBMFRvMZpqpNBMlQJzGT5WFQMVQI/AikPMIhEU1aDjqJvQwmjSHB05cC9jbYwc5UtAHNLhDw41ha+lEqF4JaH3gmB61SYcqInxTDmQK8v08vjqv4zDf1N0w3Lf4A8/vwPpfK11w==";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Font.js
var require_Font = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Font.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var Courier_Bold_compressed_json_1 = __importDefault2(require_Courier_Bold_compressed());
    var Courier_BoldOblique_compressed_json_1 = __importDefault2(require_Courier_BoldOblique_compressed());
    var Courier_Oblique_compressed_json_1 = __importDefault2(require_Courier_Oblique_compressed());
    var Courier_compressed_json_1 = __importDefault2(require_Courier_compressed());
    var Helvetica_Bold_compressed_json_1 = __importDefault2(require_Helvetica_Bold_compressed());
    var Helvetica_BoldOblique_compressed_json_1 = __importDefault2(require_Helvetica_BoldOblique_compressed());
    var Helvetica_Oblique_compressed_json_1 = __importDefault2(require_Helvetica_Oblique_compressed());
    var Helvetica_compressed_json_1 = __importDefault2(require_Helvetica_compressed());
    var Times_Bold_compressed_json_1 = __importDefault2(require_Times_Bold_compressed());
    var Times_BoldItalic_compressed_json_1 = __importDefault2(require_Times_BoldItalic_compressed());
    var Times_Italic_compressed_json_1 = __importDefault2(require_Times_Italic_compressed());
    var Times_Roman_compressed_json_1 = __importDefault2(require_Times_Roman_compressed());
    var Symbol_compressed_json_1 = __importDefault2(require_Symbol_compressed());
    var ZapfDingbats_compressed_json_1 = __importDefault2(require_ZapfDingbats_compressed());
    var compressedJsonForFontName = {
      "Courier": Courier_compressed_json_1.default,
      "Courier-Bold": Courier_Bold_compressed_json_1.default,
      "Courier-Oblique": Courier_Oblique_compressed_json_1.default,
      "Courier-BoldOblique": Courier_BoldOblique_compressed_json_1.default,
      "Helvetica": Helvetica_compressed_json_1.default,
      "Helvetica-Bold": Helvetica_Bold_compressed_json_1.default,
      "Helvetica-Oblique": Helvetica_Oblique_compressed_json_1.default,
      "Helvetica-BoldOblique": Helvetica_BoldOblique_compressed_json_1.default,
      "Times-Roman": Times_Roman_compressed_json_1.default,
      "Times-Bold": Times_Bold_compressed_json_1.default,
      "Times-Italic": Times_Italic_compressed_json_1.default,
      "Times-BoldItalic": Times_BoldItalic_compressed_json_1.default,
      "Symbol": Symbol_compressed_json_1.default,
      "ZapfDingbats": ZapfDingbats_compressed_json_1.default
    };
    var FontNames;
    (function(FontNames2) {
      FontNames2["Courier"] = "Courier";
      FontNames2["CourierBold"] = "Courier-Bold";
      FontNames2["CourierOblique"] = "Courier-Oblique";
      FontNames2["CourierBoldOblique"] = "Courier-BoldOblique";
      FontNames2["Helvetica"] = "Helvetica";
      FontNames2["HelveticaBold"] = "Helvetica-Bold";
      FontNames2["HelveticaOblique"] = "Helvetica-Oblique";
      FontNames2["HelveticaBoldOblique"] = "Helvetica-BoldOblique";
      FontNames2["TimesRoman"] = "Times-Roman";
      FontNames2["TimesRomanBold"] = "Times-Bold";
      FontNames2["TimesRomanItalic"] = "Times-Italic";
      FontNames2["TimesRomanBoldItalic"] = "Times-BoldItalic";
      FontNames2["Symbol"] = "Symbol";
      FontNames2["ZapfDingbats"] = "ZapfDingbats";
    })(FontNames = exports.FontNames || (exports.FontNames = {}));
    var fontCache = {};
    var Font = (
      /** @class */
      function() {
        function Font2() {
          var _this = this;
          this.getWidthOfGlyph = function(glyphName) {
            return _this.CharWidths[glyphName];
          };
          this.getXAxisKerningForPair = function(leftGlyphName, rightGlyphName) {
            return (_this.KernPairXAmounts[leftGlyphName] || {})[rightGlyphName];
          };
        }
        Font2.load = function(fontName) {
          var cachedFont = fontCache[fontName];
          if (cachedFont)
            return cachedFont;
          var json = utils_1.decompressJson(compressedJsonForFontName[fontName]);
          var font = Object.assign(new Font2(), JSON.parse(json));
          font.CharWidths = font.CharMetrics.reduce(function(acc, metric) {
            acc[metric.N] = metric.WX;
            return acc;
          }, {});
          font.KernPairXAmounts = font.KernPairs.reduce(function(acc, _a) {
            var name1 = _a[0], name2 = _a[1], width = _a[2];
            if (!acc[name1])
              acc[name1] = {};
            acc[name1][name2] = width;
            return acc;
          }, {});
          fontCache[fontName] = font;
          return font;
        };
        return Font2;
      }()
    );
    exports.Font = Font;
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/all-encodings.compressed.json
var require_all_encodings_compressed = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/all-encodings.compressed.json"(exports, module2) {
    module2.exports = "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";
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/Encoding.js
var require_Encoding = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/Encoding.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var all_encodings_compressed_json_1 = __importDefault2(require_all_encodings_compressed());
    var decompressedEncodings = utils_1.decompressJson(all_encodings_compressed_json_1.default);
    var allUnicodeMappings = JSON.parse(decompressedEncodings);
    var Encoding = (
      /** @class */
      function() {
        function Encoding2(name, unicodeMappings) {
          var _this = this;
          this.canEncodeUnicodeCodePoint = function(codePoint) {
            return codePoint in _this.unicodeMappings;
          };
          this.encodeUnicodeCodePoint = function(codePoint) {
            var mapped = _this.unicodeMappings[codePoint];
            if (!mapped) {
              var str = String.fromCharCode(codePoint);
              var hexCode = "0x" + utils_1.padStart(codePoint.toString(16), 4, "0");
              var msg = _this.name + ' cannot encode "' + str + '" (' + hexCode + ")";
              throw new Error(msg);
            }
            return { code: mapped[0], name: mapped[1] };
          };
          this.name = name;
          this.supportedCodePoints = Object.keys(unicodeMappings).map(Number).sort(function(a, b) {
            return a - b;
          });
          this.unicodeMappings = unicodeMappings;
        }
        return Encoding2;
      }()
    );
    exports.Encodings = {
      Symbol: new Encoding("Symbol", allUnicodeMappings.symbol),
      ZapfDingbats: new Encoding("ZapfDingbats", allUnicodeMappings.zapfdingbats),
      WinAnsi: new Encoding("WinAnsi", allUnicodeMappings.win1252)
    };
  }
});

// ../../../node_modules/@pdf-lib/standard-fonts/lib/index.js
var require_lib = __commonJS({
  "../../../node_modules/@pdf-lib/standard-fonts/lib/index.js"(exports) {
    "use strict";
    function __export2(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_Font());
    __export2(require_Encoding());
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/objects.js
var require_objects = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/objects.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rectanglesAreEqual = exports.isStandardFont = exports.StandardFontValues = exports.values = void 0;
    var standard_fonts_1 = require_lib();
    exports.values = function(obj) {
      return Object.keys(obj).map(function(k) {
        return obj[k];
      });
    };
    exports.StandardFontValues = exports.values(standard_fonts_1.FontNames);
    exports.isStandardFont = function(input) {
      return exports.StandardFontValues.includes(input);
    };
    exports.rectanglesAreEqual = function(a, b) {
      return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/validators.js
var require_validators = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/validators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertPositive = exports.assertInteger = exports.assertMultiple = exports.assertRangeOrUndefined = exports.assertRange = exports.assertEachIs = exports.assertOrUndefined = exports.assertIs = exports.createTypeErrorMsg = exports.isType = exports.getType = exports.assertIsSubset = exports.assertIsOneOfOrUndefined = exports.assertIsOneOf = exports.createValueErrorMsg = exports.singleQuote = exports.backtick = void 0;
    var objects_1 = require_objects();
    exports.backtick = function(val) {
      return "`" + val + "`";
    };
    exports.singleQuote = function(val) {
      return "'" + val + "'";
    };
    var formatValue = function(value) {
      var type = typeof value;
      if (type === "string")
        return exports.singleQuote(value);
      else if (type === "undefined")
        return exports.backtick(value);
      else
        return value;
    };
    exports.createValueErrorMsg = function(value, valueName, values) {
      var allowedValues = new Array(values.length);
      for (var idx = 0, len = values.length; idx < len; idx++) {
        var v = values[idx];
        allowedValues[idx] = formatValue(v);
      }
      var joinedValues = allowedValues.join(" or ");
      return exports.backtick(valueName) + " must be one of " + joinedValues + ", but was actually " + formatValue(value);
    };
    exports.assertIsOneOf = function(value, valueName, allowedValues) {
      if (!Array.isArray(allowedValues)) {
        allowedValues = objects_1.values(allowedValues);
      }
      for (var idx = 0, len = allowedValues.length; idx < len; idx++) {
        if (value === allowedValues[idx])
          return;
      }
      throw new TypeError(exports.createValueErrorMsg(value, valueName, allowedValues));
    };
    exports.assertIsOneOfOrUndefined = function(value, valueName, allowedValues) {
      if (!Array.isArray(allowedValues)) {
        allowedValues = objects_1.values(allowedValues);
      }
      exports.assertIsOneOf(value, valueName, allowedValues.concat(void 0));
    };
    exports.assertIsSubset = function(values, valueName, allowedValues) {
      if (!Array.isArray(allowedValues)) {
        allowedValues = objects_1.values(allowedValues);
      }
      for (var idx = 0, len = values.length; idx < len; idx++) {
        exports.assertIsOneOf(values[idx], valueName, allowedValues);
      }
    };
    exports.getType = function(val) {
      if (val === null)
        return "null";
      if (val === void 0)
        return "undefined";
      if (typeof val === "string")
        return "string";
      if (isNaN(val))
        return "NaN";
      if (typeof val === "number")
        return "number";
      if (typeof val === "boolean")
        return "boolean";
      if (typeof val === "symbol")
        return "symbol";
      if (typeof val === "bigint")
        return "bigint";
      if (val.constructor && val.constructor.name)
        return val.constructor.name;
      if (val.name)
        return val.name;
      if (val.constructor)
        return String(val.constructor);
      return String(val);
    };
    exports.isType = function(value, type) {
      if (type === "null")
        return value === null;
      if (type === "undefined")
        return value === void 0;
      if (type === "string")
        return typeof value === "string";
      if (type === "number")
        return typeof value === "number" && !isNaN(value);
      if (type === "boolean")
        return typeof value === "boolean";
      if (type === "symbol")
        return typeof value === "symbol";
      if (type === "bigint")
        return typeof value === "bigint";
      if (type === Date)
        return value instanceof Date;
      if (type === Array)
        return value instanceof Array;
      if (type === Uint8Array)
        return value instanceof Uint8Array;
      if (type === ArrayBuffer)
        return value instanceof ArrayBuffer;
      if (type === Function)
        return value instanceof Function;
      return value instanceof type[0];
    };
    exports.createTypeErrorMsg = function(value, valueName, types2) {
      var allowedTypes = new Array(types2.length);
      for (var idx = 0, len = types2.length; idx < len; idx++) {
        var type = types2[idx];
        if (type === "null")
          allowedTypes[idx] = exports.backtick("null");
        if (type === "undefined")
          allowedTypes[idx] = exports.backtick("undefined");
        if (type === "string")
          allowedTypes[idx] = exports.backtick("string");
        else if (type === "number")
          allowedTypes[idx] = exports.backtick("number");
        else if (type === "boolean")
          allowedTypes[idx] = exports.backtick("boolean");
        else if (type === "symbol")
          allowedTypes[idx] = exports.backtick("symbol");
        else if (type === "bigint")
          allowedTypes[idx] = exports.backtick("bigint");
        else if (type === Array)
          allowedTypes[idx] = exports.backtick("Array");
        else if (type === Uint8Array)
          allowedTypes[idx] = exports.backtick("Uint8Array");
        else if (type === ArrayBuffer)
          allowedTypes[idx] = exports.backtick("ArrayBuffer");
        else
          allowedTypes[idx] = exports.backtick(type[1]);
      }
      var joinedTypes = allowedTypes.join(" or ");
      return exports.backtick(valueName) + " must be of type " + joinedTypes + ", but was actually of type " + exports.backtick(exports.getType(value));
    };
    exports.assertIs = function(value, valueName, types2) {
      for (var idx = 0, len = types2.length; idx < len; idx++) {
        if (exports.isType(value, types2[idx]))
          return;
      }
      throw new TypeError(exports.createTypeErrorMsg(value, valueName, types2));
    };
    exports.assertOrUndefined = function(value, valueName, types2) {
      exports.assertIs(value, valueName, types2.concat("undefined"));
    };
    exports.assertEachIs = function(values, valueName, types2) {
      for (var idx = 0, len = values.length; idx < len; idx++) {
        exports.assertIs(values[idx], valueName, types2);
      }
    };
    exports.assertRange = function(value, valueName, min, max) {
      exports.assertIs(value, valueName, ["number"]);
      exports.assertIs(min, "min", ["number"]);
      exports.assertIs(max, "max", ["number"]);
      max = Math.max(min, max);
      if (value < min || value > max) {
        throw new Error(exports.backtick(valueName) + " must be at least " + min + " and at most " + max + ", but was actually " + value);
      }
    };
    exports.assertRangeOrUndefined = function(value, valueName, min, max) {
      exports.assertIs(value, valueName, ["number", "undefined"]);
      if (typeof value === "number")
        exports.assertRange(value, valueName, min, max);
    };
    exports.assertMultiple = function(value, valueName, multiplier) {
      exports.assertIs(value, valueName, ["number"]);
      if (value % multiplier !== 0) {
        throw new Error(exports.backtick(valueName) + " must be a multiple of " + multiplier + ", but was actually " + value);
      }
    };
    exports.assertInteger = function(value, valueName) {
      if (!Number.isInteger(value)) {
        throw new Error(exports.backtick(valueName) + " must be an integer, but was actually " + value);
      }
    };
    exports.assertPositive = function(value, valueName) {
      if (![1, 0].includes(Math.sign(value))) {
        throw new Error(exports.backtick(valueName) + " must be a positive number or 0, but was actually " + value);
      }
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/pdfDocEncoding.js
var require_pdfDocEncoding = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/pdfDocEncoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pdfDocEncodingDecode = void 0;
    var strings_1 = require_strings();
    var pdfDocEncodingToUnicode = new Uint16Array(256);
    for (idx = 0; idx < 256; idx++) {
      pdfDocEncodingToUnicode[idx] = idx;
    }
    var idx;
    pdfDocEncodingToUnicode[22] = strings_1.toCharCode("");
    pdfDocEncodingToUnicode[24] = strings_1.toCharCode("\u02D8");
    pdfDocEncodingToUnicode[25] = strings_1.toCharCode("\u02C7");
    pdfDocEncodingToUnicode[26] = strings_1.toCharCode("\u02C6");
    pdfDocEncodingToUnicode[27] = strings_1.toCharCode("\u02D9");
    pdfDocEncodingToUnicode[28] = strings_1.toCharCode("\u02DD");
    pdfDocEncodingToUnicode[29] = strings_1.toCharCode("\u02DB");
    pdfDocEncodingToUnicode[30] = strings_1.toCharCode("\u02DA");
    pdfDocEncodingToUnicode[31] = strings_1.toCharCode("\u02DC");
    pdfDocEncodingToUnicode[127] = strings_1.toCharCode("\uFFFD");
    pdfDocEncodingToUnicode[128] = strings_1.toCharCode("\u2022");
    pdfDocEncodingToUnicode[129] = strings_1.toCharCode("\u2020");
    pdfDocEncodingToUnicode[130] = strings_1.toCharCode("\u2021");
    pdfDocEncodingToUnicode[131] = strings_1.toCharCode("\u2026");
    pdfDocEncodingToUnicode[132] = strings_1.toCharCode("\u2014");
    pdfDocEncodingToUnicode[133] = strings_1.toCharCode("\u2013");
    pdfDocEncodingToUnicode[134] = strings_1.toCharCode("\u0192");
    pdfDocEncodingToUnicode[135] = strings_1.toCharCode("\u2044");
    pdfDocEncodingToUnicode[136] = strings_1.toCharCode("\u2039");
    pdfDocEncodingToUnicode[137] = strings_1.toCharCode("\u203A");
    pdfDocEncodingToUnicode[138] = strings_1.toCharCode("\u2212");
    pdfDocEncodingToUnicode[139] = strings_1.toCharCode("\u2030");
    pdfDocEncodingToUnicode[140] = strings_1.toCharCode("\u201E");
    pdfDocEncodingToUnicode[141] = strings_1.toCharCode("\u201C");
    pdfDocEncodingToUnicode[142] = strings_1.toCharCode("\u201D");
    pdfDocEncodingToUnicode[143] = strings_1.toCharCode("\u2018");
    pdfDocEncodingToUnicode[144] = strings_1.toCharCode("\u2019");
    pdfDocEncodingToUnicode[145] = strings_1.toCharCode("\u201A");
    pdfDocEncodingToUnicode[146] = strings_1.toCharCode("\u2122");
    pdfDocEncodingToUnicode[147] = strings_1.toCharCode("\uFB01");
    pdfDocEncodingToUnicode[148] = strings_1.toCharCode("\uFB02");
    pdfDocEncodingToUnicode[149] = strings_1.toCharCode("\u0141");
    pdfDocEncodingToUnicode[150] = strings_1.toCharCode("\u0152");
    pdfDocEncodingToUnicode[151] = strings_1.toCharCode("\u0160");
    pdfDocEncodingToUnicode[152] = strings_1.toCharCode("\u0178");
    pdfDocEncodingToUnicode[153] = strings_1.toCharCode("\u017D");
    pdfDocEncodingToUnicode[154] = strings_1.toCharCode("\u0131");
    pdfDocEncodingToUnicode[155] = strings_1.toCharCode("\u0142");
    pdfDocEncodingToUnicode[156] = strings_1.toCharCode("\u0153");
    pdfDocEncodingToUnicode[157] = strings_1.toCharCode("\u0161");
    pdfDocEncodingToUnicode[158] = strings_1.toCharCode("\u017E");
    pdfDocEncodingToUnicode[159] = strings_1.toCharCode("\uFFFD");
    pdfDocEncodingToUnicode[160] = strings_1.toCharCode("\u20AC");
    pdfDocEncodingToUnicode[173] = strings_1.toCharCode("\uFFFD");
    exports.pdfDocEncodingDecode = function(bytes) {
      var codePoints = new Array(bytes.length);
      for (var idx2 = 0, len = bytes.length; idx2 < len; idx2++) {
        codePoints[idx2] = pdfDocEncodingToUnicode[bytes[idx2]];
      }
      return String.fromCodePoint.apply(String, codePoints);
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/Cache.js
var require_Cache = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/Cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Cache = (
      /** @class */
      function() {
        function Cache2(populate) {
          this.populate = populate;
          this.value = void 0;
        }
        Cache2.prototype.getValue = function() {
          return this.value;
        };
        Cache2.prototype.access = function() {
          if (!this.value)
            this.value = this.populate();
          return this.value;
        };
        Cache2.prototype.invalidate = function() {
          this.value = void 0;
        };
        Cache2.populatedBy = function(populate) {
          return new Cache2(populate);
        };
        return Cache2;
      }()
    );
    exports.default = Cache;
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/index.js
var require_utils2 = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_arrays(), exports);
    tslib_1.__exportStar(require_async(), exports);
    tslib_1.__exportStar(require_strings(), exports);
    tslib_1.__exportStar(require_unicode(), exports);
    tslib_1.__exportStar(require_numbers(), exports);
    tslib_1.__exportStar(require_errors(), exports);
    tslib_1.__exportStar(require_base64(), exports);
    tslib_1.__exportStar(require_objects(), exports);
    tslib_1.__exportStar(require_validators(), exports);
    tslib_1.__exportStar(require_pdfDocEncoding(), exports);
    var Cache_1 = require_Cache();
    Object.defineProperty(exports, "Cache", { enumerable: true, get: function() {
      return Cache_1.default;
    } });
  }
});

// ../../../node_modules/pdf-lib/cjs/core/errors.js
var require_errors2 = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingKeywordError = exports.MissingPDFHeaderError = exports.StalledParserError = exports.UnbalancedParenthesisError = exports.PDFStreamParsingError = exports.PDFInvalidObjectParsingError = exports.PDFObjectParsingError = exports.NextByteAssertionError = exports.PDFParsingError = exports.NumberParsingError = exports.MissingTfOperatorError = exports.MissingDAEntryError = exports.MultiSelectValueError = exports.InvalidAcroFieldValueError = exports.IndexOutOfBoundsError = exports.CorruptPageTreeError = exports.InvalidTargetIndexError = exports.InvalidPDFDateStringError = exports.PDFArrayIsNotRectangleError = exports.PageEmbeddingMismatchedContextError = exports.UnrecognizedStreamTypeError = exports.MissingPageContentsEmbeddingError = exports.MissingCatalogError = exports.ReparseError = exports.UnsupportedEncodingError = exports.UnexpectedObjectTypeError = exports.PrivateConstructorError = exports.MethodNotImplementedError = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var utils_1 = require_utils2();
    var MethodNotImplementedError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MethodNotImplementedError2, _super);
        function MethodNotImplementedError2(className, methodName) {
          var _this = this;
          var msg = "Method " + className + "." + methodName + "() not implemented";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MethodNotImplementedError2;
      }(Error)
    );
    exports.MethodNotImplementedError = MethodNotImplementedError;
    var PrivateConstructorError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PrivateConstructorError2, _super);
        function PrivateConstructorError2(className) {
          var _this = this;
          var msg = "Cannot construct " + className + " - it has a private constructor";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return PrivateConstructorError2;
      }(Error)
    );
    exports.PrivateConstructorError = PrivateConstructorError;
    var UnexpectedObjectTypeError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(UnexpectedObjectTypeError2, _super);
        function UnexpectedObjectTypeError2(expected, actual) {
          var _this = this;
          var name = function(t2) {
            var _a, _b;
            return (_a = t2 === null || t2 === void 0 ? void 0 : t2.name) !== null && _a !== void 0 ? _a : (_b = t2 === null || t2 === void 0 ? void 0 : t2.constructor) === null || _b === void 0 ? void 0 : _b.name;
          };
          var expectedTypes = Array.isArray(expected) ? expected.map(name) : [name(expected)];
          var msg = "Expected instance of " + expectedTypes.join(" or ") + ", " + ("but got instance of " + (actual ? name(actual) : actual));
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return UnexpectedObjectTypeError2;
      }(Error)
    );
    exports.UnexpectedObjectTypeError = UnexpectedObjectTypeError;
    var UnsupportedEncodingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(UnsupportedEncodingError2, _super);
        function UnsupportedEncodingError2(encoding) {
          var _this = this;
          var msg = encoding + " stream encoding not supported";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return UnsupportedEncodingError2;
      }(Error)
    );
    exports.UnsupportedEncodingError = UnsupportedEncodingError;
    var ReparseError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(ReparseError2, _super);
        function ReparseError2(className, methodName) {
          var _this = this;
          var msg = "Cannot call " + className + "." + methodName + "() more than once";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return ReparseError2;
      }(Error)
    );
    exports.ReparseError = ReparseError;
    var MissingCatalogError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingCatalogError2, _super);
        function MissingCatalogError2(ref) {
          var _this = this;
          var msg = "Missing catalog (ref=" + ref + ")";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MissingCatalogError2;
      }(Error)
    );
    exports.MissingCatalogError = MissingCatalogError;
    var MissingPageContentsEmbeddingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingPageContentsEmbeddingError2, _super);
        function MissingPageContentsEmbeddingError2() {
          var _this = this;
          var msg = "Can't embed page with missing Contents";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MissingPageContentsEmbeddingError2;
      }(Error)
    );
    exports.MissingPageContentsEmbeddingError = MissingPageContentsEmbeddingError;
    var UnrecognizedStreamTypeError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(UnrecognizedStreamTypeError2, _super);
        function UnrecognizedStreamTypeError2(stream) {
          var _a, _b, _c;
          var _this = this;
          var streamType = (_c = (_b = (_a = stream === null || stream === void 0 ? void 0 : stream.contructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : stream === null || stream === void 0 ? void 0 : stream.name) !== null && _c !== void 0 ? _c : stream;
          var msg = "Unrecognized stream type: " + streamType;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return UnrecognizedStreamTypeError2;
      }(Error)
    );
    exports.UnrecognizedStreamTypeError = UnrecognizedStreamTypeError;
    var PageEmbeddingMismatchedContextError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PageEmbeddingMismatchedContextError2, _super);
        function PageEmbeddingMismatchedContextError2() {
          var _this = this;
          var msg = "Found mismatched contexts while embedding pages. All pages in the array passed to `PDFDocument.embedPages()` must be from the same document.";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return PageEmbeddingMismatchedContextError2;
      }(Error)
    );
    exports.PageEmbeddingMismatchedContextError = PageEmbeddingMismatchedContextError;
    var PDFArrayIsNotRectangleError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFArrayIsNotRectangleError2, _super);
        function PDFArrayIsNotRectangleError2(size) {
          var _this = this;
          var msg = "Attempted to convert PDFArray with " + size + " elements to rectangle, but must have exactly 4 elements.";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return PDFArrayIsNotRectangleError2;
      }(Error)
    );
    exports.PDFArrayIsNotRectangleError = PDFArrayIsNotRectangleError;
    var InvalidPDFDateStringError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(InvalidPDFDateStringError2, _super);
        function InvalidPDFDateStringError2(value) {
          var _this = this;
          var msg = 'Attempted to convert "' + value + '" to a date, but it does not match the PDF date string format.';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return InvalidPDFDateStringError2;
      }(Error)
    );
    exports.InvalidPDFDateStringError = InvalidPDFDateStringError;
    var InvalidTargetIndexError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(InvalidTargetIndexError2, _super);
        function InvalidTargetIndexError2(targetIndex, Count) {
          var _this = this;
          var msg = "Invalid targetIndex specified: targetIndex=" + targetIndex + " must be less than Count=" + Count;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return InvalidTargetIndexError2;
      }(Error)
    );
    exports.InvalidTargetIndexError = InvalidTargetIndexError;
    var CorruptPageTreeError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(CorruptPageTreeError2, _super);
        function CorruptPageTreeError2(targetIndex, operation) {
          var _this = this;
          var msg = "Failed to " + operation + " at targetIndex=" + targetIndex + " due to corrupt page tree: It is likely that one or more 'Count' entries are invalid";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return CorruptPageTreeError2;
      }(Error)
    );
    exports.CorruptPageTreeError = CorruptPageTreeError;
    var IndexOutOfBoundsError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(IndexOutOfBoundsError2, _super);
        function IndexOutOfBoundsError2(index2, min, max) {
          var _this = this;
          var msg = "index should be at least " + min + " and at most " + max + ", but was actually " + index2;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return IndexOutOfBoundsError2;
      }(Error)
    );
    exports.IndexOutOfBoundsError = IndexOutOfBoundsError;
    var InvalidAcroFieldValueError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(InvalidAcroFieldValueError2, _super);
        function InvalidAcroFieldValueError2() {
          var _this = this;
          var msg = "Attempted to set invalid field value";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return InvalidAcroFieldValueError2;
      }(Error)
    );
    exports.InvalidAcroFieldValueError = InvalidAcroFieldValueError;
    var MultiSelectValueError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MultiSelectValueError2, _super);
        function MultiSelectValueError2() {
          var _this = this;
          var msg = "Attempted to select multiple values for single-select field";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MultiSelectValueError2;
      }(Error)
    );
    exports.MultiSelectValueError = MultiSelectValueError;
    var MissingDAEntryError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingDAEntryError2, _super);
        function MissingDAEntryError2(fieldName) {
          var _this = this;
          var msg = "No /DA (default appearance) entry found for field: " + fieldName;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MissingDAEntryError2;
      }(Error)
    );
    exports.MissingDAEntryError = MissingDAEntryError;
    var MissingTfOperatorError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingTfOperatorError2, _super);
        function MissingTfOperatorError2(fieldName) {
          var _this = this;
          var msg = "No Tf operator found for DA of field: " + fieldName;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MissingTfOperatorError2;
      }(Error)
    );
    exports.MissingTfOperatorError = MissingTfOperatorError;
    var NumberParsingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(NumberParsingError2, _super);
        function NumberParsingError2(pos, value) {
          var _this = this;
          var msg = "Failed to parse number " + ("(line:" + pos.line + " col:" + pos.column + " offset=" + pos.offset + '): "' + value + '"');
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return NumberParsingError2;
      }(Error)
    );
    exports.NumberParsingError = NumberParsingError;
    var PDFParsingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFParsingError2, _super);
        function PDFParsingError2(pos, details) {
          var _this = this;
          var msg = "Failed to parse PDF document " + ("(line:" + pos.line + " col:" + pos.column + " offset=" + pos.offset + "): " + details);
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return PDFParsingError2;
      }(Error)
    );
    exports.PDFParsingError = PDFParsingError;
    var NextByteAssertionError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(NextByteAssertionError2, _super);
        function NextByteAssertionError2(pos, expectedByte, actualByte) {
          var _this = this;
          var msg = "Expected next byte to be " + expectedByte + " but it was actually " + actualByte;
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return NextByteAssertionError2;
      }(PDFParsingError)
    );
    exports.NextByteAssertionError = NextByteAssertionError;
    var PDFObjectParsingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFObjectParsingError2, _super);
        function PDFObjectParsingError2(pos, byte) {
          var _this = this;
          var msg = "Failed to parse PDF object starting with the following byte: " + byte;
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return PDFObjectParsingError2;
      }(PDFParsingError)
    );
    exports.PDFObjectParsingError = PDFObjectParsingError;
    var PDFInvalidObjectParsingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFInvalidObjectParsingError2, _super);
        function PDFInvalidObjectParsingError2(pos) {
          var _this = this;
          var msg = "Failed to parse invalid PDF object";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return PDFInvalidObjectParsingError2;
      }(PDFParsingError)
    );
    exports.PDFInvalidObjectParsingError = PDFInvalidObjectParsingError;
    var PDFStreamParsingError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFStreamParsingError2, _super);
        function PDFStreamParsingError2(pos) {
          var _this = this;
          var msg = "Failed to parse PDF stream";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return PDFStreamParsingError2;
      }(PDFParsingError)
    );
    exports.PDFStreamParsingError = PDFStreamParsingError;
    var UnbalancedParenthesisError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(UnbalancedParenthesisError2, _super);
        function UnbalancedParenthesisError2(pos) {
          var _this = this;
          var msg = "Failed to parse PDF literal string due to unbalanced parenthesis";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return UnbalancedParenthesisError2;
      }(PDFParsingError)
    );
    exports.UnbalancedParenthesisError = UnbalancedParenthesisError;
    var StalledParserError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(StalledParserError2, _super);
        function StalledParserError2(pos) {
          var _this = this;
          var msg = "Parser stalled";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return StalledParserError2;
      }(PDFParsingError)
    );
    exports.StalledParserError = StalledParserError;
    var MissingPDFHeaderError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingPDFHeaderError2, _super);
        function MissingPDFHeaderError2(pos) {
          var _this = this;
          var msg = "No PDF header found";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return MissingPDFHeaderError2;
      }(PDFParsingError)
    );
    exports.MissingPDFHeaderError = MissingPDFHeaderError;
    var MissingKeywordError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingKeywordError2, _super);
        function MissingKeywordError2(pos, keyword) {
          var _this = this;
          var msg = "Did not find expected keyword '" + utils_1.arrayAsString(keyword) + "'";
          _this = _super.call(this, pos, msg) || this;
          return _this;
        }
        return MissingKeywordError2;
      }(PDFParsingError)
    );
    exports.MissingKeywordError = MissingKeywordError;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/syntax/CharCodes.js
var require_CharCodes = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/syntax/CharCodes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["Null"] = 0] = "Null";
      CharCodes2[CharCodes2["Backspace"] = 8] = "Backspace";
      CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
      CharCodes2[CharCodes2["Newline"] = 10] = "Newline";
      CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
      CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
      CharCodes2[CharCodes2["Space"] = 32] = "Space";
      CharCodes2[CharCodes2["ExclamationPoint"] = 33] = "ExclamationPoint";
      CharCodes2[CharCodes2["Hash"] = 35] = "Hash";
      CharCodes2[CharCodes2["Percent"] = 37] = "Percent";
      CharCodes2[CharCodes2["LeftParen"] = 40] = "LeftParen";
      CharCodes2[CharCodes2["RightParen"] = 41] = "RightParen";
      CharCodes2[CharCodes2["Plus"] = 43] = "Plus";
      CharCodes2[CharCodes2["Minus"] = 45] = "Minus";
      CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
      CharCodes2[CharCodes2["Period"] = 46] = "Period";
      CharCodes2[CharCodes2["ForwardSlash"] = 47] = "ForwardSlash";
      CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
      CharCodes2[CharCodes2["One"] = 49] = "One";
      CharCodes2[CharCodes2["Two"] = 50] = "Two";
      CharCodes2[CharCodes2["Three"] = 51] = "Three";
      CharCodes2[CharCodes2["Four"] = 52] = "Four";
      CharCodes2[CharCodes2["Five"] = 53] = "Five";
      CharCodes2[CharCodes2["Six"] = 54] = "Six";
      CharCodes2[CharCodes2["Seven"] = 55] = "Seven";
      CharCodes2[CharCodes2["Eight"] = 56] = "Eight";
      CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
      CharCodes2[CharCodes2["LessThan"] = 60] = "LessThan";
      CharCodes2[CharCodes2["GreaterThan"] = 62] = "GreaterThan";
      CharCodes2[CharCodes2["A"] = 65] = "A";
      CharCodes2[CharCodes2["D"] = 68] = "D";
      CharCodes2[CharCodes2["E"] = 69] = "E";
      CharCodes2[CharCodes2["F"] = 70] = "F";
      CharCodes2[CharCodes2["O"] = 79] = "O";
      CharCodes2[CharCodes2["P"] = 80] = "P";
      CharCodes2[CharCodes2["R"] = 82] = "R";
      CharCodes2[CharCodes2["LeftSquareBracket"] = 91] = "LeftSquareBracket";
      CharCodes2[CharCodes2["BackSlash"] = 92] = "BackSlash";
      CharCodes2[CharCodes2["RightSquareBracket"] = 93] = "RightSquareBracket";
      CharCodes2[CharCodes2["a"] = 97] = "a";
      CharCodes2[CharCodes2["b"] = 98] = "b";
      CharCodes2[CharCodes2["d"] = 100] = "d";
      CharCodes2[CharCodes2["e"] = 101] = "e";
      CharCodes2[CharCodes2["f"] = 102] = "f";
      CharCodes2[CharCodes2["i"] = 105] = "i";
      CharCodes2[CharCodes2["j"] = 106] = "j";
      CharCodes2[CharCodes2["l"] = 108] = "l";
      CharCodes2[CharCodes2["m"] = 109] = "m";
      CharCodes2[CharCodes2["n"] = 110] = "n";
      CharCodes2[CharCodes2["o"] = 111] = "o";
      CharCodes2[CharCodes2["r"] = 114] = "r";
      CharCodes2[CharCodes2["s"] = 115] = "s";
      CharCodes2[CharCodes2["t"] = 116] = "t";
      CharCodes2[CharCodes2["u"] = 117] = "u";
      CharCodes2[CharCodes2["x"] = 120] = "x";
      CharCodes2[CharCodes2["LeftCurly"] = 123] = "LeftCurly";
      CharCodes2[CharCodes2["RightCurly"] = 125] = "RightCurly";
      CharCodes2[CharCodes2["Tilde"] = 126] = "Tilde";
    })(CharCodes || (CharCodes = {}));
    exports.default = CharCodes;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/document/PDFHeader.js
var require_PDFHeader = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/document/PDFHeader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFHeader = (
      /** @class */
      function() {
        function PDFHeader2(major, minor) {
          this.major = String(major);
          this.minor = String(minor);
        }
        PDFHeader2.prototype.toString = function() {
          var bc = utils_1.charFromCode(129);
          return "%PDF-" + this.major + "." + this.minor + "\n%" + bc + bc + bc + bc;
        };
        PDFHeader2.prototype.sizeInBytes = function() {
          return 12 + this.major.length + this.minor.length;
        };
        PDFHeader2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.Percent;
          buffer[offset2++] = CharCodes_1.default.P;
          buffer[offset2++] = CharCodes_1.default.D;
          buffer[offset2++] = CharCodes_1.default.F;
          buffer[offset2++] = CharCodes_1.default.Dash;
          offset2 += utils_1.copyStringIntoBuffer(this.major, buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.Period;
          offset2 += utils_1.copyStringIntoBuffer(this.minor, buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.Newline;
          buffer[offset2++] = CharCodes_1.default.Percent;
          buffer[offset2++] = 129;
          buffer[offset2++] = 129;
          buffer[offset2++] = 129;
          buffer[offset2++] = 129;
          return offset2 - initialOffset;
        };
        PDFHeader2.forVersion = function(major, minor) {
          return new PDFHeader2(major, minor);
        };
        return PDFHeader2;
      }()
    );
    exports.default = PDFHeader;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFObject.js
var require_PDFObject = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var errors_1 = require_errors2();
    var PDFObject = (
      /** @class */
      function() {
        function PDFObject2() {
        }
        PDFObject2.prototype.clone = function(_context) {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "clone");
        };
        PDFObject2.prototype.toString = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "toString");
        };
        PDFObject2.prototype.sizeInBytes = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "sizeInBytes");
        };
        PDFObject2.prototype.copyBytesInto = function(_buffer, _offset) {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "copyBytesInto");
        };
        return PDFObject2;
      }()
    );
    exports.default = PDFObject;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFNumber.js
var require_PDFNumber = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var index_1 = require_utils2();
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var PDFNumber = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFNumber2, _super);
        function PDFNumber2(value) {
          var _this = _super.call(this) || this;
          _this.numberValue = value;
          _this.stringValue = index_1.numberToString(value);
          return _this;
        }
        PDFNumber2.prototype.asNumber = function() {
          return this.numberValue;
        };
        PDFNumber2.prototype.value = function() {
          return this.numberValue;
        };
        PDFNumber2.prototype.clone = function() {
          return PDFNumber2.of(this.numberValue);
        };
        PDFNumber2.prototype.toString = function() {
          return this.stringValue;
        };
        PDFNumber2.prototype.sizeInBytes = function() {
          return this.stringValue.length;
        };
        PDFNumber2.prototype.copyBytesInto = function(buffer, offset2) {
          offset2 += index_1.copyStringIntoBuffer(this.stringValue, buffer, offset2);
          return this.stringValue.length;
        };
        PDFNumber2.of = function(value) {
          return new PDFNumber2(value);
        };
        return PDFNumber2;
      }(PDFObject_1.default)
    );
    exports.default = PDFNumber;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFArray.js
var require_PDFArray = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var errors_1 = require_errors2();
    var PDFArray = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFArray2, _super);
        function PDFArray2(context) {
          var _this = _super.call(this) || this;
          _this.array = [];
          _this.context = context;
          return _this;
        }
        PDFArray2.prototype.size = function() {
          return this.array.length;
        };
        PDFArray2.prototype.push = function(object2) {
          this.array.push(object2);
        };
        PDFArray2.prototype.insert = function(index2, object2) {
          this.array.splice(index2, 0, object2);
        };
        PDFArray2.prototype.indexOf = function(object2) {
          var index2 = this.array.indexOf(object2);
          return index2 === -1 ? void 0 : index2;
        };
        PDFArray2.prototype.remove = function(index2) {
          this.array.splice(index2, 1);
        };
        PDFArray2.prototype.set = function(idx, object2) {
          this.array[idx] = object2;
        };
        PDFArray2.prototype.get = function(index2) {
          return this.array[index2];
        };
        PDFArray2.prototype.lookupMaybe = function(index2) {
          var _a;
          var types2 = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types2[_i - 1] = arguments[_i];
          }
          return (_a = this.context).lookupMaybe.apply(_a, tslib_1.__spreadArrays([this.get(index2)], types2));
        };
        PDFArray2.prototype.lookup = function(index2) {
          var _a;
          var types2 = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types2[_i - 1] = arguments[_i];
          }
          return (_a = this.context).lookup.apply(_a, tslib_1.__spreadArrays([this.get(index2)], types2));
        };
        PDFArray2.prototype.asRectangle = function() {
          if (this.size() !== 4)
            throw new errors_1.PDFArrayIsNotRectangleError(this.size());
          var lowerLeftX = this.lookup(0, PDFNumber_1.default).asNumber();
          var lowerLeftY = this.lookup(1, PDFNumber_1.default).asNumber();
          var upperRightX = this.lookup(2, PDFNumber_1.default).asNumber();
          var upperRightY = this.lookup(3, PDFNumber_1.default).asNumber();
          var x = lowerLeftX;
          var y = lowerLeftY;
          var width = upperRightX - lowerLeftX;
          var height = upperRightY - lowerLeftY;
          return { x, y, width, height };
        };
        PDFArray2.prototype.asArray = function() {
          return this.array.slice();
        };
        PDFArray2.prototype.clone = function(context) {
          var clone3 = PDFArray2.withContext(context || this.context);
          for (var idx = 0, len = this.size(); idx < len; idx++) {
            clone3.push(this.array[idx]);
          }
          return clone3;
        };
        PDFArray2.prototype.toString = function() {
          var arrayString = "[ ";
          for (var idx = 0, len = this.size(); idx < len; idx++) {
            arrayString += this.get(idx).toString();
            arrayString += " ";
          }
          arrayString += "]";
          return arrayString;
        };
        PDFArray2.prototype.sizeInBytes = function() {
          var size = 3;
          for (var idx = 0, len = this.size(); idx < len; idx++) {
            size += this.get(idx).sizeInBytes() + 1;
          }
          return size;
        };
        PDFArray2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.LeftSquareBracket;
          buffer[offset2++] = CharCodes_1.default.Space;
          for (var idx = 0, len = this.size(); idx < len; idx++) {
            offset2 += this.get(idx).copyBytesInto(buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Space;
          }
          buffer[offset2++] = CharCodes_1.default.RightSquareBracket;
          return offset2 - initialOffset;
        };
        PDFArray2.prototype.scalePDFNumbers = function(x, y) {
          for (var idx = 0, len = this.size(); idx < len; idx++) {
            var el = this.lookup(idx);
            if (el instanceof PDFNumber_1.default) {
              var factor = idx % 2 === 0 ? x : y;
              this.set(idx, PDFNumber_1.default.of(el.asNumber() * factor));
            }
          }
        };
        PDFArray2.withContext = function(context) {
          return new PDFArray2(context);
        };
        return PDFArray2;
      }(PDFObject_1.default)
    );
    exports.default = PDFArray;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFBool.js
var require_PDFBool = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFBool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var ENFORCER = {};
    var PDFBool = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFBool2, _super);
        function PDFBool2(enforcer, value) {
          var _this = this;
          if (enforcer !== ENFORCER)
            throw new errors_1.PrivateConstructorError("PDFBool");
          _this = _super.call(this) || this;
          _this.value = value;
          return _this;
        }
        PDFBool2.prototype.asBoolean = function() {
          return this.value;
        };
        PDFBool2.prototype.clone = function() {
          return this;
        };
        PDFBool2.prototype.toString = function() {
          return String(this.value);
        };
        PDFBool2.prototype.sizeInBytes = function() {
          return this.value ? 4 : 5;
        };
        PDFBool2.prototype.copyBytesInto = function(buffer, offset2) {
          if (this.value) {
            buffer[offset2++] = CharCodes_1.default.t;
            buffer[offset2++] = CharCodes_1.default.r;
            buffer[offset2++] = CharCodes_1.default.u;
            buffer[offset2++] = CharCodes_1.default.e;
            return 4;
          } else {
            buffer[offset2++] = CharCodes_1.default.f;
            buffer[offset2++] = CharCodes_1.default.a;
            buffer[offset2++] = CharCodes_1.default.l;
            buffer[offset2++] = CharCodes_1.default.s;
            buffer[offset2++] = CharCodes_1.default.e;
            return 5;
          }
        };
        PDFBool2.True = new PDFBool2(ENFORCER, true);
        PDFBool2.False = new PDFBool2(ENFORCER, false);
        return PDFBool2;
      }(PDFObject_1.default)
    );
    exports.default = PDFBool;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/syntax/Delimiters.js
var require_Delimiters = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/syntax/Delimiters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsDelimiter = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    exports.IsDelimiter = new Uint8Array(256);
    exports.IsDelimiter[CharCodes_1.default.LeftParen] = 1;
    exports.IsDelimiter[CharCodes_1.default.RightParen] = 1;
    exports.IsDelimiter[CharCodes_1.default.LessThan] = 1;
    exports.IsDelimiter[CharCodes_1.default.GreaterThan] = 1;
    exports.IsDelimiter[CharCodes_1.default.LeftSquareBracket] = 1;
    exports.IsDelimiter[CharCodes_1.default.RightSquareBracket] = 1;
    exports.IsDelimiter[CharCodes_1.default.LeftCurly] = 1;
    exports.IsDelimiter[CharCodes_1.default.RightCurly] = 1;
    exports.IsDelimiter[CharCodes_1.default.ForwardSlash] = 1;
    exports.IsDelimiter[CharCodes_1.default.Percent] = 1;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/syntax/Whitespace.js
var require_Whitespace = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/syntax/Whitespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsWhitespace = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    exports.IsWhitespace = new Uint8Array(256);
    exports.IsWhitespace[CharCodes_1.default.Null] = 1;
    exports.IsWhitespace[CharCodes_1.default.Tab] = 1;
    exports.IsWhitespace[CharCodes_1.default.Newline] = 1;
    exports.IsWhitespace[CharCodes_1.default.FormFeed] = 1;
    exports.IsWhitespace[CharCodes_1.default.CarriageReturn] = 1;
    exports.IsWhitespace[CharCodes_1.default.Space] = 1;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/syntax/Irregular.js
var require_Irregular = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/syntax/Irregular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsIrregular = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Delimiters_1 = require_Delimiters();
    var Whitespace_1 = require_Whitespace();
    exports.IsIrregular = new Uint8Array(256);
    for (idx = 0, len = 256; idx < len; idx++) {
      exports.IsIrregular[idx] = Whitespace_1.IsWhitespace[idx] || Delimiters_1.IsDelimiter[idx] ? 1 : 0;
    }
    var idx;
    var len;
    exports.IsIrregular[CharCodes_1.default.Hash] = 1;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFName.js
var require_PDFName = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Irregular_1 = require_Irregular();
    var utils_1 = require_utils2();
    var decodeName = function(name) {
      return name.replace(/#([\dABCDEF]{2})/g, function(_, hex) {
        return utils_1.charFromHexCode(hex);
      });
    };
    var isRegularChar = function(charCode) {
      return charCode >= CharCodes_1.default.ExclamationPoint && charCode <= CharCodes_1.default.Tilde && !Irregular_1.IsIrregular[charCode];
    };
    var ENFORCER = {};
    var pool = /* @__PURE__ */ new Map();
    var PDFName = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFName2, _super);
        function PDFName2(enforcer, name) {
          var _this = this;
          if (enforcer !== ENFORCER)
            throw new errors_1.PrivateConstructorError("PDFName");
          _this = _super.call(this) || this;
          var encodedName = "/";
          for (var idx = 0, len = name.length; idx < len; idx++) {
            var character = name[idx];
            var code = utils_1.toCharCode(character);
            encodedName += isRegularChar(code) ? character : "#" + utils_1.toHexString(code);
          }
          _this.encodedName = encodedName;
          return _this;
        }
        PDFName2.prototype.asBytes = function() {
          var bytes = [];
          var hex = "";
          var escaped = false;
          var pushByte = function(byte2) {
            if (byte2 !== void 0)
              bytes.push(byte2);
            escaped = false;
          };
          for (var idx = 1, len = this.encodedName.length; idx < len; idx++) {
            var char = this.encodedName[idx];
            var byte = utils_1.toCharCode(char);
            var nextChar = this.encodedName[idx + 1];
            if (!escaped) {
              if (byte === CharCodes_1.default.Hash)
                escaped = true;
              else
                pushByte(byte);
            } else {
              if (byte >= CharCodes_1.default.Zero && byte <= CharCodes_1.default.Nine || byte >= CharCodes_1.default.a && byte <= CharCodes_1.default.f || byte >= CharCodes_1.default.A && byte <= CharCodes_1.default.F) {
                hex += char;
                if (hex.length === 2 || !(nextChar >= "0" && nextChar <= "9" || nextChar >= "a" && nextChar <= "f" || nextChar >= "A" && nextChar <= "F")) {
                  pushByte(parseInt(hex, 16));
                  hex = "";
                }
              } else {
                pushByte(byte);
              }
            }
          }
          return new Uint8Array(bytes);
        };
        PDFName2.prototype.decodeText = function() {
          var bytes = this.asBytes();
          return String.fromCharCode.apply(String, Array.from(bytes));
        };
        PDFName2.prototype.asString = function() {
          return this.encodedName;
        };
        PDFName2.prototype.value = function() {
          return this.encodedName;
        };
        PDFName2.prototype.clone = function() {
          return this;
        };
        PDFName2.prototype.toString = function() {
          return this.encodedName;
        };
        PDFName2.prototype.sizeInBytes = function() {
          return this.encodedName.length;
        };
        PDFName2.prototype.copyBytesInto = function(buffer, offset2) {
          offset2 += utils_1.copyStringIntoBuffer(this.encodedName, buffer, offset2);
          return this.encodedName.length;
        };
        PDFName2.of = function(name) {
          var decodedValue = decodeName(name);
          var instance2 = pool.get(decodedValue);
          if (!instance2) {
            instance2 = new PDFName2(ENFORCER, decodedValue);
            pool.set(decodedValue, instance2);
          }
          return instance2;
        };
        PDFName2.Length = PDFName2.of("Length");
        PDFName2.FlateDecode = PDFName2.of("FlateDecode");
        PDFName2.Resources = PDFName2.of("Resources");
        PDFName2.Font = PDFName2.of("Font");
        PDFName2.XObject = PDFName2.of("XObject");
        PDFName2.ExtGState = PDFName2.of("ExtGState");
        PDFName2.Contents = PDFName2.of("Contents");
        PDFName2.Type = PDFName2.of("Type");
        PDFName2.Parent = PDFName2.of("Parent");
        PDFName2.MediaBox = PDFName2.of("MediaBox");
        PDFName2.Page = PDFName2.of("Page");
        PDFName2.Annots = PDFName2.of("Annots");
        PDFName2.TrimBox = PDFName2.of("TrimBox");
        PDFName2.ArtBox = PDFName2.of("ArtBox");
        PDFName2.BleedBox = PDFName2.of("BleedBox");
        PDFName2.CropBox = PDFName2.of("CropBox");
        PDFName2.Rotate = PDFName2.of("Rotate");
        PDFName2.Title = PDFName2.of("Title");
        PDFName2.Author = PDFName2.of("Author");
        PDFName2.Subject = PDFName2.of("Subject");
        PDFName2.Creator = PDFName2.of("Creator");
        PDFName2.Keywords = PDFName2.of("Keywords");
        PDFName2.Producer = PDFName2.of("Producer");
        PDFName2.CreationDate = PDFName2.of("CreationDate");
        PDFName2.ModDate = PDFName2.of("ModDate");
        return PDFName2;
      }(PDFObject_1.default)
    );
    exports.default = PDFName;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFNull.js
var require_PDFNull = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFNull.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var PDFNull = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFNull2, _super);
        function PDFNull2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFNull2.prototype.asNull = function() {
          return null;
        };
        PDFNull2.prototype.clone = function() {
          return this;
        };
        PDFNull2.prototype.toString = function() {
          return "null";
        };
        PDFNull2.prototype.sizeInBytes = function() {
          return 4;
        };
        PDFNull2.prototype.copyBytesInto = function(buffer, offset2) {
          buffer[offset2++] = CharCodes_1.default.n;
          buffer[offset2++] = CharCodes_1.default.u;
          buffer[offset2++] = CharCodes_1.default.l;
          buffer[offset2++] = CharCodes_1.default.l;
          return 4;
        };
        return PDFNull2;
      }(PDFObject_1.default)
    );
    exports.default = new PDFNull();
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFDict.js
var require_PDFDict = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFDict.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNull_1 = tslib_1.__importDefault(require_PDFNull());
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var PDFDict = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFDict2, _super);
        function PDFDict2(map, context) {
          var _this = _super.call(this) || this;
          _this.dict = map;
          _this.context = context;
          return _this;
        }
        PDFDict2.prototype.keys = function() {
          return Array.from(this.dict.keys());
        };
        PDFDict2.prototype.values = function() {
          return Array.from(this.dict.values());
        };
        PDFDict2.prototype.entries = function() {
          return Array.from(this.dict.entries());
        };
        PDFDict2.prototype.set = function(key, value) {
          this.dict.set(key, value);
        };
        PDFDict2.prototype.get = function(key, preservePDFNull) {
          if (preservePDFNull === void 0) {
            preservePDFNull = false;
          }
          var value = this.dict.get(key);
          if (value === PDFNull_1.default && !preservePDFNull)
            return void 0;
          return value;
        };
        PDFDict2.prototype.has = function(key) {
          var value = this.dict.get(key);
          return value !== void 0 && value !== PDFNull_1.default;
        };
        PDFDict2.prototype.lookupMaybe = function(key) {
          var _a;
          var types2 = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types2[_i - 1] = arguments[_i];
          }
          var preservePDFNull = types2.includes(PDFNull_1.default);
          var value = (_a = this.context).lookupMaybe.apply(_a, tslib_1.__spreadArrays([this.get(key, preservePDFNull)], types2));
          if (value === PDFNull_1.default && !preservePDFNull)
            return void 0;
          return value;
        };
        PDFDict2.prototype.lookup = function(key) {
          var _a;
          var types2 = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types2[_i - 1] = arguments[_i];
          }
          var preservePDFNull = types2.includes(PDFNull_1.default);
          var value = (_a = this.context).lookup.apply(_a, tslib_1.__spreadArrays([this.get(key, preservePDFNull)], types2));
          if (value === PDFNull_1.default && !preservePDFNull)
            return void 0;
          return value;
        };
        PDFDict2.prototype.delete = function(key) {
          return this.dict.delete(key);
        };
        PDFDict2.prototype.asMap = function() {
          return new Map(this.dict);
        };
        PDFDict2.prototype.uniqueKey = function(tag) {
          if (tag === void 0) {
            tag = "";
          }
          var existingKeys = this.keys();
          var key = PDFName_1.default.of(this.context.addRandomSuffix(tag, 10));
          while (existingKeys.includes(key)) {
            key = PDFName_1.default.of(this.context.addRandomSuffix(tag, 10));
          }
          return key;
        };
        PDFDict2.prototype.clone = function(context) {
          var clone3 = PDFDict2.withContext(context || this.context);
          var entries = this.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            clone3.set(key, value);
          }
          return clone3;
        };
        PDFDict2.prototype.toString = function() {
          var dictString = "<<\n";
          var entries = this.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            dictString += key.toString() + " " + value.toString() + "\n";
          }
          dictString += ">>";
          return dictString;
        };
        PDFDict2.prototype.sizeInBytes = function() {
          var size = 5;
          var entries = this.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            size += key.sizeInBytes() + value.sizeInBytes() + 2;
          }
          return size;
        };
        PDFDict2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.LessThan;
          buffer[offset2++] = CharCodes_1.default.LessThan;
          buffer[offset2++] = CharCodes_1.default.Newline;
          var entries = this.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            offset2 += key.copyBytesInto(buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Space;
            offset2 += value.copyBytesInto(buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Newline;
          }
          buffer[offset2++] = CharCodes_1.default.GreaterThan;
          buffer[offset2++] = CharCodes_1.default.GreaterThan;
          return offset2 - initialOffset;
        };
        PDFDict2.withContext = function(context) {
          return new PDFDict2(/* @__PURE__ */ new Map(), context);
        };
        PDFDict2.fromMapWithContext = function(map, context) {
          return new PDFDict2(map, context);
        };
        return PDFDict2;
      }(PDFObject_1.default)
    );
    exports.default = PDFDict;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFStream.js
var require_PDFStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var PDFStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFStream2, _super);
        function PDFStream2(dict) {
          var _this = _super.call(this) || this;
          _this.dict = dict;
          return _this;
        }
        PDFStream2.prototype.clone = function(_context) {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "clone");
        };
        PDFStream2.prototype.getContentsString = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "getContentsString");
        };
        PDFStream2.prototype.getContents = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "getContents");
        };
        PDFStream2.prototype.getContentsSize = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "getContentsSize");
        };
        PDFStream2.prototype.updateDict = function() {
          var contentsSize = this.getContentsSize();
          this.dict.set(PDFName_1.default.Length, PDFNumber_1.default.of(contentsSize));
        };
        PDFStream2.prototype.sizeInBytes = function() {
          this.updateDict();
          return this.dict.sizeInBytes() + this.getContentsSize() + 18;
        };
        PDFStream2.prototype.toString = function() {
          this.updateDict();
          var streamString = this.dict.toString();
          streamString += "\nstream\n";
          streamString += this.getContentsString();
          streamString += "\nendstream";
          return streamString;
        };
        PDFStream2.prototype.copyBytesInto = function(buffer, offset2) {
          this.updateDict();
          var initialOffset = offset2;
          offset2 += this.dict.copyBytesInto(buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.Newline;
          buffer[offset2++] = CharCodes_1.default.s;
          buffer[offset2++] = CharCodes_1.default.t;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.a;
          buffer[offset2++] = CharCodes_1.default.m;
          buffer[offset2++] = CharCodes_1.default.Newline;
          var contents = this.getContents();
          for (var idx = 0, len = contents.length; idx < len; idx++) {
            buffer[offset2++] = contents[idx];
          }
          buffer[offset2++] = CharCodes_1.default.Newline;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.n;
          buffer[offset2++] = CharCodes_1.default.d;
          buffer[offset2++] = CharCodes_1.default.s;
          buffer[offset2++] = CharCodes_1.default.t;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.a;
          buffer[offset2++] = CharCodes_1.default.m;
          return offset2 - initialOffset;
        };
        return PDFStream2;
      }(PDFObject_1.default)
    );
    exports.default = PDFStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFRawStream.js
var require_PDFRawStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFRawStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var utils_1 = require_utils2();
    var PDFRawStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFRawStream2, _super);
        function PDFRawStream2(dict, contents) {
          var _this = _super.call(this, dict) || this;
          _this.contents = contents;
          return _this;
        }
        PDFRawStream2.prototype.asUint8Array = function() {
          return this.contents.slice();
        };
        PDFRawStream2.prototype.clone = function(context) {
          return PDFRawStream2.of(this.dict.clone(context), this.contents.slice());
        };
        PDFRawStream2.prototype.getContentsString = function() {
          return utils_1.arrayAsString(this.contents);
        };
        PDFRawStream2.prototype.getContents = function() {
          return this.contents;
        };
        PDFRawStream2.prototype.getContentsSize = function() {
          return this.contents.length;
        };
        PDFRawStream2.of = function(dict, contents) {
          return new PDFRawStream2(dict, contents);
        };
        return PDFRawStream2;
      }(PDFStream_1.default)
    );
    exports.default = PDFRawStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFRef.js
var require_PDFRef = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFRef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var utils_1 = require_utils2();
    var ENFORCER = {};
    var pool = /* @__PURE__ */ new Map();
    var PDFRef = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFRef2, _super);
        function PDFRef2(enforcer, objectNumber, generationNumber) {
          var _this = this;
          if (enforcer !== ENFORCER)
            throw new errors_1.PrivateConstructorError("PDFRef");
          _this = _super.call(this) || this;
          _this.objectNumber = objectNumber;
          _this.generationNumber = generationNumber;
          _this.tag = objectNumber + " " + generationNumber + " R";
          return _this;
        }
        PDFRef2.prototype.clone = function() {
          return this;
        };
        PDFRef2.prototype.toString = function() {
          return this.tag;
        };
        PDFRef2.prototype.sizeInBytes = function() {
          return this.tag.length;
        };
        PDFRef2.prototype.copyBytesInto = function(buffer, offset2) {
          offset2 += utils_1.copyStringIntoBuffer(this.tag, buffer, offset2);
          return this.tag.length;
        };
        PDFRef2.of = function(objectNumber, generationNumber) {
          if (generationNumber === void 0) {
            generationNumber = 0;
          }
          var tag = objectNumber + " " + generationNumber + " R";
          var instance2 = pool.get(tag);
          if (!instance2) {
            instance2 = new PDFRef2(ENFORCER, objectNumber, generationNumber);
            pool.set(tag, instance2);
          }
          return instance2;
        };
        return PDFRef2;
      }(PDFObject_1.default)
    );
    exports.default = PDFRef;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/operators/PDFOperator.js
var require_PDFOperator = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/operators/PDFOperator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFOperator = (
      /** @class */
      function() {
        function PDFOperator2(name, args) {
          this.name = name;
          this.args = args || [];
        }
        PDFOperator2.prototype.clone = function(context) {
          var args = new Array(this.args.length);
          for (var idx = 0, len = args.length; idx < len; idx++) {
            var arg = this.args[idx];
            args[idx] = arg instanceof PDFObject_1.default ? arg.clone(context) : arg;
          }
          return PDFOperator2.of(this.name, args);
        };
        PDFOperator2.prototype.toString = function() {
          var value = "";
          for (var idx = 0, len = this.args.length; idx < len; idx++) {
            value += String(this.args[idx]) + " ";
          }
          value += this.name;
          return value;
        };
        PDFOperator2.prototype.sizeInBytes = function() {
          var size = 0;
          for (var idx = 0, len = this.args.length; idx < len; idx++) {
            var arg = this.args[idx];
            size += (arg instanceof PDFObject_1.default ? arg.sizeInBytes() : arg.length) + 1;
          }
          size += this.name.length;
          return size;
        };
        PDFOperator2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          for (var idx = 0, len = this.args.length; idx < len; idx++) {
            var arg = this.args[idx];
            if (arg instanceof PDFObject_1.default) {
              offset2 += arg.copyBytesInto(buffer, offset2);
            } else {
              offset2 += utils_1.copyStringIntoBuffer(arg, buffer, offset2);
            }
            buffer[offset2++] = CharCodes_1.default.Space;
          }
          offset2 += utils_1.copyStringIntoBuffer(this.name, buffer, offset2);
          return offset2 - initialOffset;
        };
        PDFOperator2.of = function(name, args) {
          return new PDFOperator2(name, args);
        };
        return PDFOperator2;
      }()
    );
    exports.default = PDFOperator;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/operators/PDFOperatorNames.js
var require_PDFOperatorNames = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/operators/PDFOperatorNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PDFOperatorNames;
    (function(PDFOperatorNames2) {
      PDFOperatorNames2["NonStrokingColor"] = "sc";
      PDFOperatorNames2["NonStrokingColorN"] = "scn";
      PDFOperatorNames2["NonStrokingColorRgb"] = "rg";
      PDFOperatorNames2["NonStrokingColorGray"] = "g";
      PDFOperatorNames2["NonStrokingColorCmyk"] = "k";
      PDFOperatorNames2["NonStrokingColorspace"] = "cs";
      PDFOperatorNames2["StrokingColor"] = "SC";
      PDFOperatorNames2["StrokingColorN"] = "SCN";
      PDFOperatorNames2["StrokingColorRgb"] = "RG";
      PDFOperatorNames2["StrokingColorGray"] = "G";
      PDFOperatorNames2["StrokingColorCmyk"] = "K";
      PDFOperatorNames2["StrokingColorspace"] = "CS";
      PDFOperatorNames2["BeginMarkedContentSequence"] = "BDC";
      PDFOperatorNames2["BeginMarkedContent"] = "BMC";
      PDFOperatorNames2["EndMarkedContent"] = "EMC";
      PDFOperatorNames2["MarkedContentPointWithProps"] = "DP";
      PDFOperatorNames2["MarkedContentPoint"] = "MP";
      PDFOperatorNames2["DrawObject"] = "Do";
      PDFOperatorNames2["ConcatTransformationMatrix"] = "cm";
      PDFOperatorNames2["PopGraphicsState"] = "Q";
      PDFOperatorNames2["PushGraphicsState"] = "q";
      PDFOperatorNames2["SetFlatness"] = "i";
      PDFOperatorNames2["SetGraphicsStateParams"] = "gs";
      PDFOperatorNames2["SetLineCapStyle"] = "J";
      PDFOperatorNames2["SetLineDashPattern"] = "d";
      PDFOperatorNames2["SetLineJoinStyle"] = "j";
      PDFOperatorNames2["SetLineMiterLimit"] = "M";
      PDFOperatorNames2["SetLineWidth"] = "w";
      PDFOperatorNames2["SetTextMatrix"] = "Tm";
      PDFOperatorNames2["SetRenderingIntent"] = "ri";
      PDFOperatorNames2["AppendRectangle"] = "re";
      PDFOperatorNames2["BeginInlineImage"] = "BI";
      PDFOperatorNames2["BeginInlineImageData"] = "ID";
      PDFOperatorNames2["EndInlineImage"] = "EI";
      PDFOperatorNames2["ClipEvenOdd"] = "W*";
      PDFOperatorNames2["ClipNonZero"] = "W";
      PDFOperatorNames2["CloseAndStroke"] = "s";
      PDFOperatorNames2["CloseFillEvenOddAndStroke"] = "b*";
      PDFOperatorNames2["CloseFillNonZeroAndStroke"] = "b";
      PDFOperatorNames2["ClosePath"] = "h";
      PDFOperatorNames2["AppendBezierCurve"] = "c";
      PDFOperatorNames2["CurveToReplicateFinalPoint"] = "y";
      PDFOperatorNames2["CurveToReplicateInitialPoint"] = "v";
      PDFOperatorNames2["EndPath"] = "n";
      PDFOperatorNames2["FillEvenOddAndStroke"] = "B*";
      PDFOperatorNames2["FillEvenOdd"] = "f*";
      PDFOperatorNames2["FillNonZeroAndStroke"] = "B";
      PDFOperatorNames2["FillNonZero"] = "f";
      PDFOperatorNames2["LegacyFillNonZero"] = "F";
      PDFOperatorNames2["LineTo"] = "l";
      PDFOperatorNames2["MoveTo"] = "m";
      PDFOperatorNames2["ShadingFill"] = "sh";
      PDFOperatorNames2["StrokePath"] = "S";
      PDFOperatorNames2["BeginText"] = "BT";
      PDFOperatorNames2["EndText"] = "ET";
      PDFOperatorNames2["MoveText"] = "Td";
      PDFOperatorNames2["MoveTextSetLeading"] = "TD";
      PDFOperatorNames2["NextLine"] = "T*";
      PDFOperatorNames2["SetCharacterSpacing"] = "Tc";
      PDFOperatorNames2["SetFontAndSize"] = "Tf";
      PDFOperatorNames2["SetTextHorizontalScaling"] = "Tz";
      PDFOperatorNames2["SetTextLineHeight"] = "TL";
      PDFOperatorNames2["SetTextRenderingMode"] = "Tr";
      PDFOperatorNames2["SetTextRise"] = "Ts";
      PDFOperatorNames2["SetWordSpacing"] = "Tw";
      PDFOperatorNames2["ShowText"] = "Tj";
      PDFOperatorNames2["ShowTextAdjusted"] = "TJ";
      PDFOperatorNames2["ShowTextLine"] = "'";
      PDFOperatorNames2["ShowTextLineAndSpace"] = '"';
      PDFOperatorNames2["Type3D0"] = "d0";
      PDFOperatorNames2["Type3D1"] = "d1";
      PDFOperatorNames2["BeginCompatibilitySection"] = "BX";
      PDFOperatorNames2["EndCompatibilitySection"] = "EX";
    })(PDFOperatorNames || (PDFOperatorNames = {}));
    exports.default = PDFOperatorNames;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/structures/PDFFlateStream.js
var require_PDFFlateStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/structures/PDFFlateStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var pako_1 = tslib_1.__importDefault(require_pako());
    var errors_1 = require_errors2();
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var utils_1 = require_utils2();
    var PDFFlateStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFFlateStream2, _super);
        function PDFFlateStream2(dict, encode) {
          var _this = _super.call(this, dict) || this;
          _this.computeContents = function() {
            var unencodedContents = _this.getUnencodedContents();
            return _this.encode ? pako_1.default.deflate(unencodedContents) : unencodedContents;
          };
          _this.encode = encode;
          if (encode)
            dict.set(PDFName_1.default.of("Filter"), PDFName_1.default.of("FlateDecode"));
          _this.contentsCache = utils_1.Cache.populatedBy(_this.computeContents);
          return _this;
        }
        PDFFlateStream2.prototype.getContents = function() {
          return this.contentsCache.access();
        };
        PDFFlateStream2.prototype.getContentsSize = function() {
          return this.contentsCache.access().length;
        };
        PDFFlateStream2.prototype.getUnencodedContents = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "getUnencodedContents");
        };
        return PDFFlateStream2;
      }(PDFStream_1.default)
    );
    exports.default = PDFFlateStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/structures/PDFContentStream.js
var require_PDFContentStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/structures/PDFContentStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFFlateStream_1 = tslib_1.__importDefault(require_PDFFlateStream());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var PDFContentStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFContentStream2, _super);
        function PDFContentStream2(dict, operators, encode) {
          if (encode === void 0) {
            encode = true;
          }
          var _this = _super.call(this, dict, encode) || this;
          _this.operators = operators;
          return _this;
        }
        PDFContentStream2.prototype.push = function() {
          var _a;
          var operators = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            operators[_i] = arguments[_i];
          }
          (_a = this.operators).push.apply(_a, operators);
        };
        PDFContentStream2.prototype.clone = function(context) {
          var operators = new Array(this.operators.length);
          for (var idx = 0, len = this.operators.length; idx < len; idx++) {
            operators[idx] = this.operators[idx].clone(context);
          }
          var _a = this, dict = _a.dict, encode = _a.encode;
          return PDFContentStream2.of(dict.clone(context), operators, encode);
        };
        PDFContentStream2.prototype.getContentsString = function() {
          var value = "";
          for (var idx = 0, len = this.operators.length; idx < len; idx++) {
            value += this.operators[idx] + "\n";
          }
          return value;
        };
        PDFContentStream2.prototype.getUnencodedContents = function() {
          var buffer = new Uint8Array(this.getUnencodedContentsSize());
          var offset2 = 0;
          for (var idx = 0, len = this.operators.length; idx < len; idx++) {
            offset2 += this.operators[idx].copyBytesInto(buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Newline;
          }
          return buffer;
        };
        PDFContentStream2.prototype.getUnencodedContentsSize = function() {
          var size = 0;
          for (var idx = 0, len = this.operators.length; idx < len; idx++) {
            size += this.operators[idx].sizeInBytes() + 1;
          }
          return size;
        };
        PDFContentStream2.of = function(dict, operators, encode) {
          if (encode === void 0) {
            encode = true;
          }
          return new PDFContentStream2(dict, operators, encode);
        };
        return PDFContentStream2;
      }(PDFFlateStream_1.default)
    );
    exports.default = PDFContentStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/rng.js
var require_rng = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/rng.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleRNG = void 0;
    var SimpleRNG = (
      /** @class */
      function() {
        function SimpleRNG2(seed) {
          this.seed = seed;
        }
        SimpleRNG2.prototype.nextInt = function() {
          var x = Math.sin(this.seed++) * 1e4;
          return x - Math.floor(x);
        };
        SimpleRNG2.withSeed = function(seed) {
          return new SimpleRNG2(seed);
        };
        return SimpleRNG2;
      }()
    );
    exports.SimpleRNG = SimpleRNG;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/PDFContext.js
var require_PDFContext = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/PDFContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var pako_1 = tslib_1.__importDefault(require_pako());
    var PDFHeader_1 = tslib_1.__importDefault(require_PDFHeader());
    var errors_1 = require_errors2();
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFBool_1 = tslib_1.__importDefault(require_PDFBool());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNull_1 = tslib_1.__importDefault(require_PDFNull());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var PDFRawStream_1 = tslib_1.__importDefault(require_PDFRawStream());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFOperator_1 = tslib_1.__importDefault(require_PDFOperator());
    var PDFOperatorNames_1 = tslib_1.__importDefault(require_PDFOperatorNames());
    var PDFContentStream_1 = tslib_1.__importDefault(require_PDFContentStream());
    var utils_1 = require_utils2();
    var rng_1 = require_rng();
    var byAscendingObjectNumber = function(_a, _b) {
      var a = _a[0];
      var b = _b[0];
      return a.objectNumber - b.objectNumber;
    };
    var PDFContext = (
      /** @class */
      function() {
        function PDFContext2() {
          this.largestObjectNumber = 0;
          this.header = PDFHeader_1.default.forVersion(1, 7);
          this.trailerInfo = {};
          this.indirectObjects = /* @__PURE__ */ new Map();
          this.rng = rng_1.SimpleRNG.withSeed(1);
        }
        PDFContext2.prototype.assign = function(ref, object2) {
          this.indirectObjects.set(ref, object2);
          if (ref.objectNumber > this.largestObjectNumber) {
            this.largestObjectNumber = ref.objectNumber;
          }
        };
        PDFContext2.prototype.nextRef = function() {
          this.largestObjectNumber += 1;
          return PDFRef_1.default.of(this.largestObjectNumber);
        };
        PDFContext2.prototype.register = function(object2) {
          var ref = this.nextRef();
          this.assign(ref, object2);
          return ref;
        };
        PDFContext2.prototype.delete = function(ref) {
          return this.indirectObjects.delete(ref);
        };
        PDFContext2.prototype.lookupMaybe = function(ref) {
          var types2 = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types2[_i - 1] = arguments[_i];
          }
          var preservePDFNull = types2.includes(PDFNull_1.default);
          var result = ref instanceof PDFRef_1.default ? this.indirectObjects.get(ref) : ref;
          if (!result || result === PDFNull_1.default && !preservePDFNull)
            return void 0;
          for (var idx = 0, len = types2.length; idx < len; idx++) {
            var type = types2[idx];
            if (type === PDFNull_1.default) {
              if (result === PDFNull_1.default)
                return result;
            } else {
              if (result instanceof type)
                return result;
            }
          }
          throw new errors_1.UnexpectedObjectTypeError(types2, result);
        };
        PDFContext2.prototype.lookup = function(ref) {
          var types2 = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            types2[_i - 1] = arguments[_i];
          }
          var result = ref instanceof PDFRef_1.default ? this.indirectObjects.get(ref) : ref;
          if (types2.length === 0)
            return result;
          for (var idx = 0, len = types2.length; idx < len; idx++) {
            var type = types2[idx];
            if (type === PDFNull_1.default) {
              if (result === PDFNull_1.default)
                return result;
            } else {
              if (result instanceof type)
                return result;
            }
          }
          throw new errors_1.UnexpectedObjectTypeError(types2, result);
        };
        PDFContext2.prototype.getObjectRef = function(pdfObject) {
          var entries = Array.from(this.indirectObjects.entries());
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], ref = _a[0], object2 = _a[1];
            if (object2 === pdfObject) {
              return ref;
            }
          }
          return void 0;
        };
        PDFContext2.prototype.enumerateIndirectObjects = function() {
          return Array.from(this.indirectObjects.entries()).sort(byAscendingObjectNumber);
        };
        PDFContext2.prototype.obj = function(literal) {
          if (literal instanceof PDFObject_1.default) {
            return literal;
          } else if (literal === null || literal === void 0) {
            return PDFNull_1.default;
          } else if (typeof literal === "string") {
            return PDFName_1.default.of(literal);
          } else if (typeof literal === "number") {
            return PDFNumber_1.default.of(literal);
          } else if (typeof literal === "boolean") {
            return literal ? PDFBool_1.default.True : PDFBool_1.default.False;
          } else if (Array.isArray(literal)) {
            var array2 = PDFArray_1.default.withContext(this);
            for (var idx = 0, len = literal.length; idx < len; idx++) {
              array2.push(this.obj(literal[idx]));
            }
            return array2;
          } else {
            var dict = PDFDict_1.default.withContext(this);
            var keys = Object.keys(literal);
            for (var idx = 0, len = keys.length; idx < len; idx++) {
              var key = keys[idx];
              var value = literal[key];
              if (value !== void 0)
                dict.set(PDFName_1.default.of(key), this.obj(value));
            }
            return dict;
          }
        };
        PDFContext2.prototype.stream = function(contents, dict) {
          if (dict === void 0) {
            dict = {};
          }
          return PDFRawStream_1.default.of(this.obj(dict), utils_1.typedArrayFor(contents));
        };
        PDFContext2.prototype.flateStream = function(contents, dict) {
          if (dict === void 0) {
            dict = {};
          }
          return this.stream(pako_1.default.deflate(utils_1.typedArrayFor(contents)), tslib_1.__assign(tslib_1.__assign({}, dict), { Filter: "FlateDecode" }));
        };
        PDFContext2.prototype.contentStream = function(operators, dict) {
          if (dict === void 0) {
            dict = {};
          }
          return PDFContentStream_1.default.of(this.obj(dict), operators);
        };
        PDFContext2.prototype.formXObject = function(operators, dict) {
          if (dict === void 0) {
            dict = {};
          }
          return this.contentStream(operators, tslib_1.__assign(tslib_1.__assign({ BBox: this.obj([0, 0, 0, 0]), Matrix: this.obj([1, 0, 0, 1, 0, 0]) }, dict), { Type: "XObject", Subtype: "Form" }));
        };
        PDFContext2.prototype.getPushGraphicsStateContentStream = function() {
          if (this.pushGraphicsStateContentStreamRef) {
            return this.pushGraphicsStateContentStreamRef;
          }
          var dict = this.obj({});
          var op = PDFOperator_1.default.of(PDFOperatorNames_1.default.PushGraphicsState);
          var stream = PDFContentStream_1.default.of(dict, [op]);
          this.pushGraphicsStateContentStreamRef = this.register(stream);
          return this.pushGraphicsStateContentStreamRef;
        };
        PDFContext2.prototype.getPopGraphicsStateContentStream = function() {
          if (this.popGraphicsStateContentStreamRef) {
            return this.popGraphicsStateContentStreamRef;
          }
          var dict = this.obj({});
          var op = PDFOperator_1.default.of(PDFOperatorNames_1.default.PopGraphicsState);
          var stream = PDFContentStream_1.default.of(dict, [op]);
          this.popGraphicsStateContentStreamRef = this.register(stream);
          return this.popGraphicsStateContentStreamRef;
        };
        PDFContext2.prototype.addRandomSuffix = function(prefix, suffixLength) {
          if (suffixLength === void 0) {
            suffixLength = 4;
          }
          return prefix + "-" + Math.floor(this.rng.nextInt() * Math.pow(10, suffixLength));
        };
        PDFContext2.create = function() {
          return new PDFContext2();
        };
        return PDFContext2;
      }()
    );
    exports.default = PDFContext;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/structures/PDFPageLeaf.js
var require_PDFPageLeaf = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/structures/PDFPageLeaf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var PDFPageLeaf = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFPageLeaf2, _super);
        function PDFPageLeaf2(map, context, autoNormalizeCTM) {
          if (autoNormalizeCTM === void 0) {
            autoNormalizeCTM = true;
          }
          var _this = _super.call(this, map, context) || this;
          _this.normalized = false;
          _this.autoNormalizeCTM = autoNormalizeCTM;
          return _this;
        }
        PDFPageLeaf2.prototype.clone = function(context) {
          var clone3 = PDFPageLeaf2.fromMapWithContext(/* @__PURE__ */ new Map(), context || this.context, this.autoNormalizeCTM);
          var entries = this.entries();
          for (var idx = 0, len = entries.length; idx < len; idx++) {
            var _a = entries[idx], key = _a[0], value = _a[1];
            clone3.set(key, value);
          }
          return clone3;
        };
        PDFPageLeaf2.prototype.Parent = function() {
          return this.lookupMaybe(PDFName_1.default.Parent, PDFDict_1.default);
        };
        PDFPageLeaf2.prototype.Contents = function() {
          return this.lookup(PDFName_1.default.of("Contents"));
        };
        PDFPageLeaf2.prototype.Annots = function() {
          return this.lookupMaybe(PDFName_1.default.Annots, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.BleedBox = function() {
          return this.lookupMaybe(PDFName_1.default.BleedBox, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.TrimBox = function() {
          return this.lookupMaybe(PDFName_1.default.TrimBox, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.ArtBox = function() {
          return this.lookupMaybe(PDFName_1.default.ArtBox, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.Resources = function() {
          var dictOrRef = this.getInheritableAttribute(PDFName_1.default.Resources);
          return this.context.lookupMaybe(dictOrRef, PDFDict_1.default);
        };
        PDFPageLeaf2.prototype.MediaBox = function() {
          var arrayOrRef = this.getInheritableAttribute(PDFName_1.default.MediaBox);
          return this.context.lookup(arrayOrRef, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.CropBox = function() {
          var arrayOrRef = this.getInheritableAttribute(PDFName_1.default.CropBox);
          return this.context.lookupMaybe(arrayOrRef, PDFArray_1.default);
        };
        PDFPageLeaf2.prototype.Rotate = function() {
          var numberOrRef = this.getInheritableAttribute(PDFName_1.default.Rotate);
          return this.context.lookupMaybe(numberOrRef, PDFNumber_1.default);
        };
        PDFPageLeaf2.prototype.getInheritableAttribute = function(name) {
          var attribute;
          this.ascend(function(node) {
            if (!attribute)
              attribute = node.get(name);
          });
          return attribute;
        };
        PDFPageLeaf2.prototype.setParent = function(parentRef) {
          this.set(PDFName_1.default.Parent, parentRef);
        };
        PDFPageLeaf2.prototype.addContentStream = function(contentStreamRef) {
          var Contents = this.normalizedEntries().Contents || this.context.obj([]);
          this.set(PDFName_1.default.Contents, Contents);
          Contents.push(contentStreamRef);
        };
        PDFPageLeaf2.prototype.wrapContentStreams = function(startStream, endStream) {
          var Contents = this.Contents();
          if (Contents instanceof PDFArray_1.default) {
            Contents.insert(0, startStream);
            Contents.push(endStream);
            return true;
          }
          return false;
        };
        PDFPageLeaf2.prototype.addAnnot = function(annotRef) {
          var Annots = this.normalizedEntries().Annots;
          Annots.push(annotRef);
        };
        PDFPageLeaf2.prototype.removeAnnot = function(annotRef) {
          var Annots = this.normalizedEntries().Annots;
          var index2 = Annots.indexOf(annotRef);
          if (index2 !== void 0) {
            Annots.remove(index2);
          }
        };
        PDFPageLeaf2.prototype.setFontDictionary = function(name, fontDictRef) {
          var Font = this.normalizedEntries().Font;
          Font.set(name, fontDictRef);
        };
        PDFPageLeaf2.prototype.newFontDictionaryKey = function(tag) {
          var Font = this.normalizedEntries().Font;
          return Font.uniqueKey(tag);
        };
        PDFPageLeaf2.prototype.newFontDictionary = function(tag, fontDictRef) {
          var key = this.newFontDictionaryKey(tag);
          this.setFontDictionary(key, fontDictRef);
          return key;
        };
        PDFPageLeaf2.prototype.setXObject = function(name, xObjectRef) {
          var XObject = this.normalizedEntries().XObject;
          XObject.set(name, xObjectRef);
        };
        PDFPageLeaf2.prototype.newXObjectKey = function(tag) {
          var XObject = this.normalizedEntries().XObject;
          return XObject.uniqueKey(tag);
        };
        PDFPageLeaf2.prototype.newXObject = function(tag, xObjectRef) {
          var key = this.newXObjectKey(tag);
          this.setXObject(key, xObjectRef);
          return key;
        };
        PDFPageLeaf2.prototype.setExtGState = function(name, extGStateRef) {
          var ExtGState = this.normalizedEntries().ExtGState;
          ExtGState.set(name, extGStateRef);
        };
        PDFPageLeaf2.prototype.newExtGStateKey = function(tag) {
          var ExtGState = this.normalizedEntries().ExtGState;
          return ExtGState.uniqueKey(tag);
        };
        PDFPageLeaf2.prototype.newExtGState = function(tag, extGStateRef) {
          var key = this.newExtGStateKey(tag);
          this.setExtGState(key, extGStateRef);
          return key;
        };
        PDFPageLeaf2.prototype.ascend = function(visitor) {
          visitor(this);
          var Parent = this.Parent();
          if (Parent)
            Parent.ascend(visitor);
        };
        PDFPageLeaf2.prototype.normalize = function() {
          if (this.normalized)
            return;
          var context = this.context;
          var contentsRef = this.get(PDFName_1.default.Contents);
          var contents = this.context.lookup(contentsRef);
          if (contents instanceof PDFStream_1.default) {
            this.set(PDFName_1.default.Contents, context.obj([contentsRef]));
          }
          if (this.autoNormalizeCTM) {
            this.wrapContentStreams(this.context.getPushGraphicsStateContentStream(), this.context.getPopGraphicsStateContentStream());
          }
          var dictOrRef = this.getInheritableAttribute(PDFName_1.default.Resources);
          var Resources = context.lookupMaybe(dictOrRef, PDFDict_1.default) || context.obj({});
          this.set(PDFName_1.default.Resources, Resources);
          var Font = Resources.lookupMaybe(PDFName_1.default.Font, PDFDict_1.default) || context.obj({});
          Resources.set(PDFName_1.default.Font, Font);
          var XObject = Resources.lookupMaybe(PDFName_1.default.XObject, PDFDict_1.default) || context.obj({});
          Resources.set(PDFName_1.default.XObject, XObject);
          var ExtGState = Resources.lookupMaybe(PDFName_1.default.ExtGState, PDFDict_1.default) || context.obj({});
          Resources.set(PDFName_1.default.ExtGState, ExtGState);
          var Annots = this.Annots() || context.obj([]);
          this.set(PDFName_1.default.Annots, Annots);
          this.normalized = true;
        };
        PDFPageLeaf2.prototype.normalizedEntries = function() {
          this.normalize();
          var Annots = this.Annots();
          var Resources = this.Resources();
          var Contents = this.Contents();
          return {
            Annots,
            Resources,
            Contents,
            Font: Resources.lookup(PDFName_1.default.Font, PDFDict_1.default),
            XObject: Resources.lookup(PDFName_1.default.XObject, PDFDict_1.default),
            ExtGState: Resources.lookup(PDFName_1.default.ExtGState, PDFDict_1.default)
          };
        };
        PDFPageLeaf2.InheritableEntries = [
          "Resources",
          "MediaBox",
          "CropBox",
          "Rotate"
        ];
        PDFPageLeaf2.withContextAndParent = function(context, parent) {
          var dict = /* @__PURE__ */ new Map();
          dict.set(PDFName_1.default.Type, PDFName_1.default.Page);
          dict.set(PDFName_1.default.Parent, parent);
          dict.set(PDFName_1.default.Resources, context.obj({}));
          dict.set(PDFName_1.default.MediaBox, context.obj([0, 0, 612, 792]));
          return new PDFPageLeaf2(dict, context, false);
        };
        PDFPageLeaf2.fromMapWithContext = function(map, context, autoNormalizeCTM) {
          if (autoNormalizeCTM === void 0) {
            autoNormalizeCTM = true;
          }
          return new PDFPageLeaf2(map, context, autoNormalizeCTM);
        };
        return PDFPageLeaf2;
      }(PDFDict_1.default)
    );
    exports.default = PDFPageLeaf;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/PDFObjectCopier.js
var require_PDFObjectCopier = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/PDFObjectCopier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var PDFPageLeaf_1 = tslib_1.__importDefault(require_PDFPageLeaf());
    var PDFObjectCopier = (
      /** @class */
      function() {
        function PDFObjectCopier2(src, dest) {
          var _this = this;
          this.traversedObjects = /* @__PURE__ */ new Map();
          this.copy = function(object2) {
            return object2 instanceof PDFPageLeaf_1.default ? _this.copyPDFPage(object2) : object2 instanceof PDFDict_1.default ? _this.copyPDFDict(object2) : object2 instanceof PDFArray_1.default ? _this.copyPDFArray(object2) : object2 instanceof PDFStream_1.default ? _this.copyPDFStream(object2) : object2 instanceof PDFRef_1.default ? _this.copyPDFIndirectObject(object2) : object2.clone();
          };
          this.copyPDFPage = function(originalPage) {
            var clonedPage = originalPage.clone();
            var InheritableEntries = PDFPageLeaf_1.default.InheritableEntries;
            for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {
              var key = PDFName_1.default.of(InheritableEntries[idx]);
              var value = clonedPage.getInheritableAttribute(key);
              if (!clonedPage.get(key) && value)
                clonedPage.set(key, value);
            }
            clonedPage.delete(PDFName_1.default.of("Parent"));
            return _this.copyPDFDict(clonedPage);
          };
          this.copyPDFDict = function(originalDict) {
            if (_this.traversedObjects.has(originalDict)) {
              return _this.traversedObjects.get(originalDict);
            }
            var clonedDict = originalDict.clone(_this.dest);
            _this.traversedObjects.set(originalDict, clonedDict);
            var entries = originalDict.entries();
            for (var idx = 0, len = entries.length; idx < len; idx++) {
              var _a = entries[idx], key = _a[0], value = _a[1];
              clonedDict.set(key, _this.copy(value));
            }
            return clonedDict;
          };
          this.copyPDFArray = function(originalArray) {
            if (_this.traversedObjects.has(originalArray)) {
              return _this.traversedObjects.get(originalArray);
            }
            var clonedArray = originalArray.clone(_this.dest);
            _this.traversedObjects.set(originalArray, clonedArray);
            for (var idx = 0, len = originalArray.size(); idx < len; idx++) {
              var value = originalArray.get(idx);
              clonedArray.set(idx, _this.copy(value));
            }
            return clonedArray;
          };
          this.copyPDFStream = function(originalStream) {
            if (_this.traversedObjects.has(originalStream)) {
              return _this.traversedObjects.get(originalStream);
            }
            var clonedStream = originalStream.clone(_this.dest);
            _this.traversedObjects.set(originalStream, clonedStream);
            var entries = originalStream.dict.entries();
            for (var idx = 0, len = entries.length; idx < len; idx++) {
              var _a = entries[idx], key = _a[0], value = _a[1];
              clonedStream.dict.set(key, _this.copy(value));
            }
            return clonedStream;
          };
          this.copyPDFIndirectObject = function(ref) {
            var alreadyMapped = _this.traversedObjects.has(ref);
            if (!alreadyMapped) {
              var newRef = _this.dest.nextRef();
              _this.traversedObjects.set(ref, newRef);
              var dereferencedValue = _this.src.lookup(ref);
              if (dereferencedValue) {
                var cloned = _this.copy(dereferencedValue);
                _this.dest.assign(newRef, cloned);
              }
            }
            return _this.traversedObjects.get(ref);
          };
          this.src = src;
          this.dest = dest;
        }
        PDFObjectCopier2.for = function(src, dest) {
          return new PDFObjectCopier2(src, dest);
        };
        return PDFObjectCopier2;
      }()
    );
    exports.default = PDFObjectCopier;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/document/PDFCrossRefSection.js
var require_PDFCrossRefSection = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/document/PDFCrossRefSection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFCrossRefSection = (
      /** @class */
      function() {
        function PDFCrossRefSection2(firstEntry) {
          this.subsections = firstEntry ? [[firstEntry]] : [];
          this.chunkIdx = 0;
          this.chunkLength = firstEntry ? 1 : 0;
        }
        PDFCrossRefSection2.prototype.addEntry = function(ref, offset2) {
          this.append({ ref, offset: offset2, deleted: false });
        };
        PDFCrossRefSection2.prototype.addDeletedEntry = function(ref, nextFreeObjectNumber) {
          this.append({ ref, offset: nextFreeObjectNumber, deleted: true });
        };
        PDFCrossRefSection2.prototype.toString = function() {
          var section = "xref\n";
          for (var rangeIdx = 0, rangeLen = this.subsections.length; rangeIdx < rangeLen; rangeIdx++) {
            var range = this.subsections[rangeIdx];
            section += range[0].ref.objectNumber + " " + range.length + "\n";
            for (var entryIdx = 0, entryLen = range.length; entryIdx < entryLen; entryIdx++) {
              var entry = range[entryIdx];
              section += utils_1.padStart(String(entry.offset), 10, "0");
              section += " ";
              section += utils_1.padStart(String(entry.ref.generationNumber), 5, "0");
              section += " ";
              section += entry.deleted ? "f" : "n";
              section += " \n";
            }
          }
          return section;
        };
        PDFCrossRefSection2.prototype.sizeInBytes = function() {
          var size = 5;
          for (var idx = 0, len = this.subsections.length; idx < len; idx++) {
            var subsection = this.subsections[idx];
            var subsectionLength = subsection.length;
            var firstEntry = subsection[0];
            size += 2;
            size += String(firstEntry.ref.objectNumber).length;
            size += String(subsectionLength).length;
            size += 20 * subsectionLength;
          }
          return size;
        };
        PDFCrossRefSection2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.x;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.f;
          buffer[offset2++] = CharCodes_1.default.Newline;
          offset2 += this.copySubsectionsIntoBuffer(this.subsections, buffer, offset2);
          return offset2 - initialOffset;
        };
        PDFCrossRefSection2.prototype.copySubsectionsIntoBuffer = function(subsections, buffer, offset2) {
          var initialOffset = offset2;
          var length = subsections.length;
          for (var idx = 0; idx < length; idx++) {
            var subsection = this.subsections[idx];
            var firstObjectNumber = String(subsection[0].ref.objectNumber);
            offset2 += utils_1.copyStringIntoBuffer(firstObjectNumber, buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Space;
            var rangeLength = String(subsection.length);
            offset2 += utils_1.copyStringIntoBuffer(rangeLength, buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Newline;
            offset2 += this.copyEntriesIntoBuffer(subsection, buffer, offset2);
          }
          return offset2 - initialOffset;
        };
        PDFCrossRefSection2.prototype.copyEntriesIntoBuffer = function(entries, buffer, offset2) {
          var length = entries.length;
          for (var idx = 0; idx < length; idx++) {
            var entry = entries[idx];
            var entryOffset = utils_1.padStart(String(entry.offset), 10, "0");
            offset2 += utils_1.copyStringIntoBuffer(entryOffset, buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Space;
            var entryGen = utils_1.padStart(String(entry.ref.generationNumber), 5, "0");
            offset2 += utils_1.copyStringIntoBuffer(entryGen, buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Space;
            buffer[offset2++] = entry.deleted ? CharCodes_1.default.f : CharCodes_1.default.n;
            buffer[offset2++] = CharCodes_1.default.Space;
            buffer[offset2++] = CharCodes_1.default.Newline;
          }
          return 20 * length;
        };
        PDFCrossRefSection2.prototype.append = function(currEntry) {
          if (this.chunkLength === 0) {
            this.subsections.push([currEntry]);
            this.chunkIdx = 0;
            this.chunkLength = 1;
            return;
          }
          var chunk = this.subsections[this.chunkIdx];
          var prevEntry = chunk[this.chunkLength - 1];
          if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {
            this.subsections.push([currEntry]);
            this.chunkIdx += 1;
            this.chunkLength = 1;
          } else {
            chunk.push(currEntry);
            this.chunkLength += 1;
          }
        };
        PDFCrossRefSection2.create = function() {
          return new PDFCrossRefSection2({
            ref: PDFRef_1.default.of(0, 65535),
            offset: 0,
            deleted: true
          });
        };
        PDFCrossRefSection2.createEmpty = function() {
          return new PDFCrossRefSection2();
        };
        return PDFCrossRefSection2;
      }()
    );
    exports.default = PDFCrossRefSection;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/document/PDFTrailer.js
var require_PDFTrailer = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/document/PDFTrailer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFTrailer = (
      /** @class */
      function() {
        function PDFTrailer2(lastXRefOffset) {
          this.lastXRefOffset = String(lastXRefOffset);
        }
        PDFTrailer2.prototype.toString = function() {
          return "startxref\n" + this.lastXRefOffset + "\n%%EOF";
        };
        PDFTrailer2.prototype.sizeInBytes = function() {
          return 16 + this.lastXRefOffset.length;
        };
        PDFTrailer2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.s;
          buffer[offset2++] = CharCodes_1.default.t;
          buffer[offset2++] = CharCodes_1.default.a;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.t;
          buffer[offset2++] = CharCodes_1.default.x;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.f;
          buffer[offset2++] = CharCodes_1.default.Newline;
          offset2 += utils_1.copyStringIntoBuffer(this.lastXRefOffset, buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.Newline;
          buffer[offset2++] = CharCodes_1.default.Percent;
          buffer[offset2++] = CharCodes_1.default.Percent;
          buffer[offset2++] = CharCodes_1.default.E;
          buffer[offset2++] = CharCodes_1.default.O;
          buffer[offset2++] = CharCodes_1.default.F;
          return offset2 - initialOffset;
        };
        PDFTrailer2.forLastCrossRefSectionOffset = function(offset2) {
          return new PDFTrailer2(offset2);
        };
        return PDFTrailer2;
      }()
    );
    exports.default = PDFTrailer;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/document/PDFTrailerDict.js
var require_PDFTrailerDict = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/document/PDFTrailerDict.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var PDFTrailerDict = (
      /** @class */
      function() {
        function PDFTrailerDict2(dict) {
          this.dict = dict;
        }
        PDFTrailerDict2.prototype.toString = function() {
          return "trailer\n" + this.dict.toString();
        };
        PDFTrailerDict2.prototype.sizeInBytes = function() {
          return 8 + this.dict.sizeInBytes();
        };
        PDFTrailerDict2.prototype.copyBytesInto = function(buffer, offset2) {
          var initialOffset = offset2;
          buffer[offset2++] = CharCodes_1.default.t;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.a;
          buffer[offset2++] = CharCodes_1.default.i;
          buffer[offset2++] = CharCodes_1.default.l;
          buffer[offset2++] = CharCodes_1.default.e;
          buffer[offset2++] = CharCodes_1.default.r;
          buffer[offset2++] = CharCodes_1.default.Newline;
          offset2 += this.dict.copyBytesInto(buffer, offset2);
          return offset2 - initialOffset;
        };
        PDFTrailerDict2.of = function(dict) {
          return new PDFTrailerDict2(dict);
        };
        return PDFTrailerDict2;
      }()
    );
    exports.default = PDFTrailerDict;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/structures/PDFObjectStream.js
var require_PDFObjectStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/structures/PDFObjectStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFFlateStream_1 = tslib_1.__importDefault(require_PDFFlateStream());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFObjectStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFObjectStream2, _super);
        function PDFObjectStream2(context, objects, encode) {
          if (encode === void 0) {
            encode = true;
          }
          var _this = _super.call(this, context.obj({}), encode) || this;
          _this.objects = objects;
          _this.offsets = _this.computeObjectOffsets();
          _this.offsetsString = _this.computeOffsetsString();
          _this.dict.set(PDFName_1.default.of("Type"), PDFName_1.default.of("ObjStm"));
          _this.dict.set(PDFName_1.default.of("N"), PDFNumber_1.default.of(_this.objects.length));
          _this.dict.set(PDFName_1.default.of("First"), PDFNumber_1.default.of(_this.offsetsString.length));
          return _this;
        }
        PDFObjectStream2.prototype.getObjectsCount = function() {
          return this.objects.length;
        };
        PDFObjectStream2.prototype.clone = function(context) {
          return PDFObjectStream2.withContextAndObjects(context || this.dict.context, this.objects.slice(), this.encode);
        };
        PDFObjectStream2.prototype.getContentsString = function() {
          var value = this.offsetsString;
          for (var idx = 0, len = this.objects.length; idx < len; idx++) {
            var _a = this.objects[idx], object2 = _a[1];
            value += object2 + "\n";
          }
          return value;
        };
        PDFObjectStream2.prototype.getUnencodedContents = function() {
          var buffer = new Uint8Array(this.getUnencodedContentsSize());
          var offset2 = utils_1.copyStringIntoBuffer(this.offsetsString, buffer, 0);
          for (var idx = 0, len = this.objects.length; idx < len; idx++) {
            var _a = this.objects[idx], object2 = _a[1];
            offset2 += object2.copyBytesInto(buffer, offset2);
            buffer[offset2++] = CharCodes_1.default.Newline;
          }
          return buffer;
        };
        PDFObjectStream2.prototype.getUnencodedContentsSize = function() {
          return this.offsetsString.length + utils_1.last(this.offsets)[1] + utils_1.last(this.objects)[1].sizeInBytes() + 1;
        };
        PDFObjectStream2.prototype.computeOffsetsString = function() {
          var offsetsString = "";
          for (var idx = 0, len = this.offsets.length; idx < len; idx++) {
            var _a = this.offsets[idx], objectNumber = _a[0], offset2 = _a[1];
            offsetsString += objectNumber + " " + offset2 + " ";
          }
          return offsetsString;
        };
        PDFObjectStream2.prototype.computeObjectOffsets = function() {
          var offset2 = 0;
          var offsets = new Array(this.objects.length);
          for (var idx = 0, len = this.objects.length; idx < len; idx++) {
            var _a = this.objects[idx], ref = _a[0], object2 = _a[1];
            offsets[idx] = [ref.objectNumber, offset2];
            offset2 += object2.sizeInBytes() + 1;
          }
          return offsets;
        };
        PDFObjectStream2.withContextAndObjects = function(context, objects, encode) {
          if (encode === void 0) {
            encode = true;
          }
          return new PDFObjectStream2(context, objects, encode);
        };
        return PDFObjectStream2;
      }(PDFFlateStream_1.default)
    );
    exports.default = PDFObjectStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/writers/PDFWriter.js
var require_PDFWriter = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/writers/PDFWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFCrossRefSection_1 = tslib_1.__importDefault(require_PDFCrossRefSection());
    var PDFHeader_1 = tslib_1.__importDefault(require_PDFHeader());
    var PDFTrailer_1 = tslib_1.__importDefault(require_PDFTrailer());
    var PDFTrailerDict_1 = tslib_1.__importDefault(require_PDFTrailerDict());
    var PDFObjectStream_1 = tslib_1.__importDefault(require_PDFObjectStream());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var PDFWriter = (
      /** @class */
      function() {
        function PDFWriter2(context, objectsPerTick) {
          var _this = this;
          this.parsedObjects = 0;
          this.shouldWaitForTick = function(n2) {
            _this.parsedObjects += n2;
            return _this.parsedObjects % _this.objectsPerTick === 0;
          };
          this.context = context;
          this.objectsPerTick = objectsPerTick;
        }
        PDFWriter2.prototype.serializeToBuffer = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, size, header, indirectObjects, xref, trailerDict, trailer, offset2, buffer, idx, len, _b, ref, object2, objectNumber, generationNumber, n2;
            return tslib_1.__generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  return [4, this.computeBufferSize()];
                case 1:
                  _a = _c.sent(), size = _a.size, header = _a.header, indirectObjects = _a.indirectObjects, xref = _a.xref, trailerDict = _a.trailerDict, trailer = _a.trailer;
                  offset2 = 0;
                  buffer = new Uint8Array(size);
                  offset2 += header.copyBytesInto(buffer, offset2);
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  idx = 0, len = indirectObjects.length;
                  _c.label = 2;
                case 2:
                  if (!(idx < len))
                    return [3, 5];
                  _b = indirectObjects[idx], ref = _b[0], object2 = _b[1];
                  objectNumber = String(ref.objectNumber);
                  offset2 += utils_1.copyStringIntoBuffer(objectNumber, buffer, offset2);
                  buffer[offset2++] = CharCodes_1.default.Space;
                  generationNumber = String(ref.generationNumber);
                  offset2 += utils_1.copyStringIntoBuffer(generationNumber, buffer, offset2);
                  buffer[offset2++] = CharCodes_1.default.Space;
                  buffer[offset2++] = CharCodes_1.default.o;
                  buffer[offset2++] = CharCodes_1.default.b;
                  buffer[offset2++] = CharCodes_1.default.j;
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  offset2 += object2.copyBytesInto(buffer, offset2);
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  buffer[offset2++] = CharCodes_1.default.e;
                  buffer[offset2++] = CharCodes_1.default.n;
                  buffer[offset2++] = CharCodes_1.default.d;
                  buffer[offset2++] = CharCodes_1.default.o;
                  buffer[offset2++] = CharCodes_1.default.b;
                  buffer[offset2++] = CharCodes_1.default.j;
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  buffer[offset2++] = CharCodes_1.default.Newline;
                  n2 = object2 instanceof PDFObjectStream_1.default ? object2.getObjectsCount() : 1;
                  if (!this.shouldWaitForTick(n2))
                    return [3, 4];
                  return [4, utils_1.waitForTick()];
                case 3:
                  _c.sent();
                  _c.label = 4;
                case 4:
                  idx++;
                  return [3, 2];
                case 5:
                  if (xref) {
                    offset2 += xref.copyBytesInto(buffer, offset2);
                    buffer[offset2++] = CharCodes_1.default.Newline;
                  }
                  if (trailerDict) {
                    offset2 += trailerDict.copyBytesInto(buffer, offset2);
                    buffer[offset2++] = CharCodes_1.default.Newline;
                    buffer[offset2++] = CharCodes_1.default.Newline;
                  }
                  offset2 += trailer.copyBytesInto(buffer, offset2);
                  return [2, buffer];
              }
            });
          });
        };
        PDFWriter2.prototype.computeIndirectObjectSize = function(_a) {
          var ref = _a[0], object2 = _a[1];
          var refSize = ref.sizeInBytes() + 3;
          var objectSize = object2.sizeInBytes() + 9;
          return refSize + objectSize;
        };
        PDFWriter2.prototype.createTrailerDict = function() {
          return this.context.obj({
            Size: this.context.largestObjectNumber + 1,
            Root: this.context.trailerInfo.Root,
            Encrypt: this.context.trailerInfo.Encrypt,
            Info: this.context.trailerInfo.Info,
            ID: this.context.trailerInfo.ID
          });
        };
        PDFWriter2.prototype.computeBufferSize = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var header, size, xref, indirectObjects, idx, len, indirectObject, ref, xrefOffset, trailerDict, trailer;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  header = PDFHeader_1.default.forVersion(1, 7);
                  size = header.sizeInBytes() + 2;
                  xref = PDFCrossRefSection_1.default.create();
                  indirectObjects = this.context.enumerateIndirectObjects();
                  idx = 0, len = indirectObjects.length;
                  _a.label = 1;
                case 1:
                  if (!(idx < len))
                    return [3, 4];
                  indirectObject = indirectObjects[idx];
                  ref = indirectObject[0];
                  xref.addEntry(ref, size);
                  size += this.computeIndirectObjectSize(indirectObject);
                  if (!this.shouldWaitForTick(1))
                    return [3, 3];
                  return [4, utils_1.waitForTick()];
                case 2:
                  _a.sent();
                  _a.label = 3;
                case 3:
                  idx++;
                  return [3, 1];
                case 4:
                  xrefOffset = size;
                  size += xref.sizeInBytes() + 1;
                  trailerDict = PDFTrailerDict_1.default.of(this.createTrailerDict());
                  size += trailerDict.sizeInBytes() + 2;
                  trailer = PDFTrailer_1.default.forLastCrossRefSectionOffset(xrefOffset);
                  size += trailer.sizeInBytes();
                  return [2, { size, header, indirectObjects, xref, trailerDict, trailer }];
              }
            });
          });
        };
        PDFWriter2.forContext = function(context, objectsPerTick) {
          return new PDFWriter2(context, objectsPerTick);
        };
        return PDFWriter2;
      }()
    );
    exports.default = PDFWriter;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFInvalidObject.js
var require_PDFInvalidObject = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFInvalidObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var PDFInvalidObject = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFInvalidObject2, _super);
        function PDFInvalidObject2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        PDFInvalidObject2.prototype.clone = function() {
          return PDFInvalidObject2.of(this.data.slice());
        };
        PDFInvalidObject2.prototype.toString = function() {
          return "PDFInvalidObject(" + this.data.length + " bytes)";
        };
        PDFInvalidObject2.prototype.sizeInBytes = function() {
          return this.data.length;
        };
        PDFInvalidObject2.prototype.copyBytesInto = function(buffer, offset2) {
          var length = this.data.length;
          for (var idx = 0; idx < length; idx++) {
            buffer[offset2++] = this.data[idx];
          }
          return length;
        };
        PDFInvalidObject2.of = function(data) {
          return new PDFInvalidObject2(data);
        };
        return PDFInvalidObject2;
      }(PDFObject_1.default)
    );
    exports.default = PDFInvalidObject;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/structures/PDFCrossRefStream.js
var require_PDFCrossRefStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/structures/PDFCrossRefStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntryType = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFFlateStream_1 = tslib_1.__importDefault(require_PDFFlateStream());
    var utils_1 = require_utils2();
    var EntryType;
    (function(EntryType2) {
      EntryType2[EntryType2["Deleted"] = 0] = "Deleted";
      EntryType2[EntryType2["Uncompressed"] = 1] = "Uncompressed";
      EntryType2[EntryType2["Compressed"] = 2] = "Compressed";
    })(EntryType = exports.EntryType || (exports.EntryType = {}));
    var PDFCrossRefStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFCrossRefStream2, _super);
        function PDFCrossRefStream2(dict, entries, encode) {
          if (encode === void 0) {
            encode = true;
          }
          var _this = _super.call(this, dict, encode) || this;
          _this.computeIndex = function() {
            var subsections = [];
            var subsectionLength = 0;
            for (var idx = 0, len = _this.entries.length; idx < len; idx++) {
              var currEntry = _this.entries[idx];
              var prevEntry = _this.entries[idx - 1];
              if (idx === 0) {
                subsections.push(currEntry.ref.objectNumber);
              } else if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {
                subsections.push(subsectionLength);
                subsections.push(currEntry.ref.objectNumber);
                subsectionLength = 0;
              }
              subsectionLength += 1;
            }
            subsections.push(subsectionLength);
            return subsections;
          };
          _this.computeEntryTuples = function() {
            var entryTuples = new Array(_this.entries.length);
            for (var idx = 0, len = _this.entries.length; idx < len; idx++) {
              var entry = _this.entries[idx];
              if (entry.type === EntryType.Deleted) {
                var type = entry.type, nextFreeObjectNumber = entry.nextFreeObjectNumber, ref = entry.ref;
                entryTuples[idx] = [type, nextFreeObjectNumber, ref.generationNumber];
              }
              if (entry.type === EntryType.Uncompressed) {
                var type = entry.type, offset2 = entry.offset, ref = entry.ref;
                entryTuples[idx] = [type, offset2, ref.generationNumber];
              }
              if (entry.type === EntryType.Compressed) {
                var type = entry.type, objectStreamRef = entry.objectStreamRef, index2 = entry.index;
                entryTuples[idx] = [type, objectStreamRef.objectNumber, index2];
              }
            }
            return entryTuples;
          };
          _this.computeMaxEntryByteWidths = function() {
            var entryTuples = _this.entryTuplesCache.access();
            var widths = [0, 0, 0];
            for (var idx = 0, len = entryTuples.length; idx < len; idx++) {
              var _a = entryTuples[idx], first = _a[0], second = _a[1], third = _a[2];
              var firstSize = utils_1.sizeInBytes(first);
              var secondSize = utils_1.sizeInBytes(second);
              var thirdSize = utils_1.sizeInBytes(third);
              if (firstSize > widths[0])
                widths[0] = firstSize;
              if (secondSize > widths[1])
                widths[1] = secondSize;
              if (thirdSize > widths[2])
                widths[2] = thirdSize;
            }
            return widths;
          };
          _this.entries = entries || [];
          _this.entryTuplesCache = utils_1.Cache.populatedBy(_this.computeEntryTuples);
          _this.maxByteWidthsCache = utils_1.Cache.populatedBy(_this.computeMaxEntryByteWidths);
          _this.indexCache = utils_1.Cache.populatedBy(_this.computeIndex);
          dict.set(PDFName_1.default.of("Type"), PDFName_1.default.of("XRef"));
          return _this;
        }
        PDFCrossRefStream2.prototype.addDeletedEntry = function(ref, nextFreeObjectNumber) {
          var type = EntryType.Deleted;
          this.entries.push({ type, ref, nextFreeObjectNumber });
          this.entryTuplesCache.invalidate();
          this.maxByteWidthsCache.invalidate();
          this.indexCache.invalidate();
          this.contentsCache.invalidate();
        };
        PDFCrossRefStream2.prototype.addUncompressedEntry = function(ref, offset2) {
          var type = EntryType.Uncompressed;
          this.entries.push({ type, ref, offset: offset2 });
          this.entryTuplesCache.invalidate();
          this.maxByteWidthsCache.invalidate();
          this.indexCache.invalidate();
          this.contentsCache.invalidate();
        };
        PDFCrossRefStream2.prototype.addCompressedEntry = function(ref, objectStreamRef, index2) {
          var type = EntryType.Compressed;
          this.entries.push({ type, ref, objectStreamRef, index: index2 });
          this.entryTuplesCache.invalidate();
          this.maxByteWidthsCache.invalidate();
          this.indexCache.invalidate();
          this.contentsCache.invalidate();
        };
        PDFCrossRefStream2.prototype.clone = function(context) {
          var _a = this, dict = _a.dict, entries = _a.entries, encode = _a.encode;
          return PDFCrossRefStream2.of(dict.clone(context), entries.slice(), encode);
        };
        PDFCrossRefStream2.prototype.getContentsString = function() {
          var entryTuples = this.entryTuplesCache.access();
          var byteWidths = this.maxByteWidthsCache.access();
          var value = "";
          for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {
            var _a = entryTuples[entryIdx], first = _a[0], second = _a[1], third = _a[2];
            var firstBytes = utils_1.reverseArray(utils_1.bytesFor(first));
            var secondBytes = utils_1.reverseArray(utils_1.bytesFor(second));
            var thirdBytes = utils_1.reverseArray(utils_1.bytesFor(third));
            for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {
              value += (firstBytes[idx] || 0).toString(2);
            }
            for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {
              value += (secondBytes[idx] || 0).toString(2);
            }
            for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {
              value += (thirdBytes[idx] || 0).toString(2);
            }
          }
          return value;
        };
        PDFCrossRefStream2.prototype.getUnencodedContents = function() {
          var entryTuples = this.entryTuplesCache.access();
          var byteWidths = this.maxByteWidthsCache.access();
          var buffer = new Uint8Array(this.getUnencodedContentsSize());
          var offset2 = 0;
          for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {
            var _a = entryTuples[entryIdx], first = _a[0], second = _a[1], third = _a[2];
            var firstBytes = utils_1.reverseArray(utils_1.bytesFor(first));
            var secondBytes = utils_1.reverseArray(utils_1.bytesFor(second));
            var thirdBytes = utils_1.reverseArray(utils_1.bytesFor(third));
            for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {
              buffer[offset2++] = firstBytes[idx] || 0;
            }
            for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {
              buffer[offset2++] = secondBytes[idx] || 0;
            }
            for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {
              buffer[offset2++] = thirdBytes[idx] || 0;
            }
          }
          return buffer;
        };
        PDFCrossRefStream2.prototype.getUnencodedContentsSize = function() {
          var byteWidths = this.maxByteWidthsCache.access();
          var entryWidth = utils_1.sum(byteWidths);
          return entryWidth * this.entries.length;
        };
        PDFCrossRefStream2.prototype.updateDict = function() {
          _super.prototype.updateDict.call(this);
          var byteWidths = this.maxByteWidthsCache.access();
          var index2 = this.indexCache.access();
          var context = this.dict.context;
          this.dict.set(PDFName_1.default.of("W"), context.obj(byteWidths));
          this.dict.set(PDFName_1.default.of("Index"), context.obj(index2));
        };
        PDFCrossRefStream2.create = function(dict, encode) {
          if (encode === void 0) {
            encode = true;
          }
          var stream = new PDFCrossRefStream2(dict, [], encode);
          stream.addDeletedEntry(PDFRef_1.default.of(0, 65535), 0);
          return stream;
        };
        PDFCrossRefStream2.of = function(dict, entries, encode) {
          if (encode === void 0) {
            encode = true;
          }
          return new PDFCrossRefStream2(dict, entries, encode);
        };
        return PDFCrossRefStream2;
      }(PDFFlateStream_1.default)
    );
    exports.default = PDFCrossRefStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/writers/PDFStreamWriter.js
var require_PDFStreamWriter = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/writers/PDFStreamWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFHeader_1 = tslib_1.__importDefault(require_PDFHeader());
    var PDFTrailer_1 = tslib_1.__importDefault(require_PDFTrailer());
    var PDFInvalidObject_1 = tslib_1.__importDefault(require_PDFInvalidObject());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var PDFCrossRefStream_1 = tslib_1.__importDefault(require_PDFCrossRefStream());
    var PDFObjectStream_1 = tslib_1.__importDefault(require_PDFObjectStream());
    var PDFWriter_1 = tslib_1.__importDefault(require_PDFWriter());
    var utils_1 = require_utils2();
    var PDFStreamWriter = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFStreamWriter2, _super);
        function PDFStreamWriter2(context, objectsPerTick, encodeStreams, objectsPerStream) {
          var _this = _super.call(this, context, objectsPerTick) || this;
          _this.encodeStreams = encodeStreams;
          _this.objectsPerStream = objectsPerStream;
          return _this;
        }
        PDFStreamWriter2.prototype.computeBufferSize = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var objectNumber, header, size, xrefStream, uncompressedObjects, compressedObjects, objectStreamRefs, indirectObjects, idx, len, indirectObject, ref, object2, shouldNotCompress, chunk, objectStreamRef, idx, len, chunk, ref, objectStream, xrefStreamRef, xrefOffset, trailer;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  objectNumber = this.context.largestObjectNumber + 1;
                  header = PDFHeader_1.default.forVersion(1, 7);
                  size = header.sizeInBytes() + 2;
                  xrefStream = PDFCrossRefStream_1.default.create(this.createTrailerDict(), this.encodeStreams);
                  uncompressedObjects = [];
                  compressedObjects = [];
                  objectStreamRefs = [];
                  indirectObjects = this.context.enumerateIndirectObjects();
                  idx = 0, len = indirectObjects.length;
                  _a.label = 1;
                case 1:
                  if (!(idx < len))
                    return [3, 6];
                  indirectObject = indirectObjects[idx];
                  ref = indirectObject[0], object2 = indirectObject[1];
                  shouldNotCompress = ref === this.context.trailerInfo.Encrypt || object2 instanceof PDFStream_1.default || object2 instanceof PDFInvalidObject_1.default || ref.generationNumber !== 0;
                  if (!shouldNotCompress)
                    return [3, 4];
                  uncompressedObjects.push(indirectObject);
                  xrefStream.addUncompressedEntry(ref, size);
                  size += this.computeIndirectObjectSize(indirectObject);
                  if (!this.shouldWaitForTick(1))
                    return [3, 3];
                  return [4, utils_1.waitForTick()];
                case 2:
                  _a.sent();
                  _a.label = 3;
                case 3:
                  return [3, 5];
                case 4:
                  chunk = utils_1.last(compressedObjects);
                  objectStreamRef = utils_1.last(objectStreamRefs);
                  if (!chunk || chunk.length % this.objectsPerStream === 0) {
                    chunk = [];
                    compressedObjects.push(chunk);
                    objectStreamRef = PDFRef_1.default.of(objectNumber++);
                    objectStreamRefs.push(objectStreamRef);
                  }
                  xrefStream.addCompressedEntry(ref, objectStreamRef, chunk.length);
                  chunk.push(indirectObject);
                  _a.label = 5;
                case 5:
                  idx++;
                  return [3, 1];
                case 6:
                  idx = 0, len = compressedObjects.length;
                  _a.label = 7;
                case 7:
                  if (!(idx < len))
                    return [3, 10];
                  chunk = compressedObjects[idx];
                  ref = objectStreamRefs[idx];
                  objectStream = PDFObjectStream_1.default.withContextAndObjects(this.context, chunk, this.encodeStreams);
                  xrefStream.addUncompressedEntry(ref, size);
                  size += this.computeIndirectObjectSize([ref, objectStream]);
                  uncompressedObjects.push([ref, objectStream]);
                  if (!this.shouldWaitForTick(chunk.length))
                    return [3, 9];
                  return [4, utils_1.waitForTick()];
                case 8:
                  _a.sent();
                  _a.label = 9;
                case 9:
                  idx++;
                  return [3, 7];
                case 10:
                  xrefStreamRef = PDFRef_1.default.of(objectNumber++);
                  xrefStream.dict.set(PDFName_1.default.of("Size"), PDFNumber_1.default.of(objectNumber));
                  xrefStream.addUncompressedEntry(xrefStreamRef, size);
                  xrefOffset = size;
                  size += this.computeIndirectObjectSize([xrefStreamRef, xrefStream]);
                  uncompressedObjects.push([xrefStreamRef, xrefStream]);
                  trailer = PDFTrailer_1.default.forLastCrossRefSectionOffset(xrefOffset);
                  size += trailer.sizeInBytes();
                  return [2, { size, header, indirectObjects: uncompressedObjects, trailer }];
              }
            });
          });
        };
        PDFStreamWriter2.forContext = function(context, objectsPerTick, encodeStreams, objectsPerStream) {
          if (encodeStreams === void 0) {
            encodeStreams = true;
          }
          if (objectsPerStream === void 0) {
            objectsPerStream = 50;
          }
          return new PDFStreamWriter2(context, objectsPerTick, encodeStreams, objectsPerStream);
        };
        return PDFStreamWriter2;
      }(PDFWriter_1.default)
    );
    exports.default = PDFStreamWriter;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFHexString.js
var require_PDFHexString = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFHexString.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var errors_1 = require_errors2();
    var PDFHexString = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFHexString2, _super);
        function PDFHexString2(value) {
          var _this = _super.call(this) || this;
          _this.value = value;
          return _this;
        }
        PDFHexString2.prototype.asBytes = function() {
          var hex = this.value + (this.value.length % 2 === 1 ? "0" : "");
          var hexLength = hex.length;
          var bytes = new Uint8Array(hex.length / 2);
          var hexOffset = 0;
          var bytesOffset = 0;
          while (hexOffset < hexLength) {
            var byte = parseInt(hex.substring(hexOffset, hexOffset + 2), 16);
            bytes[bytesOffset] = byte;
            hexOffset += 2;
            bytesOffset += 1;
          }
          return bytes;
        };
        PDFHexString2.prototype.decodeText = function() {
          var bytes = this.asBytes();
          if (utils_1.hasUtf16BOM(bytes))
            return utils_1.utf16Decode(bytes);
          return utils_1.pdfDocEncodingDecode(bytes);
        };
        PDFHexString2.prototype.decodeDate = function() {
          var text = this.decodeText();
          var date = utils_1.parseDate(text);
          if (!date)
            throw new errors_1.InvalidPDFDateStringError(text);
          return date;
        };
        PDFHexString2.prototype.asString = function() {
          return this.value;
        };
        PDFHexString2.prototype.clone = function() {
          return PDFHexString2.of(this.value);
        };
        PDFHexString2.prototype.toString = function() {
          return "<" + this.value + ">";
        };
        PDFHexString2.prototype.sizeInBytes = function() {
          return this.value.length + 2;
        };
        PDFHexString2.prototype.copyBytesInto = function(buffer, offset2) {
          buffer[offset2++] = CharCodes_1.default.LessThan;
          offset2 += utils_1.copyStringIntoBuffer(this.value, buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.GreaterThan;
          return this.value.length + 2;
        };
        PDFHexString2.of = function(value) {
          return new PDFHexString2(value);
        };
        PDFHexString2.fromText = function(value) {
          var encoded = utils_1.utf16Encode(value);
          var hex = "";
          for (var idx = 0, len = encoded.length; idx < len; idx++) {
            hex += utils_1.toHexStringOfMinLength(encoded[idx], 4);
          }
          return new PDFHexString2(hex);
        };
        return PDFHexString2;
      }(PDFObject_1.default)
    );
    exports.default = PDFHexString;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/embedders/StandardFontEmbedder.js
var require_StandardFontEmbedder = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/embedders/StandardFontEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var standard_fonts_1 = require_lib();
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var utils_1 = require_utils2();
    var StandardFontEmbedder = (
      /** @class */
      function() {
        function StandardFontEmbedder2(fontName, customName) {
          this.encoding = fontName === standard_fonts_1.FontNames.ZapfDingbats ? standard_fonts_1.Encodings.ZapfDingbats : fontName === standard_fonts_1.FontNames.Symbol ? standard_fonts_1.Encodings.Symbol : standard_fonts_1.Encodings.WinAnsi;
          this.font = standard_fonts_1.Font.load(fontName);
          this.fontName = this.font.FontName;
          this.customName = customName;
        }
        StandardFontEmbedder2.prototype.encodeText = function(text) {
          var glyphs = this.encodeTextAsGlyphs(text);
          var hexCodes = new Array(glyphs.length);
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            hexCodes[idx] = utils_1.toHexString(glyphs[idx].code);
          }
          return PDFHexString_1.default.of(hexCodes.join(""));
        };
        StandardFontEmbedder2.prototype.widthOfTextAtSize = function(text, size) {
          var glyphs = this.encodeTextAsGlyphs(text);
          var totalWidth = 0;
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            var left = glyphs[idx].name;
            var right = (glyphs[idx + 1] || {}).name;
            var kernAmount = this.font.getXAxisKerningForPair(left, right) || 0;
            totalWidth += this.widthOfGlyph(left) + kernAmount;
          }
          var scale2 = size / 1e3;
          return totalWidth * scale2;
        };
        StandardFontEmbedder2.prototype.heightOfFontAtSize = function(size, options) {
          if (options === void 0) {
            options = {};
          }
          var _a = options.descender, descender = _a === void 0 ? true : _a;
          var _b = this.font, Ascender = _b.Ascender, Descender = _b.Descender, FontBBox = _b.FontBBox;
          var yTop = Ascender || FontBBox[3];
          var yBottom = Descender || FontBBox[1];
          var height = yTop - yBottom;
          if (!descender)
            height += Descender || 0;
          return height / 1e3 * size;
        };
        StandardFontEmbedder2.prototype.sizeOfFontAtHeight = function(height) {
          var _a = this.font, Ascender = _a.Ascender, Descender = _a.Descender, FontBBox = _a.FontBBox;
          var yTop = Ascender || FontBBox[3];
          var yBottom = Descender || FontBBox[1];
          return 1e3 * height / (yTop - yBottom);
        };
        StandardFontEmbedder2.prototype.embedIntoContext = function(context, ref) {
          var fontDict = context.obj({
            Type: "Font",
            Subtype: "Type1",
            BaseFont: this.customName || this.fontName,
            Encoding: this.encoding === standard_fonts_1.Encodings.WinAnsi ? "WinAnsiEncoding" : void 0
          });
          if (ref) {
            context.assign(ref, fontDict);
            return ref;
          } else {
            return context.register(fontDict);
          }
        };
        StandardFontEmbedder2.prototype.widthOfGlyph = function(glyphName) {
          return this.font.getWidthOfGlyph(glyphName) || 250;
        };
        StandardFontEmbedder2.prototype.encodeTextAsGlyphs = function(text) {
          var codePoints = Array.from(text);
          var glyphs = new Array(codePoints.length);
          for (var idx = 0, len = codePoints.length; idx < len; idx++) {
            var codePoint = utils_1.toCodePoint(codePoints[idx]);
            glyphs[idx] = this.encoding.encodeUnicodeCodePoint(codePoint);
          }
          return glyphs;
        };
        StandardFontEmbedder2.for = function(fontName, customName) {
          return new StandardFontEmbedder2(fontName, customName);
        };
        return StandardFontEmbedder2;
      }()
    );
    exports.default = StandardFontEmbedder;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/embedders/CMap.js
var require_CMap = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/embedders/CMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCmap = void 0;
    var utils_1 = require_utils2();
    var unicode_1 = require_unicode();
    exports.createCmap = function(glyphs, glyphId) {
      var bfChars = new Array(glyphs.length);
      for (var idx = 0, len = glyphs.length; idx < len; idx++) {
        var glyph = glyphs[idx];
        var id = cmapHexFormat(cmapHexString(glyphId(glyph)));
        var unicode = cmapHexFormat.apply(void 0, glyph.codePoints.map(cmapCodePointFormat));
        bfChars[idx] = [id, unicode];
      }
      return fillCmapTemplate(bfChars);
    };
    var fillCmapTemplate = function(bfChars) {
      return "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n" + bfChars.length + " beginbfchar\n" + bfChars.map(function(_a) {
        var glyphId = _a[0], codePoint = _a[1];
        return glyphId + " " + codePoint;
      }).join("\n") + "\nendbfchar\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
    };
    var cmapHexFormat = function() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return "<" + values.join("") + ">";
    };
    var cmapHexString = function(value) {
      return utils_1.toHexStringOfMinLength(value, 4);
    };
    var cmapCodePointFormat = function(codePoint) {
      if (unicode_1.isWithinBMP(codePoint))
        return cmapHexString(codePoint);
      if (unicode_1.hasSurrogates(codePoint)) {
        var hs = unicode_1.highSurrogate(codePoint);
        var ls = unicode_1.lowSurrogate(codePoint);
        return "" + cmapHexString(hs) + cmapHexString(ls);
      }
      var hex = utils_1.toHexString(codePoint);
      var msg = "0x" + hex + " is not a valid UTF-8 or UTF-16 codepoint.";
      throw new Error(msg);
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/core/embedders/FontFlags.js
var require_FontFlags = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/embedders/FontFlags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveFontFlags = void 0;
    var makeFontFlags = function(options) {
      var flags = 0;
      var flipBit = function(bit) {
        flags |= 1 << bit - 1;
      };
      if (options.fixedPitch)
        flipBit(1);
      if (options.serif)
        flipBit(2);
      if (options.symbolic)
        flipBit(3);
      if (options.script)
        flipBit(4);
      if (options.nonsymbolic)
        flipBit(6);
      if (options.italic)
        flipBit(7);
      if (options.allCap)
        flipBit(17);
      if (options.smallCap)
        flipBit(18);
      if (options.forceBold)
        flipBit(19);
      return flags;
    };
    exports.deriveFontFlags = function(font) {
      var familyClass = font["OS/2"] ? font["OS/2"].sFamilyClass : 0;
      var flags = makeFontFlags({
        fixedPitch: font.post.isFixedPitch,
        serif: 1 <= familyClass && familyClass <= 7,
        symbolic: true,
        script: familyClass === 10,
        italic: font.head.macStyle.italic
      });
      return flags;
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/core/objects/PDFString.js
var require_PDFString = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/objects/PDFString.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFObject_1 = tslib_1.__importDefault(require_PDFObject());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var errors_1 = require_errors2();
    var PDFString = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFString2, _super);
        function PDFString2(value) {
          var _this = _super.call(this) || this;
          _this.value = value;
          return _this;
        }
        PDFString2.prototype.asBytes = function() {
          var bytes = [];
          var octal = "";
          var escaped = false;
          var pushByte = function(byte2) {
            if (byte2 !== void 0)
              bytes.push(byte2);
            escaped = false;
          };
          for (var idx = 0, len = this.value.length; idx < len; idx++) {
            var char = this.value[idx];
            var byte = utils_1.toCharCode(char);
            var nextChar = this.value[idx + 1];
            if (!escaped) {
              if (byte === CharCodes_1.default.BackSlash)
                escaped = true;
              else
                pushByte(byte);
            } else {
              if (byte === CharCodes_1.default.Newline)
                pushByte();
              else if (byte === CharCodes_1.default.CarriageReturn)
                pushByte();
              else if (byte === CharCodes_1.default.n)
                pushByte(CharCodes_1.default.Newline);
              else if (byte === CharCodes_1.default.r)
                pushByte(CharCodes_1.default.CarriageReturn);
              else if (byte === CharCodes_1.default.t)
                pushByte(CharCodes_1.default.Tab);
              else if (byte === CharCodes_1.default.b)
                pushByte(CharCodes_1.default.Backspace);
              else if (byte === CharCodes_1.default.f)
                pushByte(CharCodes_1.default.FormFeed);
              else if (byte === CharCodes_1.default.LeftParen)
                pushByte(CharCodes_1.default.LeftParen);
              else if (byte === CharCodes_1.default.RightParen)
                pushByte(CharCodes_1.default.RightParen);
              else if (byte === CharCodes_1.default.Backspace)
                pushByte(CharCodes_1.default.BackSlash);
              else if (byte >= CharCodes_1.default.Zero && byte <= CharCodes_1.default.Seven) {
                octal += char;
                if (octal.length === 3 || !(nextChar >= "0" && nextChar <= "7")) {
                  pushByte(parseInt(octal, 8));
                  octal = "";
                }
              } else {
                pushByte(byte);
              }
            }
          }
          return new Uint8Array(bytes);
        };
        PDFString2.prototype.decodeText = function() {
          var bytes = this.asBytes();
          if (utils_1.hasUtf16BOM(bytes))
            return utils_1.utf16Decode(bytes);
          return utils_1.pdfDocEncodingDecode(bytes);
        };
        PDFString2.prototype.decodeDate = function() {
          var text = this.decodeText();
          var date = utils_1.parseDate(text);
          if (!date)
            throw new errors_1.InvalidPDFDateStringError(text);
          return date;
        };
        PDFString2.prototype.asString = function() {
          return this.value;
        };
        PDFString2.prototype.clone = function() {
          return PDFString2.of(this.value);
        };
        PDFString2.prototype.toString = function() {
          return "(" + this.value + ")";
        };
        PDFString2.prototype.sizeInBytes = function() {
          return this.value.length + 2;
        };
        PDFString2.prototype.copyBytesInto = function(buffer, offset2) {
          buffer[offset2++] = CharCodes_1.default.LeftParen;
          offset2 += utils_1.copyStringIntoBuffer(this.value, buffer, offset2);
          buffer[offset2++] = CharCodes_1.default.RightParen;
          return this.value.length + 2;
        };
        PDFString2.of = function(value) {
          return new PDFString2(value);
        };
        PDFString2.fromDate = function(date) {
          var year = utils_1.padStart(String(date.getUTCFullYear()), 4, "0");
          var month = utils_1.padStart(String(date.getUTCMonth() + 1), 2, "0");
          var day = utils_1.padStart(String(date.getUTCDate()), 2, "0");
          var hours = utils_1.padStart(String(date.getUTCHours()), 2, "0");
          var mins = utils_1.padStart(String(date.getUTCMinutes()), 2, "0");
          var secs = utils_1.padStart(String(date.getUTCSeconds()), 2, "0");
          return new PDFString2("D:" + year + month + day + hours + mins + secs + "Z");
        };
        return PDFString2;
      }(PDFObject_1.default)
    );
    exports.default = PDFString;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/embedders/CustomFontEmbedder.js
var require_CustomFontEmbedder = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/embedders/CustomFontEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CMap_1 = require_CMap();
    var FontFlags_1 = require_FontFlags();
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var utils_1 = require_utils2();
    var CustomFontEmbedder = (
      /** @class */
      function() {
        function CustomFontEmbedder2(font, fontData, customName, fontFeatures) {
          var _this = this;
          this.allGlyphsInFontSortedById = function() {
            var glyphs = new Array(_this.font.characterSet.length);
            for (var idx = 0, len = glyphs.length; idx < len; idx++) {
              var codePoint = _this.font.characterSet[idx];
              glyphs[idx] = _this.font.glyphForCodePoint(codePoint);
            }
            return utils_1.sortedUniq(glyphs.sort(utils_1.byAscendingId), function(g) {
              return g.id;
            });
          };
          this.font = font;
          this.scale = 1e3 / this.font.unitsPerEm;
          this.fontData = fontData;
          this.fontName = this.font.postscriptName || "Font";
          this.customName = customName;
          this.fontFeatures = fontFeatures;
          this.baseFontName = "";
          this.glyphCache = utils_1.Cache.populatedBy(this.allGlyphsInFontSortedById);
        }
        CustomFontEmbedder2.for = function(fontkit, fontData, customName, fontFeatures) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var font;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, fontkit.create(fontData)];
                case 1:
                  font = _a.sent();
                  return [2, new CustomFontEmbedder2(font, fontData, customName, fontFeatures)];
              }
            });
          });
        };
        CustomFontEmbedder2.prototype.encodeText = function(text) {
          var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
          var hexCodes = new Array(glyphs.length);
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            hexCodes[idx] = utils_1.toHexStringOfMinLength(glyphs[idx].id, 4);
          }
          return PDFHexString_1.default.of(hexCodes.join(""));
        };
        CustomFontEmbedder2.prototype.widthOfTextAtSize = function(text, size) {
          var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
          var totalWidth = 0;
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            totalWidth += glyphs[idx].advanceWidth * this.scale;
          }
          var scale2 = size / 1e3;
          return totalWidth * scale2;
        };
        CustomFontEmbedder2.prototype.heightOfFontAtSize = function(size, options) {
          if (options === void 0) {
            options = {};
          }
          var _a = options.descender, descender = _a === void 0 ? true : _a;
          var _b = this.font, ascent = _b.ascent, descent = _b.descent, bbox = _b.bbox;
          var yTop = (ascent || bbox.maxY) * this.scale;
          var yBottom = (descent || bbox.minY) * this.scale;
          var height = yTop - yBottom;
          if (!descender)
            height -= Math.abs(descent) || 0;
          return height / 1e3 * size;
        };
        CustomFontEmbedder2.prototype.sizeOfFontAtHeight = function(height) {
          var _a = this.font, ascent = _a.ascent, descent = _a.descent, bbox = _a.bbox;
          var yTop = (ascent || bbox.maxY) * this.scale;
          var yBottom = (descent || bbox.minY) * this.scale;
          return 1e3 * height / (yTop - yBottom);
        };
        CustomFontEmbedder2.prototype.embedIntoContext = function(context, ref) {
          this.baseFontName = this.customName || context.addRandomSuffix(this.fontName);
          return this.embedFontDict(context, ref);
        };
        CustomFontEmbedder2.prototype.embedFontDict = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var cidFontDictRef, unicodeCMapRef, fontDict;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.embedCIDFontDict(context)];
                case 1:
                  cidFontDictRef = _a.sent();
                  unicodeCMapRef = this.embedUnicodeCmap(context);
                  fontDict = context.obj({
                    Type: "Font",
                    Subtype: "Type0",
                    BaseFont: this.baseFontName,
                    Encoding: "Identity-H",
                    DescendantFonts: [cidFontDictRef],
                    ToUnicode: unicodeCMapRef
                  });
                  if (ref) {
                    context.assign(ref, fontDict);
                    return [2, ref];
                  } else {
                    return [2, context.register(fontDict)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        CustomFontEmbedder2.prototype.isCFF = function() {
          return this.font.cff;
        };
        CustomFontEmbedder2.prototype.embedCIDFontDict = function(context) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var fontDescriptorRef, cidFontDict;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.embedFontDescriptor(context)];
                case 1:
                  fontDescriptorRef = _a.sent();
                  cidFontDict = context.obj({
                    Type: "Font",
                    Subtype: this.isCFF() ? "CIDFontType0" : "CIDFontType2",
                    CIDToGIDMap: "Identity",
                    BaseFont: this.baseFontName,
                    CIDSystemInfo: {
                      Registry: PDFString_1.default.of("Adobe"),
                      Ordering: PDFString_1.default.of("Identity"),
                      Supplement: 0
                    },
                    FontDescriptor: fontDescriptorRef,
                    W: this.computeWidths()
                  });
                  return [2, context.register(cidFontDict)];
              }
            });
          });
        };
        CustomFontEmbedder2.prototype.embedFontDescriptor = function(context) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var fontStreamRef, scale2, _a, italicAngle, ascent, descent, capHeight, xHeight, _b, minX, minY, maxX, maxY, fontDescriptor;
            var _c;
            return tslib_1.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  return [4, this.embedFontStream(context)];
                case 1:
                  fontStreamRef = _d.sent();
                  scale2 = this.scale;
                  _a = this.font, italicAngle = _a.italicAngle, ascent = _a.ascent, descent = _a.descent, capHeight = _a.capHeight, xHeight = _a.xHeight;
                  _b = this.font.bbox, minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
                  fontDescriptor = context.obj((_c = {
                    Type: "FontDescriptor",
                    FontName: this.baseFontName,
                    Flags: FontFlags_1.deriveFontFlags(this.font),
                    FontBBox: [minX * scale2, minY * scale2, maxX * scale2, maxY * scale2],
                    ItalicAngle: italicAngle,
                    Ascent: ascent * scale2,
                    Descent: descent * scale2,
                    CapHeight: (capHeight || ascent) * scale2,
                    XHeight: (xHeight || 0) * scale2,
                    // Not sure how to compute/find this, nor is anybody else really:
                    // https://stackoverflow.com/questions/35485179/stemv-value-of-the-truetype-font
                    StemV: 0
                  }, _c[this.isCFF() ? "FontFile3" : "FontFile2"] = fontStreamRef, _c));
                  return [2, context.register(fontDescriptor)];
              }
            });
          });
        };
        CustomFontEmbedder2.prototype.serializeFont = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              return [2, this.fontData];
            });
          });
        };
        CustomFontEmbedder2.prototype.embedFontStream = function(context) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var fontStream, _a, _b;
            return tslib_1.__generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  _b = (_a = context).flateStream;
                  return [4, this.serializeFont()];
                case 1:
                  fontStream = _b.apply(_a, [_c.sent(), {
                    Subtype: this.isCFF() ? "CIDFontType0C" : void 0
                  }]);
                  return [2, context.register(fontStream)];
              }
            });
          });
        };
        CustomFontEmbedder2.prototype.embedUnicodeCmap = function(context) {
          var cmap = CMap_1.createCmap(this.glyphCache.access(), this.glyphId.bind(this));
          var cmapStream = context.flateStream(cmap);
          return context.register(cmapStream);
        };
        CustomFontEmbedder2.prototype.glyphId = function(glyph) {
          return glyph ? glyph.id : -1;
        };
        CustomFontEmbedder2.prototype.computeWidths = function() {
          var glyphs = this.glyphCache.access();
          var widths = [];
          var currSection = [];
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            var currGlyph = glyphs[idx];
            var prevGlyph = glyphs[idx - 1];
            var currGlyphId = this.glyphId(currGlyph);
            var prevGlyphId = this.glyphId(prevGlyph);
            if (idx === 0) {
              widths.push(currGlyphId);
            } else if (currGlyphId - prevGlyphId !== 1) {
              widths.push(currSection);
              widths.push(currGlyphId);
              currSection = [];
            }
            currSection.push(currGlyph.advanceWidth * this.scale);
          }
          widths.push(currSection);
          return widths;
        };
        return CustomFontEmbedder2;
      }()
    );
    exports.default = CustomFontEmbedder;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/embedders/CustomFontSubsetEmbedder.js
var require_CustomFontSubsetEmbedder = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/embedders/CustomFontSubsetEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CustomFontEmbedder_1 = tslib_1.__importDefault(require_CustomFontEmbedder());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var utils_1 = require_utils2();
    var CustomFontSubsetEmbedder = (
      /** @class */
      function(_super) {
        tslib_1.__extends(CustomFontSubsetEmbedder2, _super);
        function CustomFontSubsetEmbedder2(font, fontData, customFontName, fontFeatures) {
          var _this = _super.call(this, font, fontData, customFontName, fontFeatures) || this;
          _this.subset = _this.font.createSubset();
          _this.glyphs = [];
          _this.glyphCache = utils_1.Cache.populatedBy(function() {
            return _this.glyphs;
          });
          _this.glyphIdMap = /* @__PURE__ */ new Map();
          return _this;
        }
        CustomFontSubsetEmbedder2.for = function(fontkit, fontData, customFontName, fontFeatures) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var font;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, fontkit.create(fontData)];
                case 1:
                  font = _a.sent();
                  return [2, new CustomFontSubsetEmbedder2(font, fontData, customFontName, fontFeatures)];
              }
            });
          });
        };
        CustomFontSubsetEmbedder2.prototype.encodeText = function(text) {
          var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
          var hexCodes = new Array(glyphs.length);
          for (var idx = 0, len = glyphs.length; idx < len; idx++) {
            var glyph = glyphs[idx];
            var subsetGlyphId = this.subset.includeGlyph(glyph);
            this.glyphs[subsetGlyphId - 1] = glyph;
            this.glyphIdMap.set(glyph.id, subsetGlyphId);
            hexCodes[idx] = utils_1.toHexStringOfMinLength(subsetGlyphId, 4);
          }
          this.glyphCache.invalidate();
          return PDFHexString_1.default.of(hexCodes.join(""));
        };
        CustomFontSubsetEmbedder2.prototype.isCFF = function() {
          return this.subset.cff;
        };
        CustomFontSubsetEmbedder2.prototype.glyphId = function(glyph) {
          return glyph ? this.glyphIdMap.get(glyph.id) : -1;
        };
        CustomFontSubsetEmbedder2.prototype.serializeFont = function() {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var parts = [];
            _this.subset.encodeStream().on("data", function(bytes) {
              return parts.push(bytes);
            }).on("end", function() {
              return resolve(utils_1.mergeUint8Arrays(parts));
            }).on("error", function(err) {
              return reject(err);
            });
          });
        };
        return CustomFontSubsetEmbedder2;
      }(CustomFontEmbedder_1.default)
    );
    exports.default = CustomFontSubsetEmbedder;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/embedders/FileEmbedder.js
var require_FileEmbedder = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/embedders/FileEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AFRelationship = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var AFRelationship;
    (function(AFRelationship2) {
      AFRelationship2["Source"] = "Source";
      AFRelationship2["Data"] = "Data";
      AFRelationship2["Alternative"] = "Alternative";
      AFRelationship2["Supplement"] = "Supplement";
      AFRelationship2["EncryptedPayload"] = "EncryptedPayload";
      AFRelationship2["FormData"] = "EncryptedPayload";
      AFRelationship2["Schema"] = "Schema";
      AFRelationship2["Unspecified"] = "Unspecified";
    })(AFRelationship = exports.AFRelationship || (exports.AFRelationship = {}));
    var FileEmbedder = (
      /** @class */
      function() {
        function FileEmbedder2(fileData, fileName, options) {
          if (options === void 0) {
            options = {};
          }
          this.fileData = fileData;
          this.fileName = fileName;
          this.options = options;
        }
        FileEmbedder2.for = function(bytes, fileName, options) {
          if (options === void 0) {
            options = {};
          }
          return new FileEmbedder2(bytes, fileName, options);
        };
        FileEmbedder2.prototype.embedIntoContext = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, mimeType, description, creationDate, modificationDate, afRelationship, embeddedFileStream, embeddedFileStreamRef, fileSpecDict;
            return tslib_1.__generator(this, function(_b) {
              _a = this.options, mimeType = _a.mimeType, description = _a.description, creationDate = _a.creationDate, modificationDate = _a.modificationDate, afRelationship = _a.afRelationship;
              embeddedFileStream = context.flateStream(this.fileData, {
                Type: "EmbeddedFile",
                Subtype: mimeType !== null && mimeType !== void 0 ? mimeType : void 0,
                Params: {
                  Size: this.fileData.length,
                  CreationDate: creationDate ? PDFString_1.default.fromDate(creationDate) : void 0,
                  ModDate: modificationDate ? PDFString_1.default.fromDate(modificationDate) : void 0
                }
              });
              embeddedFileStreamRef = context.register(embeddedFileStream);
              fileSpecDict = context.obj({
                Type: "Filespec",
                F: PDFString_1.default.of(this.fileName),
                UF: PDFHexString_1.default.fromText(this.fileName),
                EF: { F: embeddedFileStreamRef },
                Desc: description ? PDFHexString_1.default.fromText(description) : void 0,
                AFRelationship: afRelationship !== null && afRelationship !== void 0 ? afRelationship : void 0
              });
              if (ref) {
                context.assign(ref, fileSpecDict);
                return [2, ref];
              } else {
                return [2, context.register(fileSpecDict)];
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        return FileEmbedder2;
      }()
    );
    exports.default = FileEmbedder;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/embedders/JpegEmbedder.js
var require_JpegEmbedder = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/embedders/JpegEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var MARKERS = [
      65472,
      65473,
      65474,
      65475,
      65477,
      65478,
      65479,
      65480,
      65481,
      65482,
      65483,
      65484,
      65485,
      65486,
      65487
    ];
    var ColorSpace;
    (function(ColorSpace2) {
      ColorSpace2["DeviceGray"] = "DeviceGray";
      ColorSpace2["DeviceRGB"] = "DeviceRGB";
      ColorSpace2["DeviceCMYK"] = "DeviceCMYK";
    })(ColorSpace || (ColorSpace = {}));
    var ChannelToColorSpace = {
      1: ColorSpace.DeviceGray,
      3: ColorSpace.DeviceRGB,
      4: ColorSpace.DeviceCMYK
    };
    var JpegEmbedder = (
      /** @class */
      function() {
        function JpegEmbedder2(imageData, bitsPerComponent, width, height, colorSpace) {
          this.imageData = imageData;
          this.bitsPerComponent = bitsPerComponent;
          this.width = width;
          this.height = height;
          this.colorSpace = colorSpace;
        }
        JpegEmbedder2.for = function(imageData) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var dataView, soi, pos, marker, bitsPerComponent, height, width, channelByte, channelName, colorSpace;
            return tslib_1.__generator(this, function(_a) {
              dataView = new DataView(imageData.buffer);
              soi = dataView.getUint16(0);
              if (soi !== 65496)
                throw new Error("SOI not found in JPEG");
              pos = 2;
              while (pos < dataView.byteLength) {
                marker = dataView.getUint16(pos);
                pos += 2;
                if (MARKERS.includes(marker))
                  break;
                pos += dataView.getUint16(pos);
              }
              if (!MARKERS.includes(marker))
                throw new Error("Invalid JPEG");
              pos += 2;
              bitsPerComponent = dataView.getUint8(pos++);
              height = dataView.getUint16(pos);
              pos += 2;
              width = dataView.getUint16(pos);
              pos += 2;
              channelByte = dataView.getUint8(pos++);
              channelName = ChannelToColorSpace[channelByte];
              if (!channelName)
                throw new Error("Unknown JPEG channel.");
              colorSpace = channelName;
              return [2, new JpegEmbedder2(imageData, bitsPerComponent, width, height, colorSpace)];
            });
          });
        };
        JpegEmbedder2.prototype.embedIntoContext = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var xObject;
            return tslib_1.__generator(this, function(_a) {
              xObject = context.stream(this.imageData, {
                Type: "XObject",
                Subtype: "Image",
                BitsPerComponent: this.bitsPerComponent,
                Width: this.width,
                Height: this.height,
                ColorSpace: this.colorSpace,
                Filter: "DCTDecode",
                // CMYK JPEG streams in PDF are typically stored complemented,
                // with 1 as 'off' and 0 as 'on' (PDF 32000-1:2008, 8.6.4.4).
                //
                // Standalone CMYK JPEG (usually exported by Photoshop) are
                // stored inverse, with 0 as 'off' and 1 as 'on', like RGB.
                //
                // Applying a swap here as a hedge that most bytes passing
                // through this method will benefit from it.
                Decode: this.colorSpace === ColorSpace.DeviceCMYK ? [1, 0, 1, 0, 1, 0, 1, 0] : void 0
              });
              if (ref) {
                context.assign(ref, xObject);
                return [2, ref];
              } else {
                return [2, context.register(xObject)];
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        return JpegEmbedder2;
      }()
    );
    exports.default = JpegEmbedder;
  }
});

// ../../../node_modules/@pdf-lib/upng/cjs/UPNG.js
var require_UPNG = __commonJS({
  "../../../node_modules/@pdf-lib/upng/cjs/UPNG.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _pako = _interopRequireDefault(require_pako());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var UPNG = {};
    UPNG.toRGBA8 = function(out) {
      var w = out.width, h = out.height;
      if (out.tabs.acTL == null)
        return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];
      var frms = [];
      if (out.frames[0].data == null)
        out.frames[0].data = out.data;
      var len = w * h * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);
      for (var i = 0; i < out.frames.length; i++) {
        var frm = out.frames[i];
        var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
        var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);
        if (i != 0)
          for (var j = 0; j < len; j++)
            prev[j] = img[j];
        if (frm.blend == 0)
          UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
        else if (frm.blend == 1)
          UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);
        frms.push(img.buffer.slice(0));
        if (frm.dispose == 0) {
        } else if (frm.dispose == 1)
          UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);
        else if (frm.dispose == 2)
          for (var j = 0; j < len; j++)
            img[j] = prev[j];
      }
      return frms;
    };
    UPNG.toRGBA8.decodeImage = function(data, w, h, out) {
      var area = w * h, bpp = UPNG.decode._getBPP(out);
      var bpl = Math.ceil(w * bpp / 8);
      var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);
      var ctype = out.ctype, depth = out.depth;
      var rs = UPNG._bin.readUshort;
      var time = Date.now();
      if (ctype == 6) {
        var qarea = area << 2;
        if (depth == 8)
          for (var i = 0; i < qarea; i += 4) {
            bf[i] = data[i];
            bf[i + 1] = data[i + 1];
            bf[i + 2] = data[i + 2];
            bf[i + 3] = data[i + 3];
          }
        if (depth == 16)
          for (var i = 0; i < qarea; i++) {
            bf[i] = data[i << 1];
          }
      } else if (ctype == 2) {
        var ts = out.tabs["tRNS"];
        if (ts == null) {
          if (depth == 8)
            for (var i = 0; i < area; i++) {
              var ti = i * 3;
              bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
            }
          if (depth == 16)
            for (var i = 0; i < area; i++) {
              var ti = i * 6;
              bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
            }
        } else {
          var tr = ts[0], tg = ts[1], tb = ts[2];
          if (depth == 8)
            for (var i = 0; i < area; i++) {
              var qi = i << 2, ti = i * 3;
              bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
              if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb)
                bf[qi + 3] = 0;
            }
          if (depth == 16)
            for (var i = 0; i < area; i++) {
              var qi = i << 2, ti = i * 6;
              bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
              if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb)
                bf[qi + 3] = 0;
            }
        }
      } else if (ctype == 3) {
        var p = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
        if (depth == 1)
          for (var y = 0; y < h; y++) {
            var s0 = y * bpl, t0 = y * w;
            for (var i = 0; i < w; i++) {
              var qi = t0 + i << 2, j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1, cj = 3 * j;
              bf[qi] = p[cj];
              bf[qi + 1] = p[cj + 1];
              bf[qi + 2] = p[cj + 2];
              bf[qi + 3] = j < tl ? ap[j] : 255;
            }
          }
        if (depth == 2)
          for (var y = 0; y < h; y++) {
            var s0 = y * bpl, t0 = y * w;
            for (var i = 0; i < w; i++) {
              var qi = t0 + i << 2, j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3, cj = 3 * j;
              bf[qi] = p[cj];
              bf[qi + 1] = p[cj + 1];
              bf[qi + 2] = p[cj + 2];
              bf[qi + 3] = j < tl ? ap[j] : 255;
            }
          }
        if (depth == 4)
          for (var y = 0; y < h; y++) {
            var s0 = y * bpl, t0 = y * w;
            for (var i = 0; i < w; i++) {
              var qi = t0 + i << 2, j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15, cj = 3 * j;
              bf[qi] = p[cj];
              bf[qi + 1] = p[cj + 1];
              bf[qi + 2] = p[cj + 2];
              bf[qi + 3] = j < tl ? ap[j] : 255;
            }
          }
        if (depth == 8)
          for (var i = 0; i < area; i++) {
            var qi = i << 2, j = data[i], cj = 3 * j;
            bf[qi] = p[cj];
            bf[qi + 1] = p[cj + 1];
            bf[qi + 2] = p[cj + 2];
            bf[qi + 3] = j < tl ? ap[j] : 255;
          }
      } else if (ctype == 4) {
        if (depth == 8)
          for (var i = 0; i < area; i++) {
            var qi = i << 2, di = i << 1, gr = data[di];
            bf[qi] = gr;
            bf[qi + 1] = gr;
            bf[qi + 2] = gr;
            bf[qi + 3] = data[di + 1];
          }
        if (depth == 16)
          for (var i = 0; i < area; i++) {
            var qi = i << 2, di = i << 2, gr = data[di];
            bf[qi] = gr;
            bf[qi + 1] = gr;
            bf[qi + 2] = gr;
            bf[qi + 3] = data[di + 2];
          }
      } else if (ctype == 0) {
        var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
        for (var y = 0; y < h; y++) {
          var off = y * bpl, to = y * w;
          if (depth == 1)
            for (var x = 0; x < w; x++) {
              var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1), al = gr == tr * 255 ? 0 : 255;
              bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          else if (depth == 2)
            for (var x = 0; x < w; x++) {
              var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
              bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          else if (depth == 4)
            for (var x = 0; x < w; x++) {
              var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
              bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          else if (depth == 8)
            for (var x = 0; x < w; x++) {
              var gr = data[off + x], al = gr == tr ? 0 : 255;
              bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
            }
          else if (depth == 16)
            for (var x = 0; x < w; x++) {
              var gr = data[off + (x << 1)], al = rs(data, off + (x << i)) == tr ? 0 : 255;
              bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
            }
        }
      }
      return bf;
    };
    UPNG.decode = function(buff) {
      var data = new Uint8Array(buff), offset2 = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;
      var out = {
        tabs: {},
        frames: []
      };
      var dd = new Uint8Array(data.length), doff = 0;
      var fd, foff = 0;
      var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
      for (var i = 0; i < 8; i++)
        if (data[i] != mgck[i])
          throw "The input is not a PNG file!";
      while (offset2 < data.length) {
        var len = bin.readUint(data, offset2);
        offset2 += 4;
        var type = bin.readASCII(data, offset2, 4);
        offset2 += 4;
        if (type == "IHDR") {
          UPNG.decode._IHDR(data, offset2, out);
        } else if (type == "IDAT") {
          for (var i = 0; i < len; i++)
            dd[doff + i] = data[offset2 + i];
          doff += len;
        } else if (type == "acTL") {
          out.tabs[type] = {
            num_frames: rUi(data, offset2),
            num_plays: rUi(data, offset2 + 4)
          };
          fd = new Uint8Array(data.length);
        } else if (type == "fcTL") {
          if (foff != 0) {
            var fr = out.frames[out.frames.length - 1];
            fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
            foff = 0;
          }
          var rct = {
            x: rUi(data, offset2 + 12),
            y: rUi(data, offset2 + 16),
            width: rUi(data, offset2 + 4),
            height: rUi(data, offset2 + 8)
          };
          var del2 = rUs(data, offset2 + 22);
          del2 = rUs(data, offset2 + 20) / (del2 == 0 ? 100 : del2);
          var frm = {
            rect: rct,
            delay: Math.round(del2 * 1e3),
            dispose: data[offset2 + 24],
            blend: data[offset2 + 25]
          };
          out.frames.push(frm);
        } else if (type == "fdAT") {
          for (var i = 0; i < len - 4; i++)
            fd[foff + i] = data[offset2 + i + 4];
          foff += len - 4;
        } else if (type == "pHYs") {
          out.tabs[type] = [bin.readUint(data, offset2), bin.readUint(data, offset2 + 4), data[offset2 + 8]];
        } else if (type == "cHRM") {
          out.tabs[type] = [];
          for (var i = 0; i < 8; i++)
            out.tabs[type].push(bin.readUint(data, offset2 + i * 4));
        } else if (type == "tEXt") {
          if (out.tabs[type] == null)
            out.tabs[type] = {};
          var nz = bin.nextZero(data, offset2);
          var keyw = bin.readASCII(data, offset2, nz - offset2);
          var text = bin.readASCII(data, nz + 1, offset2 + len - nz - 1);
          out.tabs[type][keyw] = text;
        } else if (type == "iTXt") {
          if (out.tabs[type] == null)
            out.tabs[type] = {};
          var nz = 0, off = offset2;
          nz = bin.nextZero(data, off);
          var keyw = bin.readASCII(data, off, nz - off);
          off = nz + 1;
          var cflag = data[off], cmeth = data[off + 1];
          off += 2;
          nz = bin.nextZero(data, off);
          var ltag = bin.readASCII(data, off, nz - off);
          off = nz + 1;
          nz = bin.nextZero(data, off);
          var tkeyw = bin.readUTF8(data, off, nz - off);
          off = nz + 1;
          var text = bin.readUTF8(data, off, len - (off - offset2));
          out.tabs[type][keyw] = text;
        } else if (type == "PLTE") {
          out.tabs[type] = bin.readBytes(data, offset2, len);
        } else if (type == "hIST") {
          var pl = out.tabs["PLTE"].length / 3;
          out.tabs[type] = [];
          for (var i = 0; i < pl; i++)
            out.tabs[type].push(rUs(data, offset2 + i * 2));
        } else if (type == "tRNS") {
          if (out.ctype == 3)
            out.tabs[type] = bin.readBytes(data, offset2, len);
          else if (out.ctype == 0)
            out.tabs[type] = rUs(data, offset2);
          else if (out.ctype == 2)
            out.tabs[type] = [rUs(data, offset2), rUs(data, offset2 + 2), rUs(data, offset2 + 4)];
        } else if (type == "gAMA")
          out.tabs[type] = bin.readUint(data, offset2) / 1e5;
        else if (type == "sRGB")
          out.tabs[type] = data[offset2];
        else if (type == "bKGD") {
          if (out.ctype == 0 || out.ctype == 4)
            out.tabs[type] = [rUs(data, offset2)];
          else if (out.ctype == 2 || out.ctype == 6)
            out.tabs[type] = [rUs(data, offset2), rUs(data, offset2 + 2), rUs(data, offset2 + 4)];
          else if (out.ctype == 3)
            out.tabs[type] = data[offset2];
        } else if (type == "IEND") {
          break;
        }
        offset2 += len;
        var crc = bin.readUint(data, offset2);
        offset2 += 4;
      }
      if (foff != 0) {
        var fr = out.frames[out.frames.length - 1];
        fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
        foff = 0;
      }
      out.data = UPNG.decode._decompress(out, dd, out.width, out.height);
      delete out.compress;
      delete out.interlace;
      delete out.filter;
      return out;
    };
    UPNG.decode._decompress = function(out, dd, w, h) {
      var time = Date.now();
      var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h);
      dd = UPNG.decode._inflate(dd, buff);
      var time = Date.now();
      if (out.interlace == 0)
        dd = UPNG.decode._filterZero(dd, out, 0, w, h);
      else if (out.interlace == 1)
        dd = UPNG.decode._readInterlace(dd, out);
      return dd;
    };
    UPNG.decode._inflate = function(data, buff) {
      var out = UPNG["inflateRaw"](new Uint8Array(data.buffer, 2, data.length - 6), buff);
      return out;
    };
    UPNG.inflateRaw = function() {
      var H = {};
      H.H = {};
      H.H.N = function(N, W) {
        var R = Uint8Array, i = 0, m = 0, J = 0, h = 0, Q = 0, X = 0, u = 0, w = 0, d = 0, v, C;
        if (N[0] == 3 && N[1] == 0)
          return W ? W : new R(0);
        var V = H.H, n2 = V.b, A = V.e, l2 = V.R, M = V.n, I = V.A, e = V.Z, b = V.m, Z = W == null;
        if (Z)
          W = new R(N.length >>> 2 << 3);
        while (i == 0) {
          i = n2(N, d, 1);
          m = n2(N, d + 1, 2);
          d += 3;
          if (m == 0) {
            if ((d & 7) != 0)
              d += 8 - (d & 7);
            var D = (d >>> 3) + 4, q = N[D - 4] | N[D - 3] << 8;
            if (Z)
              W = H.H.W(W, w + q);
            W.set(new R(N.buffer, N.byteOffset + D, q), w);
            d = D + q << 3;
            w += q;
            continue;
          }
          if (Z)
            W = H.H.W(W, w + (1 << 17));
          if (m == 1) {
            v = b.J;
            C = b.h;
            X = (1 << 9) - 1;
            u = (1 << 5) - 1;
          }
          if (m == 2) {
            J = A(N, d, 5) + 257;
            h = A(N, d + 5, 5) + 1;
            Q = A(N, d + 10, 4) + 4;
            d += 14;
            var E = d, j = 1;
            for (var c = 0; c < 38; c += 2) {
              b.Q[c] = 0;
              b.Q[c + 1] = 0;
            }
            for (var c = 0; c < Q; c++) {
              var K = A(N, d + c * 3, 3);
              b.Q[(b.X[c] << 1) + 1] = K;
              if (K > j)
                j = K;
            }
            d += 3 * Q;
            M(b.Q, j);
            I(b.Q, j, b.u);
            v = b.w;
            C = b.d;
            d = l2(b.u, (1 << j) - 1, J + h, N, d, b.v);
            var r = V.V(b.v, 0, J, b.C);
            X = (1 << r) - 1;
            var S = V.V(b.v, J, h, b.D);
            u = (1 << S) - 1;
            M(b.C, r);
            I(b.C, r, v);
            M(b.D, S);
            I(b.D, S, C);
          }
          while (true) {
            var T = v[e(N, d) & X];
            d += T & 15;
            var p = T >>> 4;
            if (p >>> 8 == 0) {
              W[w++] = p;
            } else if (p == 256) {
              break;
            } else {
              var z = w + p - 254;
              if (p > 264) {
                var _ = b.q[p - 257];
                z = w + (_ >>> 3) + A(N, d, _ & 7);
                d += _ & 7;
              }
              var $ = C[e(N, d) & u];
              d += $ & 15;
              var s2 = $ >>> 4, Y = b.c[s2], a = (Y >>> 4) + n2(N, d, Y & 15);
              d += Y & 15;
              while (w < z) {
                W[w] = W[w++ - a];
                W[w] = W[w++ - a];
                W[w] = W[w++ - a];
                W[w] = W[w++ - a];
              }
              w = z;
            }
          }
        }
        return W.length == w ? W : W.slice(0, w);
      };
      H.H.W = function(N, W) {
        var R = N.length;
        if (W <= R)
          return N;
        var V = new Uint8Array(R << 1);
        V.set(N, 0);
        return V;
      };
      H.H.R = function(N, W, R, V, n2, A) {
        var l2 = H.H.e, M = H.H.Z, I = 0;
        while (I < R) {
          var e = N[M(V, n2) & W];
          n2 += e & 15;
          var b = e >>> 4;
          if (b <= 15) {
            A[I] = b;
            I++;
          } else {
            var Z = 0, m = 0;
            if (b == 16) {
              m = 3 + l2(V, n2, 2);
              n2 += 2;
              Z = A[I - 1];
            } else if (b == 17) {
              m = 3 + l2(V, n2, 3);
              n2 += 3;
            } else if (b == 18) {
              m = 11 + l2(V, n2, 7);
              n2 += 7;
            }
            var J = I + m;
            while (I < J) {
              A[I] = Z;
              I++;
            }
          }
        }
        return n2;
      };
      H.H.V = function(N, W, R, V) {
        var n2 = 0, A = 0, l2 = V.length >>> 1;
        while (A < R) {
          var M = N[A + W];
          V[A << 1] = 0;
          V[(A << 1) + 1] = M;
          if (M > n2)
            n2 = M;
          A++;
        }
        while (A < l2) {
          V[A << 1] = 0;
          V[(A << 1) + 1] = 0;
          A++;
        }
        return n2;
      };
      H.H.n = function(N, W) {
        var R = H.H.m, V = N.length, n2, A, l2, M, I, e = R.j;
        for (var M = 0; M <= W; M++)
          e[M] = 0;
        for (M = 1; M < V; M += 2)
          e[N[M]]++;
        var b = R.K;
        n2 = 0;
        e[0] = 0;
        for (A = 1; A <= W; A++) {
          n2 = n2 + e[A - 1] << 1;
          b[A] = n2;
        }
        for (l2 = 0; l2 < V; l2 += 2) {
          I = N[l2 + 1];
          if (I != 0) {
            N[l2] = b[I];
            b[I]++;
          }
        }
      };
      H.H.A = function(N, W, R) {
        var V = N.length, n2 = H.H.m, A = n2.r;
        for (var l2 = 0; l2 < V; l2 += 2)
          if (N[l2 + 1] != 0) {
            var M = l2 >> 1, I = N[l2 + 1], e = M << 4 | I, b = W - I, Z = N[l2] << b, m = Z + (1 << b);
            while (Z != m) {
              var J = A[Z] >>> 15 - W;
              R[J] = e;
              Z++;
            }
          }
      };
      H.H.l = function(N, W) {
        var R = H.H.m.r, V = 15 - W;
        for (var n2 = 0; n2 < N.length; n2 += 2) {
          var A = N[n2] << W - N[n2 + 1];
          N[n2] = R[A] >>> V;
        }
      };
      H.H.M = function(N, W, R) {
        R = R << (W & 7);
        var V = W >>> 3;
        N[V] |= R;
        N[V + 1] |= R >>> 8;
      };
      H.H.I = function(N, W, R) {
        R = R << (W & 7);
        var V = W >>> 3;
        N[V] |= R;
        N[V + 1] |= R >>> 8;
        N[V + 2] |= R >>> 16;
      };
      H.H.e = function(N, W, R) {
        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;
      };
      H.H.b = function(N, W, R) {
        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;
      };
      H.H.Z = function(N, W) {
        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);
      };
      H.H.i = function(N, W) {
        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);
      };
      H.H.m = function() {
        var N = Uint16Array, W = Uint32Array;
        return {
          K: new N(16),
          j: new N(16),
          X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
          S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],
          T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],
          q: new N(32),
          p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],
          z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],
          c: new W(32),
          J: new N(512),
          _: [],
          h: new N(32),
          $: [],
          w: new N(32768),
          C: [],
          v: [],
          d: new N(32768),
          D: [],
          u: new N(512),
          Q: [],
          r: new N(1 << 15),
          s: new W(286),
          Y: new W(30),
          a: new W(19),
          t: new W(15e3),
          k: new N(1 << 16),
          g: new N(1 << 15)
        };
      }();
      (function() {
        var N = H.H.m, W = 1 << 15;
        for (var R = 0; R < W; R++) {
          var V = R;
          V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;
          V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;
          V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;
          V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;
          N.r[R] = (V >>> 16 | V << 16) >>> 17;
        }
        function n2(A, l2, M) {
          while (l2-- != 0)
            A.push(0, M);
        }
        for (var R = 0; R < 32; R++) {
          N.q[R] = N.S[R] << 3 | N.T[R];
          N.c[R] = N.p[R] << 4 | N.z[R];
        }
        n2(N._, 144, 8);
        n2(N._, 255 - 143, 9);
        n2(N._, 279 - 255, 7);
        n2(N._, 287 - 279, 8);
        H.H.n(N._, 9);
        H.H.A(N._, 9, N.J);
        H.H.l(N._, 9);
        n2(N.$, 32, 5);
        H.H.n(N.$, 5);
        H.H.A(N.$, 5, N.h);
        H.H.l(N.$, 5);
        n2(N.Q, 19, 0);
        n2(N.C, 286, 0);
        n2(N.D, 30, 0);
        n2(N.v, 320, 0);
      })();
      return H.H.N;
    }();
    UPNG.decode._readInterlace = function(data, out) {
      var w = out.width, h = out.height;
      var bpp = UPNG.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);
      var img = new Uint8Array(h * bpl);
      var di = 0;
      var starting_row = [0, 0, 4, 0, 2, 0, 1];
      var starting_col = [0, 4, 0, 2, 0, 1, 0];
      var row_increment = [8, 8, 8, 4, 4, 2, 2];
      var col_increment = [8, 8, 4, 4, 2, 2, 1];
      var pass = 0;
      while (pass < 7) {
        var ri = row_increment[pass], ci = col_increment[pass];
        var sw = 0, sh = 0;
        var cr = starting_row[pass];
        while (cr < h) {
          cr += ri;
          sh++;
        }
        var cc = starting_col[pass];
        while (cc < w) {
          cc += ci;
          sw++;
        }
        var bpll = Math.ceil(sw * bpp / 8);
        UPNG.decode._filterZero(data, out, di, sw, sh);
        var y = 0, row = starting_row[pass];
        while (row < h) {
          var col = starting_col[pass];
          var cdi = di + y * bpll << 3;
          while (col < w) {
            if (bpp == 1) {
              var val = data[cdi >> 3];
              val = val >> 7 - (cdi & 7) & 1;
              img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);
            }
            if (bpp == 2) {
              var val = data[cdi >> 3];
              val = val >> 6 - (cdi & 7) & 3;
              img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
            }
            if (bpp == 4) {
              var val = data[cdi >> 3];
              val = val >> 4 - (cdi & 7) & 15;
              img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
            }
            if (bpp >= 8) {
              var ii = row * bpl + col * cbpp;
              for (var j = 0; j < cbpp; j++)
                img[ii + j] = data[(cdi >> 3) + j];
            }
            cdi += bpp;
            col += ci;
          }
          y++;
          row += ri;
        }
        if (sw * sh != 0)
          di += sh * (1 + bpll);
        pass = pass + 1;
      }
      return img;
    };
    UPNG.decode._getBPP = function(out) {
      var noc = [1, null, 3, 1, 2, null, 4][out.ctype];
      return noc * out.depth;
    };
    UPNG.decode._filterZero = function(data, out, off, w, h) {
      var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), paeth = UPNG.decode._paeth;
      bpp = Math.ceil(bpp / 8);
      var i = 0, di = 1, type = data[off], x = 0;
      if (type > 1)
        data[off] = [0, 0, 1][type - 2];
      if (type == 3)
        for (x = bpp; x < bpl; x++)
          data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;
      for (var y = 0; y < h; y++) {
        i = off + y * bpl;
        di = i + y + 1;
        type = data[di - 1];
        x = 0;
        if (type == 0)
          for (; x < bpl; x++)
            data[i + x] = data[di + x];
        else if (type == 1) {
          for (; x < bpp; x++)
            data[i + x] = data[di + x];
          for (; x < bpl; x++)
            data[i + x] = data[di + x] + data[i + x - bpp];
        } else if (type == 2) {
          for (; x < bpl; x++)
            data[i + x] = data[di + x] + data[i + x - bpl];
        } else if (type == 3) {
          for (; x < bpp; x++)
            data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1);
          for (; x < bpl; x++)
            data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >>> 1);
        } else {
          for (; x < bpp; x++)
            data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0);
          for (; x < bpl; x++)
            data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]);
        }
      }
      return data;
    };
    UPNG.decode._paeth = function(a, b, c) {
      var p = a + b - c, pa = p - a, pb = p - b, pc = p - c;
      if (pa * pa <= pb * pb && pa * pa <= pc * pc)
        return a;
      else if (pb * pb <= pc * pc)
        return b;
      return c;
    };
    UPNG.decode._IHDR = function(data, offset2, out) {
      var bin = UPNG._bin;
      out.width = bin.readUint(data, offset2);
      offset2 += 4;
      out.height = bin.readUint(data, offset2);
      offset2 += 4;
      out.depth = data[offset2];
      offset2++;
      out.ctype = data[offset2];
      offset2++;
      out.compress = data[offset2];
      offset2++;
      out.filter = data[offset2];
      offset2++;
      out.interlace = data[offset2];
      offset2++;
    };
    UPNG._bin = {
      nextZero: function(data, p) {
        while (data[p] != 0)
          p++;
        return p;
      },
      readUshort: function(buff, p) {
        return buff[p] << 8 | buff[p + 1];
      },
      writeUshort: function(buff, p, n2) {
        buff[p] = n2 >> 8 & 255;
        buff[p + 1] = n2 & 255;
      },
      readUint: function(buff, p) {
        return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);
      },
      writeUint: function(buff, p, n2) {
        buff[p] = n2 >> 24 & 255;
        buff[p + 1] = n2 >> 16 & 255;
        buff[p + 2] = n2 >> 8 & 255;
        buff[p + 3] = n2 & 255;
      },
      readASCII: function(buff, p, l2) {
        var s2 = "";
        for (var i = 0; i < l2; i++)
          s2 += String.fromCharCode(buff[p + i]);
        return s2;
      },
      writeASCII: function(data, p, s2) {
        for (var i = 0; i < s2.length; i++)
          data[p + i] = s2.charCodeAt(i);
      },
      readBytes: function(buff, p, l2) {
        var arr2 = [];
        for (var i = 0; i < l2; i++)
          arr2.push(buff[p + i]);
        return arr2;
      },
      pad: function(n2) {
        return n2.length < 2 ? "0" + n2 : n2;
      },
      readUTF8: function(buff, p, l2) {
        var s2 = "", ns;
        for (var i = 0; i < l2; i++)
          s2 += "%" + UPNG._bin.pad(buff[p + i].toString(16));
        try {
          ns = decodeURIComponent(s2);
        } catch (e) {
          return UPNG._bin.readASCII(buff, p, l2);
        }
        return ns;
      }
    };
    UPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
      var w = Math.min(sw, tw), h = Math.min(sh, th);
      var si = 0, ti = 0;
      for (var y = 0; y < h; y++)
        for (var x = 0; x < w; x++) {
          if (xoff >= 0 && yoff >= 0) {
            si = y * sw + x << 2;
            ti = (yoff + y) * tw + xoff + x << 2;
          } else {
            si = (-yoff + y) * sw - xoff + x << 2;
            ti = y * tw + x << 2;
          }
          if (mode == 0) {
            tb[ti] = sb[si];
            tb[ti + 1] = sb[si + 1];
            tb[ti + 2] = sb[si + 2];
            tb[ti + 3] = sb[si + 3];
          } else if (mode == 1) {
            var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
            var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
            var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
            tb[ti + 3] = 255 * oa;
            tb[ti + 0] = (fr + br * ifa) * ioa;
            tb[ti + 1] = (fg + bg * ifa) * ioa;
            tb[ti + 2] = (fb + bb * ifa) * ioa;
          } else if (mode == 2) {
            var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
            var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
            if (fa == ba && fr == br && fg == bg && fb == bb) {
              tb[ti] = 0;
              tb[ti + 1] = 0;
              tb[ti + 2] = 0;
              tb[ti + 3] = 0;
            } else {
              tb[ti] = fr;
              tb[ti + 1] = fg;
              tb[ti + 2] = fb;
              tb[ti + 3] = fa;
            }
          } else if (mode == 3) {
            var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
            var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
            if (fa == ba && fr == br && fg == bg && fb == bb)
              continue;
            if (fa < 220 && ba > 20)
              return false;
          }
        }
      return true;
    };
    UPNG.encode = function(bufs, w, h, ps, dels, tabs, forbidPlte) {
      if (ps == null)
        ps = 0;
      if (forbidPlte == null)
        forbidPlte = false;
      var nimg = UPNG.encode.compress(bufs, w, h, ps, [false, false, false, 0, forbidPlte]);
      UPNG.encode.compressPNG(nimg, -1);
      return UPNG.encode._main(nimg, w, h, dels, tabs);
    };
    UPNG.encodeLL = function(bufs, w, h, cc, ac, depth, dels, tabs) {
      var nimg = {
        ctype: 0 + (cc == 1 ? 0 : 2) + (ac == 0 ? 0 : 4),
        depth,
        frames: []
      };
      var time = Date.now();
      var bipp = (cc + ac) * depth, bipl = bipp * w;
      for (var i = 0; i < bufs.length; i++)
        nimg.frames.push({
          rect: {
            x: 0,
            y: 0,
            width: w,
            height: h
          },
          img: new Uint8Array(bufs[i]),
          blend: 0,
          dispose: 1,
          bpp: Math.ceil(bipp / 8),
          bpl: Math.ceil(bipl / 8)
        });
      UPNG.encode.compressPNG(nimg, 0, true);
      var out = UPNG.encode._main(nimg, w, h, dels, tabs);
      return out;
    };
    UPNG.encode._main = function(nimg, w, h, dels, tabs) {
      if (tabs == null)
        tabs = {};
      var crc = UPNG.crc.crc, wUi = UPNG._bin.writeUint, wUs = UPNG._bin.writeUshort, wAs = UPNG._bin.writeASCII;
      var offset2 = 8, anim = nimg.frames.length > 1, pltAlpha = false;
      var leng = 8 + (16 + 5 + 4) + (anim ? 20 : 0);
      if (tabs["sRGB"] != null)
        leng += 8 + 1 + 4;
      if (tabs["pHYs"] != null)
        leng += 8 + 9 + 4;
      if (nimg.ctype == 3) {
        var dl = nimg.plte.length;
        for (var i = 0; i < dl; i++)
          if (nimg.plte[i] >>> 24 != 255)
            pltAlpha = true;
        leng += 8 + dl * 3 + 4 + (pltAlpha ? 8 + dl * 1 + 4 : 0);
      }
      for (var j = 0; j < nimg.frames.length; j++) {
        var fr = nimg.frames[j];
        if (anim)
          leng += 38;
        leng += fr.cimg.length + 12;
        if (j != 0)
          leng += 4;
      }
      leng += 12;
      var data = new Uint8Array(leng);
      var wr = [137, 80, 78, 71, 13, 10, 26, 10];
      for (var i = 0; i < 8; i++)
        data[i] = wr[i];
      wUi(data, offset2, 13);
      offset2 += 4;
      wAs(data, offset2, "IHDR");
      offset2 += 4;
      wUi(data, offset2, w);
      offset2 += 4;
      wUi(data, offset2, h);
      offset2 += 4;
      data[offset2] = nimg.depth;
      offset2++;
      data[offset2] = nimg.ctype;
      offset2++;
      data[offset2] = 0;
      offset2++;
      data[offset2] = 0;
      offset2++;
      data[offset2] = 0;
      offset2++;
      wUi(data, offset2, crc(data, offset2 - 17, 17));
      offset2 += 4;
      if (tabs["sRGB"] != null) {
        wUi(data, offset2, 1);
        offset2 += 4;
        wAs(data, offset2, "sRGB");
        offset2 += 4;
        data[offset2] = tabs["sRGB"];
        offset2++;
        wUi(data, offset2, crc(data, offset2 - 5, 5));
        offset2 += 4;
      }
      if (tabs["pHYs"] != null) {
        wUi(data, offset2, 9);
        offset2 += 4;
        wAs(data, offset2, "pHYs");
        offset2 += 4;
        wUi(data, offset2, tabs["pHYs"][0]);
        offset2 += 4;
        wUi(data, offset2, tabs["pHYs"][1]);
        offset2 += 4;
        data[offset2] = tabs["pHYs"][2];
        offset2++;
        wUi(data, offset2, crc(data, offset2 - 13, 13));
        offset2 += 4;
      }
      if (anim) {
        wUi(data, offset2, 8);
        offset2 += 4;
        wAs(data, offset2, "acTL");
        offset2 += 4;
        wUi(data, offset2, nimg.frames.length);
        offset2 += 4;
        wUi(data, offset2, tabs["loop"] != null ? tabs["loop"] : 0);
        offset2 += 4;
        wUi(data, offset2, crc(data, offset2 - 12, 12));
        offset2 += 4;
      }
      if (nimg.ctype == 3) {
        var dl = nimg.plte.length;
        wUi(data, offset2, dl * 3);
        offset2 += 4;
        wAs(data, offset2, "PLTE");
        offset2 += 4;
        for (var i = 0; i < dl; i++) {
          var ti = i * 3, c = nimg.plte[i], r = c & 255, g = c >>> 8 & 255, b = c >>> 16 & 255;
          data[offset2 + ti + 0] = r;
          data[offset2 + ti + 1] = g;
          data[offset2 + ti + 2] = b;
        }
        offset2 += dl * 3;
        wUi(data, offset2, crc(data, offset2 - dl * 3 - 4, dl * 3 + 4));
        offset2 += 4;
        if (pltAlpha) {
          wUi(data, offset2, dl);
          offset2 += 4;
          wAs(data, offset2, "tRNS");
          offset2 += 4;
          for (var i = 0; i < dl; i++)
            data[offset2 + i] = nimg.plte[i] >>> 24 & 255;
          offset2 += dl;
          wUi(data, offset2, crc(data, offset2 - dl - 4, dl + 4));
          offset2 += 4;
        }
      }
      var fi = 0;
      for (var j = 0; j < nimg.frames.length; j++) {
        var fr = nimg.frames[j];
        if (anim) {
          wUi(data, offset2, 26);
          offset2 += 4;
          wAs(data, offset2, "fcTL");
          offset2 += 4;
          wUi(data, offset2, fi++);
          offset2 += 4;
          wUi(data, offset2, fr.rect.width);
          offset2 += 4;
          wUi(data, offset2, fr.rect.height);
          offset2 += 4;
          wUi(data, offset2, fr.rect.x);
          offset2 += 4;
          wUi(data, offset2, fr.rect.y);
          offset2 += 4;
          wUs(data, offset2, dels[j]);
          offset2 += 2;
          wUs(data, offset2, 1e3);
          offset2 += 2;
          data[offset2] = fr.dispose;
          offset2++;
          data[offset2] = fr.blend;
          offset2++;
          wUi(data, offset2, crc(data, offset2 - 30, 30));
          offset2 += 4;
        }
        var imgd = fr.cimg, dl = imgd.length;
        wUi(data, offset2, dl + (j == 0 ? 0 : 4));
        offset2 += 4;
        var ioff = offset2;
        wAs(data, offset2, j == 0 ? "IDAT" : "fdAT");
        offset2 += 4;
        if (j != 0) {
          wUi(data, offset2, fi++);
          offset2 += 4;
        }
        data.set(imgd, offset2);
        offset2 += dl;
        wUi(data, offset2, crc(data, ioff, offset2 - ioff));
        offset2 += 4;
      }
      wUi(data, offset2, 0);
      offset2 += 4;
      wAs(data, offset2, "IEND");
      offset2 += 4;
      wUi(data, offset2, crc(data, offset2 - 4, 4));
      offset2 += 4;
      return data.buffer;
    };
    UPNG.encode.compressPNG = function(out, filter, levelZero) {
      for (var i = 0; i < out.frames.length; i++) {
        var frm = out.frames[i], nw = frm.rect.width, nh = frm.rect.height;
        var fdata = new Uint8Array(nh * frm.bpl + nh);
        frm.cimg = UPNG.encode._filterZero(frm.img, nh, frm.bpp, frm.bpl, fdata, filter, levelZero);
      }
    };
    UPNG.encode.compress = function(bufs, w, h, ps, prms) {
      var onlyBlend = prms[0], evenCrd = prms[1], forbidPrev = prms[2], minBits = prms[3], forbidPlte = prms[4];
      var ctype = 6, depth = 8, alphaAnd = 255;
      for (var j = 0; j < bufs.length; j++) {
        var img = new Uint8Array(bufs[j]), ilen = img.length;
        for (var i = 0; i < ilen; i += 4)
          alphaAnd &= img[i + 3];
      }
      var gotAlpha = alphaAnd != 255;
      var frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);
      var cmap = {}, plte = [], inds = [];
      if (ps != 0) {
        var nbufs = [];
        for (var i = 0; i < frms.length; i++)
          nbufs.push(frms[i].img.buffer);
        var abuf = UPNG.encode.concatRGBA(nbufs), qres = UPNG.quantize(abuf, ps);
        var cof = 0, bb = new Uint8Array(qres.abuf);
        for (var i = 0; i < frms.length; i++) {
          var ti = frms[i].img, bln = ti.length;
          inds.push(new Uint8Array(qres.inds.buffer, cof >> 2, bln >> 2));
          for (var j = 0; j < bln; j += 4) {
            ti[j] = bb[cof + j];
            ti[j + 1] = bb[cof + j + 1];
            ti[j + 2] = bb[cof + j + 2];
            ti[j + 3] = bb[cof + j + 3];
          }
          cof += bln;
        }
        for (var i = 0; i < qres.plte.length; i++)
          plte.push(qres.plte[i].est.rgba);
      } else {
        for (var j = 0; j < frms.length; j++) {
          var frm = frms[j], img32 = new Uint32Array(frm.img.buffer), nw = frm.rect.width, ilen = img32.length;
          var ind = new Uint8Array(ilen);
          inds.push(ind);
          for (var i = 0; i < ilen; i++) {
            var c = img32[i];
            if (i != 0 && c == img32[i - 1])
              ind[i] = ind[i - 1];
            else if (i > nw && c == img32[i - nw])
              ind[i] = ind[i - nw];
            else {
              var cmc = cmap[c];
              if (cmc == null) {
                cmap[c] = cmc = plte.length;
                plte.push(c);
                if (plte.length >= 300)
                  break;
              }
              ind[i] = cmc;
            }
          }
        }
      }
      var cc = plte.length;
      if (cc <= 256 && forbidPlte == false) {
        if (cc <= 2)
          depth = 1;
        else if (cc <= 4)
          depth = 2;
        else if (cc <= 16)
          depth = 4;
        else
          depth = 8;
        depth = Math.max(depth, minBits);
      }
      for (var j = 0; j < frms.length; j++) {
        var frm = frms[j], nx = frm.rect.x, ny = frm.rect.y, nw = frm.rect.width, nh = frm.rect.height;
        var cimg = frm.img, cimg32 = new Uint32Array(cimg.buffer);
        var bpl = 4 * nw, bpp = 4;
        if (cc <= 256 && forbidPlte == false) {
          bpl = Math.ceil(depth * nw / 8);
          var nimg = new Uint8Array(bpl * nh);
          var inj = inds[j];
          for (var y = 0; y < nh; y++) {
            var i = y * bpl, ii = y * nw;
            if (depth == 8)
              for (var x = 0; x < nw; x++)
                nimg[i + x] = inj[ii + x];
            else if (depth == 4)
              for (var x = 0; x < nw; x++)
                nimg[i + (x >> 1)] |= inj[ii + x] << 4 - (x & 1) * 4;
            else if (depth == 2)
              for (var x = 0; x < nw; x++)
                nimg[i + (x >> 2)] |= inj[ii + x] << 6 - (x & 3) * 2;
            else if (depth == 1)
              for (var x = 0; x < nw; x++)
                nimg[i + (x >> 3)] |= inj[ii + x] << 7 - (x & 7) * 1;
          }
          cimg = nimg;
          ctype = 3;
          bpp = 1;
        } else if (gotAlpha == false && frms.length == 1) {
          var nimg = new Uint8Array(nw * nh * 3), area = nw * nh;
          for (var i = 0; i < area; i++) {
            var ti = i * 3, qi = i * 4;
            nimg[ti] = cimg[qi];
            nimg[ti + 1] = cimg[qi + 1];
            nimg[ti + 2] = cimg[qi + 2];
          }
          cimg = nimg;
          ctype = 2;
          bpp = 3;
          bpl = 3 * nw;
        }
        frm.img = cimg;
        frm.bpl = bpl;
        frm.bpp = bpp;
      }
      return {
        ctype,
        depth,
        plte,
        frames: frms
      };
    };
    UPNG.encode.framize = function(bufs, w, h, alwaysBlend, evenCrd, forbidPrev) {
      var frms = [];
      for (var j = 0; j < bufs.length; j++) {
        var cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);
        var nimg;
        var nx = 0, ny = 0, nw = w, nh = h, blend = alwaysBlend ? 1 : 0;
        if (j != 0) {
          var tlim = forbidPrev || alwaysBlend || j == 1 || frms[j - 2].dispose != 0 ? 1 : 2, tstp = 0, tarea = 1e9;
          for (var it = 0; it < tlim; it++) {
            var pimg = new Uint8Array(bufs[j - 1 - it]), p32 = new Uint32Array(bufs[j - 1 - it]);
            var mix = w, miy = h, max = -1, may = -1;
            for (var y = 0; y < h; y++)
              for (var x = 0; x < w; x++) {
                var i = y * w + x;
                if (cimg32[i] != p32[i]) {
                  if (x < mix)
                    mix = x;
                  if (x > max)
                    max = x;
                  if (y < miy)
                    miy = y;
                  if (y > may)
                    may = y;
                }
              }
            if (max == -1)
              mix = miy = max = may = 0;
            if (evenCrd) {
              if ((mix & 1) == 1)
                mix--;
              if ((miy & 1) == 1)
                miy--;
            }
            var sarea = (max - mix + 1) * (may - miy + 1);
            if (sarea < tarea) {
              tarea = sarea;
              tstp = it;
              nx = mix;
              ny = miy;
              nw = max - mix + 1;
              nh = may - miy + 1;
            }
          }
          var pimg = new Uint8Array(bufs[j - 1 - tstp]);
          if (tstp == 1)
            frms[j - 1].dispose = 2;
          nimg = new Uint8Array(nw * nh * 4);
          UPNG._copyTile(pimg, w, h, nimg, nw, nh, -nx, -ny, 0);
          blend = UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 3) ? 1 : 0;
          if (blend == 1)
            UPNG.encode._prepareDiff(cimg, w, h, nimg, {
              x: nx,
              y: ny,
              width: nw,
              height: nh
            });
          else
            UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 0);
        } else
          nimg = cimg.slice(0);
        frms.push({
          rect: {
            x: nx,
            y: ny,
            width: nw,
            height: nh
          },
          img: nimg,
          blend,
          dispose: 0
        });
      }
      if (alwaysBlend)
        for (var j = 0; j < frms.length; j++) {
          var frm = frms[j];
          if (frm.blend == 1)
            continue;
          var r0 = frm.rect, r1 = frms[j - 1].rect;
          var miX = Math.min(r0.x, r1.x), miY = Math.min(r0.y, r1.y);
          var maX = Math.max(r0.x + r0.width, r1.x + r1.width), maY = Math.max(r0.y + r0.height, r1.y + r1.height);
          var r = {
            x: miX,
            y: miY,
            width: maX - miX,
            height: maY - miY
          };
          frms[j - 1].dispose = 1;
          if (j - 1 != 0)
            UPNG.encode._updateFrame(bufs, w, h, frms, j - 1, r, evenCrd);
          UPNG.encode._updateFrame(bufs, w, h, frms, j, r, evenCrd);
        }
      var area = 0;
      if (bufs.length != 1)
        for (var i = 0; i < frms.length; i++) {
          var frm = frms[i];
          area += frm.rect.width * frm.rect.height;
        }
      return frms;
    };
    UPNG.encode._updateFrame = function(bufs, w, h, frms, i, r, evenCrd) {
      var U8 = Uint8Array, U32 = Uint32Array;
      var pimg = new U8(bufs[i - 1]), pimg32 = new U32(bufs[i - 1]), nimg = i + 1 < bufs.length ? new U8(bufs[i + 1]) : null;
      var cimg = new U8(bufs[i]), cimg32 = new U32(cimg.buffer);
      var mix = w, miy = h, max = -1, may = -1;
      for (var y = 0; y < r.height; y++)
        for (var x = 0; x < r.width; x++) {
          var cx = r.x + x, cy = r.y + y;
          var j = cy * w + cx, cc = cimg32[j];
          if (cc == 0 || frms[i - 1].dispose == 0 && pimg32[j] == cc && (nimg == null || nimg[j * 4 + 3] != 0)) {
          } else {
            if (cx < mix)
              mix = cx;
            if (cx > max)
              max = cx;
            if (cy < miy)
              miy = cy;
            if (cy > may)
              may = cy;
          }
        }
      if (max == -1)
        mix = miy = max = may = 0;
      if (evenCrd) {
        if ((mix & 1) == 1)
          mix--;
        if ((miy & 1) == 1)
          miy--;
      }
      r = {
        x: mix,
        y: miy,
        width: max - mix + 1,
        height: may - miy + 1
      };
      var fr = frms[i];
      fr.rect = r;
      fr.blend = 1;
      fr.img = new Uint8Array(r.width * r.height * 4);
      if (frms[i - 1].dispose == 0) {
        UPNG._copyTile(pimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);
        UPNG.encode._prepareDiff(cimg, w, h, fr.img, r);
      } else
        UPNG._copyTile(cimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);
    };
    UPNG.encode._prepareDiff = function(cimg, w, h, nimg, rec) {
      UPNG._copyTile(cimg, w, h, nimg, rec.width, rec.height, -rec.x, -rec.y, 2);
    };
    UPNG.encode._filterZero = function(img, h, bpp, bpl, data, filter, levelZero) {
      var fls = [], ftry = [0, 1, 2, 3, 4];
      if (filter != -1)
        ftry = [filter];
      else if (h * bpl > 5e5 || bpp == 1)
        ftry = [0];
      var opts;
      if (levelZero)
        opts = {
          level: 0
        };
      var CMPR = levelZero && UZIP != null ? UZIP : _pako.default;
      for (var i = 0; i < ftry.length; i++) {
        for (var y = 0; y < h; y++)
          UPNG.encode._filterLine(data, img, y, bpl, bpp, ftry[i]);
        fls.push(CMPR["deflate"](data, opts));
      }
      var ti, tsize = 1e9;
      for (var i = 0; i < fls.length; i++)
        if (fls[i].length < tsize) {
          ti = i;
          tsize = fls[i].length;
        }
      return fls[ti];
    };
    UPNG.encode._filterLine = function(data, img, y, bpl, bpp, type) {
      var i = y * bpl, di = i + y, paeth = UPNG.decode._paeth;
      data[di] = type;
      di++;
      if (type == 0) {
        if (bpl < 500)
          for (var x = 0; x < bpl; x++)
            data[di + x] = img[i + x];
        else
          data.set(new Uint8Array(img.buffer, i, bpl), di);
      } else if (type == 1) {
        for (var x = 0; x < bpp; x++)
          data[di + x] = img[i + x];
        for (var x = bpp; x < bpl; x++)
          data[di + x] = img[i + x] - img[i + x - bpp] + 256 & 255;
      } else if (y == 0) {
        for (var x = 0; x < bpp; x++)
          data[di + x] = img[i + x];
        if (type == 2)
          for (var x = bpp; x < bpl; x++)
            data[di + x] = img[i + x];
        if (type == 3)
          for (var x = bpp; x < bpl; x++)
            data[di + x] = img[i + x] - (img[i + x - bpp] >> 1) + 256 & 255;
        if (type == 4)
          for (var x = bpp; x < bpl; x++)
            data[di + x] = img[i + x] - paeth(img[i + x - bpp], 0, 0) + 256 & 255;
      } else {
        if (type == 2) {
          for (var x = 0; x < bpl; x++)
            data[di + x] = img[i + x] + 256 - img[i + x - bpl] & 255;
        }
        if (type == 3) {
          for (var x = 0; x < bpp; x++)
            data[di + x] = img[i + x] + 256 - (img[i + x - bpl] >> 1) & 255;
          for (var x = bpp; x < bpl; x++)
            data[di + x] = img[i + x] + 256 - (img[i + x - bpl] + img[i + x - bpp] >> 1) & 255;
        }
        if (type == 4) {
          for (var x = 0; x < bpp; x++)
            data[di + x] = img[i + x] + 256 - paeth(0, img[i + x - bpl], 0) & 255;
          for (var x = bpp; x < bpl; x++)
            data[di + x] = img[i + x] + 256 - paeth(img[i + x - bpp], img[i + x - bpl], img[i + x - bpp - bpl]) & 255;
        }
      }
    };
    UPNG.crc = {
      table: function() {
        var tab = new Uint32Array(256);
        for (var n2 = 0; n2 < 256; n2++) {
          var c = n2;
          for (var k = 0; k < 8; k++) {
            if (c & 1)
              c = 3988292384 ^ c >>> 1;
            else
              c = c >>> 1;
          }
          tab[n2] = c;
        }
        return tab;
      }(),
      update: function(c, buf, off, len) {
        for (var i = 0; i < len; i++)
          c = UPNG.crc.table[(c ^ buf[off + i]) & 255] ^ c >>> 8;
        return c;
      },
      crc: function(b, o, l2) {
        return UPNG.crc.update(4294967295, b, o, l2) ^ 4294967295;
      }
    };
    UPNG.quantize = function(abuf, ps) {
      var oimg = new Uint8Array(abuf), nimg = oimg.slice(0), nimg32 = new Uint32Array(nimg.buffer);
      var KD = UPNG.quantize.getKDtree(nimg, ps);
      var root = KD[0], leafs = KD[1];
      var planeDst = UPNG.quantize.planeDst;
      var sb = oimg, tb = nimg32, len = sb.length;
      var inds = new Uint8Array(oimg.length >> 2);
      for (var i = 0; i < len; i += 4) {
        var r = sb[i] * (1 / 255), g = sb[i + 1] * (1 / 255), b = sb[i + 2] * (1 / 255), a = sb[i + 3] * (1 / 255);
        var nd = UPNG.quantize.getNearest(root, r, g, b, a);
        inds[i >> 2] = nd.ind;
        tb[i >> 2] = nd.est.rgba;
      }
      return {
        abuf: nimg.buffer,
        inds,
        plte: leafs
      };
    };
    UPNG.quantize.getKDtree = function(nimg, ps, err) {
      if (err == null)
        err = 1e-4;
      var nimg32 = new Uint32Array(nimg.buffer);
      var root = {
        i0: 0,
        i1: nimg.length,
        bst: null,
        est: null,
        tdst: 0,
        left: null,
        right: null
      };
      root.bst = UPNG.quantize.stats(nimg, root.i0, root.i1);
      root.est = UPNG.quantize.estats(root.bst);
      var leafs = [root];
      while (leafs.length < ps) {
        var maxL = 0, mi = 0;
        for (var i = 0; i < leafs.length; i++)
          if (leafs[i].est.L > maxL) {
            maxL = leafs[i].est.L;
            mi = i;
          }
        if (maxL < err)
          break;
        var node = leafs[mi];
        var s0 = UPNG.quantize.splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);
        var s0wrong = node.i0 >= s0 || node.i1 <= s0;
        if (s0wrong) {
          node.est.L = 0;
          continue;
        }
        var ln = {
          i0: node.i0,
          i1: s0,
          bst: null,
          est: null,
          tdst: 0,
          left: null,
          right: null
        };
        ln.bst = UPNG.quantize.stats(nimg, ln.i0, ln.i1);
        ln.est = UPNG.quantize.estats(ln.bst);
        var rn = {
          i0: s0,
          i1: node.i1,
          bst: null,
          est: null,
          tdst: 0,
          left: null,
          right: null
        };
        rn.bst = {
          R: [],
          m: [],
          N: node.bst.N - ln.bst.N
        };
        for (var i = 0; i < 16; i++)
          rn.bst.R[i] = node.bst.R[i] - ln.bst.R[i];
        for (var i = 0; i < 4; i++)
          rn.bst.m[i] = node.bst.m[i] - ln.bst.m[i];
        rn.est = UPNG.quantize.estats(rn.bst);
        node.left = ln;
        node.right = rn;
        leafs[mi] = ln;
        leafs.push(rn);
      }
      leafs.sort(function(a, b) {
        return b.bst.N - a.bst.N;
      });
      for (var i = 0; i < leafs.length; i++)
        leafs[i].ind = i;
      return [root, leafs];
    };
    UPNG.quantize.getNearest = function(nd, r, g, b, a) {
      if (nd.left == null) {
        nd.tdst = UPNG.quantize.dist(nd.est.q, r, g, b, a);
        return nd;
      }
      var planeDst = UPNG.quantize.planeDst(nd.est, r, g, b, a);
      var node0 = nd.left, node1 = nd.right;
      if (planeDst > 0) {
        node0 = nd.right;
        node1 = nd.left;
      }
      var ln = UPNG.quantize.getNearest(node0, r, g, b, a);
      if (ln.tdst <= planeDst * planeDst)
        return ln;
      var rn = UPNG.quantize.getNearest(node1, r, g, b, a);
      return rn.tdst < ln.tdst ? rn : ln;
    };
    UPNG.quantize.planeDst = function(est, r, g, b, a) {
      var e = est.e;
      return e[0] * r + e[1] * g + e[2] * b + e[3] * a - est.eMq;
    };
    UPNG.quantize.dist = function(q, r, g, b, a) {
      var d0 = r - q[0], d1 = g - q[1], d2 = b - q[2], d3 = a - q[3];
      return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;
    };
    UPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq) {
      var vecDot = UPNG.quantize.vecDot;
      i1 -= 4;
      var shfs = 0;
      while (i0 < i1) {
        while (vecDot(nimg, i0, e) <= eMq)
          i0 += 4;
        while (vecDot(nimg, i1, e) > eMq)
          i1 -= 4;
        if (i0 >= i1)
          break;
        var t2 = nimg32[i0 >> 2];
        nimg32[i0 >> 2] = nimg32[i1 >> 2];
        nimg32[i1 >> 2] = t2;
        i0 += 4;
        i1 -= 4;
      }
      while (vecDot(nimg, i0, e) > eMq)
        i0 -= 4;
      return i0 + 4;
    };
    UPNG.quantize.vecDot = function(nimg, i, e) {
      return nimg[i] * e[0] + nimg[i + 1] * e[1] + nimg[i + 2] * e[2] + nimg[i + 3] * e[3];
    };
    UPNG.quantize.stats = function(nimg, i0, i1) {
      var R = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      var m = [0, 0, 0, 0];
      var N = i1 - i0 >> 2;
      for (var i = i0; i < i1; i += 4) {
        var r = nimg[i] * (1 / 255), g = nimg[i + 1] * (1 / 255), b = nimg[i + 2] * (1 / 255), a = nimg[i + 3] * (1 / 255);
        m[0] += r;
        m[1] += g;
        m[2] += b;
        m[3] += a;
        R[0] += r * r;
        R[1] += r * g;
        R[2] += r * b;
        R[3] += r * a;
        R[5] += g * g;
        R[6] += g * b;
        R[7] += g * a;
        R[10] += b * b;
        R[11] += b * a;
        R[15] += a * a;
      }
      R[4] = R[1];
      R[8] = R[2];
      R[9] = R[6];
      R[12] = R[3];
      R[13] = R[7];
      R[14] = R[11];
      return {
        R,
        m,
        N
      };
    };
    UPNG.quantize.estats = function(stats) {
      var R = stats.R, m = stats.m, N = stats.N;
      var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = N == 0 ? 0 : 1 / N;
      var Rj = [R[0] - m0 * m0 * iN, R[1] - m0 * m1 * iN, R[2] - m0 * m2 * iN, R[3] - m0 * m3 * iN, R[4] - m1 * m0 * iN, R[5] - m1 * m1 * iN, R[6] - m1 * m2 * iN, R[7] - m1 * m3 * iN, R[8] - m2 * m0 * iN, R[9] - m2 * m1 * iN, R[10] - m2 * m2 * iN, R[11] - m2 * m3 * iN, R[12] - m3 * m0 * iN, R[13] - m3 * m1 * iN, R[14] - m3 * m2 * iN, R[15] - m3 * m3 * iN];
      var A = Rj, M = UPNG.M4;
      var b = [0.5, 0.5, 0.5, 0.5], mi = 0, tmi = 0;
      if (N != 0)
        for (var i = 0; i < 10; i++) {
          b = M.multVec(A, b);
          tmi = Math.sqrt(M.dot(b, b));
          b = M.sml(1 / tmi, b);
          if (Math.abs(tmi - mi) < 1e-9)
            break;
          mi = tmi;
        }
      var q = [m0 * iN, m1 * iN, m2 * iN, m3 * iN];
      var eMq255 = M.dot(M.sml(255, q), b);
      return {
        Cov: Rj,
        q,
        e: b,
        L: mi,
        eMq255,
        eMq: M.dot(b, q),
        rgba: (Math.round(255 * q[3]) << 24 | Math.round(255 * q[2]) << 16 | Math.round(255 * q[1]) << 8 | Math.round(255 * q[0]) << 0) >>> 0
      };
    };
    UPNG.M4 = {
      multVec: function(m, v) {
        return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3], m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3], m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3], m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3]];
      },
      dot: function(x, y) {
        return x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];
      },
      sml: function(a, y) {
        return [a * y[0], a * y[1], a * y[2], a * y[3]];
      }
    };
    UPNG.encode.concatRGBA = function(bufs) {
      var tlen = 0;
      for (var i = 0; i < bufs.length; i++)
        tlen += bufs[i].byteLength;
      var nimg = new Uint8Array(tlen), noff = 0;
      for (var i = 0; i < bufs.length; i++) {
        var img = new Uint8Array(bufs[i]), il = img.length;
        for (var j = 0; j < il; j += 4) {
          var r = img[j], g = img[j + 1], b = img[j + 2], a = img[j + 3];
          if (a == 0)
            r = g = b = 0;
          nimg[noff + j] = r;
          nimg[noff + j + 1] = g;
          nimg[noff + j + 2] = b;
          nimg[noff + j + 3] = a;
        }
        noff += il;
      }
      return nimg.buffer;
    };
    var _default = UPNG;
    exports.default = _default;
  }
});

// ../../../node_modules/pdf-lib/cjs/utils/png.js
var require_png = __commonJS({
  "../../../node_modules/pdf-lib/cjs/utils/png.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PNG = exports.PngType = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var upng_1 = tslib_1.__importDefault(require_UPNG());
    var getImageType = function(ctype) {
      if (ctype === 0)
        return PngType.Greyscale;
      if (ctype === 2)
        return PngType.Truecolour;
      if (ctype === 3)
        return PngType.IndexedColour;
      if (ctype === 4)
        return PngType.GreyscaleWithAlpha;
      if (ctype === 6)
        return PngType.TruecolourWithAlpha;
      throw new Error("Unknown color type: " + ctype);
    };
    var splitAlphaChannel = function(rgbaChannel) {
      var pixelCount = Math.floor(rgbaChannel.length / 4);
      var rgbChannel = new Uint8Array(pixelCount * 3);
      var alphaChannel = new Uint8Array(pixelCount * 1);
      var rgbaOffset = 0;
      var rgbOffset = 0;
      var alphaOffset = 0;
      while (rgbaOffset < rgbaChannel.length) {
        rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
        rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
        rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
        alphaChannel[alphaOffset++] = rgbaChannel[rgbaOffset++];
      }
      return { rgbChannel, alphaChannel };
    };
    var PngType;
    (function(PngType2) {
      PngType2["Greyscale"] = "Greyscale";
      PngType2["Truecolour"] = "Truecolour";
      PngType2["IndexedColour"] = "IndexedColour";
      PngType2["GreyscaleWithAlpha"] = "GreyscaleWithAlpha";
      PngType2["TruecolourWithAlpha"] = "TruecolourWithAlpha";
    })(PngType = exports.PngType || (exports.PngType = {}));
    var PNG = (
      /** @class */
      function() {
        function PNG2(pngData) {
          var upng = upng_1.default.decode(pngData);
          var frames = upng_1.default.toRGBA8(upng);
          if (frames.length > 1)
            throw new Error("Animated PNGs are not supported");
          var frame = new Uint8Array(frames[0]);
          var _a = splitAlphaChannel(frame), rgbChannel = _a.rgbChannel, alphaChannel = _a.alphaChannel;
          this.rgbChannel = rgbChannel;
          var hasAlphaValues = alphaChannel.some(function(a) {
            return a < 255;
          });
          if (hasAlphaValues)
            this.alphaChannel = alphaChannel;
          this.type = getImageType(upng.ctype);
          this.width = upng.width;
          this.height = upng.height;
          this.bitsPerComponent = 8;
        }
        PNG2.load = function(pngData) {
          return new PNG2(pngData);
        };
        return PNG2;
      }()
    );
    exports.PNG = PNG;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/embedders/PngEmbedder.js
var require_PngEmbedder = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/embedders/PngEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var png_1 = require_png();
    var PngEmbedder = (
      /** @class */
      function() {
        function PngEmbedder2(png) {
          this.image = png;
          this.bitsPerComponent = png.bitsPerComponent;
          this.width = png.width;
          this.height = png.height;
          this.colorSpace = "DeviceRGB";
        }
        PngEmbedder2.for = function(imageData) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var png;
            return tslib_1.__generator(this, function(_a) {
              png = png_1.PNG.load(imageData);
              return [2, new PngEmbedder2(png)];
            });
          });
        };
        PngEmbedder2.prototype.embedIntoContext = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var SMask, xObject;
            return tslib_1.__generator(this, function(_a) {
              SMask = this.embedAlphaChannel(context);
              xObject = context.flateStream(this.image.rgbChannel, {
                Type: "XObject",
                Subtype: "Image",
                BitsPerComponent: this.image.bitsPerComponent,
                Width: this.image.width,
                Height: this.image.height,
                ColorSpace: this.colorSpace,
                SMask
              });
              if (ref) {
                context.assign(ref, xObject);
                return [2, ref];
              } else {
                return [2, context.register(xObject)];
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        PngEmbedder2.prototype.embedAlphaChannel = function(context) {
          if (!this.image.alphaChannel)
            return void 0;
          var xObject = context.flateStream(this.image.alphaChannel, {
            Type: "XObject",
            Subtype: "Image",
            Height: this.image.height,
            Width: this.image.width,
            BitsPerComponent: this.image.bitsPerComponent,
            ColorSpace: "DeviceGray",
            Decode: [0, 1]
          });
          return context.register(xObject);
        };
        return PngEmbedder2;
      }()
    );
    exports.default = PngEmbedder;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/streams/Stream.js
var require_Stream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/streams/Stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Stream = (
      /** @class */
      function() {
        function Stream2(buffer, start, length) {
          this.bytes = buffer;
          this.start = start || 0;
          this.pos = this.start;
          this.end = !!start && !!length ? start + length : this.bytes.length;
        }
        Object.defineProperty(Stream2.prototype, "length", {
          get: function() {
            return this.end - this.start;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Stream2.prototype, "isEmpty", {
          get: function() {
            return this.length === 0;
          },
          enumerable: false,
          configurable: true
        });
        Stream2.prototype.getByte = function() {
          if (this.pos >= this.end) {
            return -1;
          }
          return this.bytes[this.pos++];
        };
        Stream2.prototype.getUint16 = function() {
          var b0 = this.getByte();
          var b1 = this.getByte();
          if (b0 === -1 || b1 === -1) {
            return -1;
          }
          return (b0 << 8) + b1;
        };
        Stream2.prototype.getInt32 = function() {
          var b0 = this.getByte();
          var b1 = this.getByte();
          var b2 = this.getByte();
          var b3 = this.getByte();
          return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
        };
        Stream2.prototype.getBytes = function(length, forceClamped) {
          if (forceClamped === void 0) {
            forceClamped = false;
          }
          var bytes = this.bytes;
          var pos = this.pos;
          var strEnd = this.end;
          if (!length) {
            var subarray = bytes.subarray(pos, strEnd);
            return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
          } else {
            var end = pos + length;
            if (end > strEnd) {
              end = strEnd;
            }
            this.pos = end;
            var subarray = bytes.subarray(pos, end);
            return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
          }
        };
        Stream2.prototype.peekByte = function() {
          var peekedByte = this.getByte();
          this.pos--;
          return peekedByte;
        };
        Stream2.prototype.peekBytes = function(length, forceClamped) {
          if (forceClamped === void 0) {
            forceClamped = false;
          }
          var bytes = this.getBytes(length, forceClamped);
          this.pos -= bytes.length;
          return bytes;
        };
        Stream2.prototype.skip = function(n2) {
          if (!n2) {
            n2 = 1;
          }
          this.pos += n2;
        };
        Stream2.prototype.reset = function() {
          this.pos = this.start;
        };
        Stream2.prototype.moveStart = function() {
          this.start = this.pos;
        };
        Stream2.prototype.makeSubStream = function(start, length) {
          return new Stream2(this.bytes, start, length);
        };
        Stream2.prototype.decode = function() {
          return this.bytes;
        };
        return Stream2;
      }()
    );
    exports.default = Stream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/streams/DecodeStream.js
var require_DecodeStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/streams/DecodeStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var Stream_1 = tslib_1.__importDefault(require_Stream());
    var emptyBuffer = new Uint8Array(0);
    var DecodeStream = (
      /** @class */
      function() {
        function DecodeStream2(maybeMinBufferLength) {
          this.pos = 0;
          this.bufferLength = 0;
          this.eof = false;
          this.buffer = emptyBuffer;
          this.minBufferLength = 512;
          if (maybeMinBufferLength) {
            while (this.minBufferLength < maybeMinBufferLength) {
              this.minBufferLength *= 2;
            }
          }
        }
        Object.defineProperty(DecodeStream2.prototype, "isEmpty", {
          get: function() {
            while (!this.eof && this.bufferLength === 0) {
              this.readBlock();
            }
            return this.bufferLength === 0;
          },
          enumerable: false,
          configurable: true
        });
        DecodeStream2.prototype.getByte = function() {
          var pos = this.pos;
          while (this.bufferLength <= pos) {
            if (this.eof) {
              return -1;
            }
            this.readBlock();
          }
          return this.buffer[this.pos++];
        };
        DecodeStream2.prototype.getUint16 = function() {
          var b0 = this.getByte();
          var b1 = this.getByte();
          if (b0 === -1 || b1 === -1) {
            return -1;
          }
          return (b0 << 8) + b1;
        };
        DecodeStream2.prototype.getInt32 = function() {
          var b0 = this.getByte();
          var b1 = this.getByte();
          var b2 = this.getByte();
          var b3 = this.getByte();
          return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
        };
        DecodeStream2.prototype.getBytes = function(length, forceClamped) {
          if (forceClamped === void 0) {
            forceClamped = false;
          }
          var end;
          var pos = this.pos;
          if (length) {
            this.ensureBuffer(pos + length);
            end = pos + length;
            while (!this.eof && this.bufferLength < end) {
              this.readBlock();
            }
            var bufEnd = this.bufferLength;
            if (end > bufEnd) {
              end = bufEnd;
            }
          } else {
            while (!this.eof) {
              this.readBlock();
            }
            end = this.bufferLength;
          }
          this.pos = end;
          var subarray = this.buffer.subarray(pos, end);
          return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;
        };
        DecodeStream2.prototype.peekByte = function() {
          var peekedByte = this.getByte();
          this.pos--;
          return peekedByte;
        };
        DecodeStream2.prototype.peekBytes = function(length, forceClamped) {
          if (forceClamped === void 0) {
            forceClamped = false;
          }
          var bytes = this.getBytes(length, forceClamped);
          this.pos -= bytes.length;
          return bytes;
        };
        DecodeStream2.prototype.skip = function(n2) {
          if (!n2) {
            n2 = 1;
          }
          this.pos += n2;
        };
        DecodeStream2.prototype.reset = function() {
          this.pos = 0;
        };
        DecodeStream2.prototype.makeSubStream = function(start, length) {
          var end = start + length;
          while (this.bufferLength <= end && !this.eof) {
            this.readBlock();
          }
          return new Stream_1.default(
            this.buffer,
            start,
            length
            /* dict */
          );
        };
        DecodeStream2.prototype.decode = function() {
          while (!this.eof)
            this.readBlock();
          return this.buffer.subarray(0, this.bufferLength);
        };
        DecodeStream2.prototype.readBlock = function() {
          throw new errors_1.MethodNotImplementedError(this.constructor.name, "readBlock");
        };
        DecodeStream2.prototype.ensureBuffer = function(requested) {
          var buffer = this.buffer;
          if (requested <= buffer.byteLength) {
            return buffer;
          }
          var size = this.minBufferLength;
          while (size < requested) {
            size *= 2;
          }
          var buffer2 = new Uint8Array(size);
          buffer2.set(buffer);
          return this.buffer = buffer2;
        };
        return DecodeStream2;
      }()
    );
    exports.default = DecodeStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/streams/Ascii85Stream.js
var require_Ascii85Stream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/streams/Ascii85Stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var DecodeStream_1 = tslib_1.__importDefault(require_DecodeStream());
    var isSpace = function(ch) {
      return ch === 32 || ch === 9 || ch === 13 || ch === 10;
    };
    var Ascii85Stream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(Ascii85Stream2, _super);
        function Ascii85Stream2(stream, maybeLength) {
          var _this = _super.call(this, maybeLength) || this;
          _this.stream = stream;
          _this.input = new Uint8Array(5);
          if (maybeLength) {
            maybeLength = 0.8 * maybeLength;
          }
          return _this;
        }
        Ascii85Stream2.prototype.readBlock = function() {
          var TILDA_CHAR = 126;
          var Z_LOWER_CHAR = 122;
          var EOF = -1;
          var stream = this.stream;
          var c = stream.getByte();
          while (isSpace(c)) {
            c = stream.getByte();
          }
          if (c === EOF || c === TILDA_CHAR) {
            this.eof = true;
            return;
          }
          var bufferLength = this.bufferLength;
          var buffer;
          var i;
          if (c === Z_LOWER_CHAR) {
            buffer = this.ensureBuffer(bufferLength + 4);
            for (i = 0; i < 4; ++i) {
              buffer[bufferLength + i] = 0;
            }
            this.bufferLength += 4;
          } else {
            var input = this.input;
            input[0] = c;
            for (i = 1; i < 5; ++i) {
              c = stream.getByte();
              while (isSpace(c)) {
                c = stream.getByte();
              }
              input[i] = c;
              if (c === EOF || c === TILDA_CHAR) {
                break;
              }
            }
            buffer = this.ensureBuffer(bufferLength + i - 1);
            this.bufferLength += i - 1;
            if (i < 5) {
              for (; i < 5; ++i) {
                input[i] = 33 + 84;
              }
              this.eof = true;
            }
            var t2 = 0;
            for (i = 0; i < 5; ++i) {
              t2 = t2 * 85 + (input[i] - 33);
            }
            for (i = 3; i >= 0; --i) {
              buffer[bufferLength + i] = t2 & 255;
              t2 >>= 8;
            }
          }
        };
        return Ascii85Stream2;
      }(DecodeStream_1.default)
    );
    exports.default = Ascii85Stream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/streams/AsciiHexStream.js
var require_AsciiHexStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/streams/AsciiHexStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var DecodeStream_1 = tslib_1.__importDefault(require_DecodeStream());
    var AsciiHexStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(AsciiHexStream2, _super);
        function AsciiHexStream2(stream, maybeLength) {
          var _this = _super.call(this, maybeLength) || this;
          _this.stream = stream;
          _this.firstDigit = -1;
          if (maybeLength) {
            maybeLength = 0.5 * maybeLength;
          }
          return _this;
        }
        AsciiHexStream2.prototype.readBlock = function() {
          var UPSTREAM_BLOCK_SIZE = 8e3;
          var bytes = this.stream.getBytes(UPSTREAM_BLOCK_SIZE);
          if (!bytes.length) {
            this.eof = true;
            return;
          }
          var maxDecodeLength = bytes.length + 1 >> 1;
          var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
          var bufferLength = this.bufferLength;
          var firstDigit = this.firstDigit;
          for (var i = 0, ii = bytes.length; i < ii; i++) {
            var ch = bytes[i];
            var digit = void 0;
            if (ch >= 48 && ch <= 57) {
              digit = ch & 15;
            } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
              digit = (ch & 15) + 9;
            } else if (ch === 62) {
              this.eof = true;
              break;
            } else {
              continue;
            }
            if (firstDigit < 0) {
              firstDigit = digit;
            } else {
              buffer[bufferLength++] = firstDigit << 4 | digit;
              firstDigit = -1;
            }
          }
          if (firstDigit >= 0 && this.eof) {
            buffer[bufferLength++] = firstDigit << 4;
            firstDigit = -1;
          }
          this.firstDigit = firstDigit;
          this.bufferLength = bufferLength;
        };
        return AsciiHexStream2;
      }(DecodeStream_1.default)
    );
    exports.default = AsciiHexStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/streams/FlateStream.js
var require_FlateStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/streams/FlateStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var DecodeStream_1 = tslib_1.__importDefault(require_DecodeStream());
    var codeLenCodeMap = new Int32Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var lengthDecode = new Int32Array([
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      65547,
      65549,
      65551,
      65553,
      131091,
      131095,
      131099,
      131103,
      196643,
      196651,
      196659,
      196667,
      262211,
      262227,
      262243,
      262259,
      327811,
      327843,
      327875,
      327907,
      258,
      258,
      258
    ]);
    var distDecode = new Int32Array([
      1,
      2,
      3,
      4,
      65541,
      65543,
      131081,
      131085,
      196625,
      196633,
      262177,
      262193,
      327745,
      327777,
      393345,
      393409,
      459009,
      459137,
      524801,
      525057,
      590849,
      591361,
      657409,
      658433,
      724993,
      727041,
      794625,
      798721,
      868353,
      876545
    ]);
    var fixedLitCodeTab = [new Int32Array([
      459008,
      524368,
      524304,
      524568,
      459024,
      524400,
      524336,
      590016,
      459016,
      524384,
      524320,
      589984,
      524288,
      524416,
      524352,
      590048,
      459012,
      524376,
      524312,
      589968,
      459028,
      524408,
      524344,
      590032,
      459020,
      524392,
      524328,
      59e4,
      524296,
      524424,
      524360,
      590064,
      459010,
      524372,
      524308,
      524572,
      459026,
      524404,
      524340,
      590024,
      459018,
      524388,
      524324,
      589992,
      524292,
      524420,
      524356,
      590056,
      459014,
      524380,
      524316,
      589976,
      459030,
      524412,
      524348,
      590040,
      459022,
      524396,
      524332,
      590008,
      524300,
      524428,
      524364,
      590072,
      459009,
      524370,
      524306,
      524570,
      459025,
      524402,
      524338,
      590020,
      459017,
      524386,
      524322,
      589988,
      524290,
      524418,
      524354,
      590052,
      459013,
      524378,
      524314,
      589972,
      459029,
      524410,
      524346,
      590036,
      459021,
      524394,
      524330,
      590004,
      524298,
      524426,
      524362,
      590068,
      459011,
      524374,
      524310,
      524574,
      459027,
      524406,
      524342,
      590028,
      459019,
      524390,
      524326,
      589996,
      524294,
      524422,
      524358,
      590060,
      459015,
      524382,
      524318,
      589980,
      459031,
      524414,
      524350,
      590044,
      459023,
      524398,
      524334,
      590012,
      524302,
      524430,
      524366,
      590076,
      459008,
      524369,
      524305,
      524569,
      459024,
      524401,
      524337,
      590018,
      459016,
      524385,
      524321,
      589986,
      524289,
      524417,
      524353,
      590050,
      459012,
      524377,
      524313,
      589970,
      459028,
      524409,
      524345,
      590034,
      459020,
      524393,
      524329,
      590002,
      524297,
      524425,
      524361,
      590066,
      459010,
      524373,
      524309,
      524573,
      459026,
      524405,
      524341,
      590026,
      459018,
      524389,
      524325,
      589994,
      524293,
      524421,
      524357,
      590058,
      459014,
      524381,
      524317,
      589978,
      459030,
      524413,
      524349,
      590042,
      459022,
      524397,
      524333,
      590010,
      524301,
      524429,
      524365,
      590074,
      459009,
      524371,
      524307,
      524571,
      459025,
      524403,
      524339,
      590022,
      459017,
      524387,
      524323,
      589990,
      524291,
      524419,
      524355,
      590054,
      459013,
      524379,
      524315,
      589974,
      459029,
      524411,
      524347,
      590038,
      459021,
      524395,
      524331,
      590006,
      524299,
      524427,
      524363,
      590070,
      459011,
      524375,
      524311,
      524575,
      459027,
      524407,
      524343,
      590030,
      459019,
      524391,
      524327,
      589998,
      524295,
      524423,
      524359,
      590062,
      459015,
      524383,
      524319,
      589982,
      459031,
      524415,
      524351,
      590046,
      459023,
      524399,
      524335,
      590014,
      524303,
      524431,
      524367,
      590078,
      459008,
      524368,
      524304,
      524568,
      459024,
      524400,
      524336,
      590017,
      459016,
      524384,
      524320,
      589985,
      524288,
      524416,
      524352,
      590049,
      459012,
      524376,
      524312,
      589969,
      459028,
      524408,
      524344,
      590033,
      459020,
      524392,
      524328,
      590001,
      524296,
      524424,
      524360,
      590065,
      459010,
      524372,
      524308,
      524572,
      459026,
      524404,
      524340,
      590025,
      459018,
      524388,
      524324,
      589993,
      524292,
      524420,
      524356,
      590057,
      459014,
      524380,
      524316,
      589977,
      459030,
      524412,
      524348,
      590041,
      459022,
      524396,
      524332,
      590009,
      524300,
      524428,
      524364,
      590073,
      459009,
      524370,
      524306,
      524570,
      459025,
      524402,
      524338,
      590021,
      459017,
      524386,
      524322,
      589989,
      524290,
      524418,
      524354,
      590053,
      459013,
      524378,
      524314,
      589973,
      459029,
      524410,
      524346,
      590037,
      459021,
      524394,
      524330,
      590005,
      524298,
      524426,
      524362,
      590069,
      459011,
      524374,
      524310,
      524574,
      459027,
      524406,
      524342,
      590029,
      459019,
      524390,
      524326,
      589997,
      524294,
      524422,
      524358,
      590061,
      459015,
      524382,
      524318,
      589981,
      459031,
      524414,
      524350,
      590045,
      459023,
      524398,
      524334,
      590013,
      524302,
      524430,
      524366,
      590077,
      459008,
      524369,
      524305,
      524569,
      459024,
      524401,
      524337,
      590019,
      459016,
      524385,
      524321,
      589987,
      524289,
      524417,
      524353,
      590051,
      459012,
      524377,
      524313,
      589971,
      459028,
      524409,
      524345,
      590035,
      459020,
      524393,
      524329,
      590003,
      524297,
      524425,
      524361,
      590067,
      459010,
      524373,
      524309,
      524573,
      459026,
      524405,
      524341,
      590027,
      459018,
      524389,
      524325,
      589995,
      524293,
      524421,
      524357,
      590059,
      459014,
      524381,
      524317,
      589979,
      459030,
      524413,
      524349,
      590043,
      459022,
      524397,
      524333,
      590011,
      524301,
      524429,
      524365,
      590075,
      459009,
      524371,
      524307,
      524571,
      459025,
      524403,
      524339,
      590023,
      459017,
      524387,
      524323,
      589991,
      524291,
      524419,
      524355,
      590055,
      459013,
      524379,
      524315,
      589975,
      459029,
      524411,
      524347,
      590039,
      459021,
      524395,
      524331,
      590007,
      524299,
      524427,
      524363,
      590071,
      459011,
      524375,
      524311,
      524575,
      459027,
      524407,
      524343,
      590031,
      459019,
      524391,
      524327,
      589999,
      524295,
      524423,
      524359,
      590063,
      459015,
      524383,
      524319,
      589983,
      459031,
      524415,
      524351,
      590047,
      459023,
      524399,
      524335,
      590015,
      524303,
      524431,
      524367,
      590079
    ]), 9];
    var fixedDistCodeTab = [new Int32Array([
      327680,
      327696,
      327688,
      327704,
      327684,
      327700,
      327692,
      327708,
      327682,
      327698,
      327690,
      327706,
      327686,
      327702,
      327694,
      0,
      327681,
      327697,
      327689,
      327705,
      327685,
      327701,
      327693,
      327709,
      327683,
      327699,
      327691,
      327707,
      327687,
      327703,
      327695,
      0
    ]), 5];
    var FlateStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(FlateStream2, _super);
        function FlateStream2(stream, maybeLength) {
          var _this = _super.call(this, maybeLength) || this;
          _this.stream = stream;
          var cmf = stream.getByte();
          var flg = stream.getByte();
          if (cmf === -1 || flg === -1) {
            throw new Error("Invalid header in flate stream: " + cmf + ", " + flg);
          }
          if ((cmf & 15) !== 8) {
            throw new Error("Unknown compression method in flate stream: " + cmf + ", " + flg);
          }
          if (((cmf << 8) + flg) % 31 !== 0) {
            throw new Error("Bad FCHECK in flate stream: " + cmf + ", " + flg);
          }
          if (flg & 32) {
            throw new Error("FDICT bit set in flate stream: " + cmf + ", " + flg);
          }
          _this.codeSize = 0;
          _this.codeBuf = 0;
          return _this;
        }
        FlateStream2.prototype.readBlock = function() {
          var buffer;
          var len;
          var str = this.stream;
          var hdr = this.getBits(3);
          if (hdr & 1) {
            this.eof = true;
          }
          hdr >>= 1;
          if (hdr === 0) {
            var b = void 0;
            if ((b = str.getByte()) === -1) {
              throw new Error("Bad block header in flate stream");
            }
            var blockLen = b;
            if ((b = str.getByte()) === -1) {
              throw new Error("Bad block header in flate stream");
            }
            blockLen |= b << 8;
            if ((b = str.getByte()) === -1) {
              throw new Error("Bad block header in flate stream");
            }
            var check = b;
            if ((b = str.getByte()) === -1) {
              throw new Error("Bad block header in flate stream");
            }
            check |= b << 8;
            if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
              throw new Error("Bad uncompressed block length in flate stream");
            }
            this.codeBuf = 0;
            this.codeSize = 0;
            var bufferLength = this.bufferLength;
            buffer = this.ensureBuffer(bufferLength + blockLen);
            var end = bufferLength + blockLen;
            this.bufferLength = end;
            if (blockLen === 0) {
              if (str.peekByte() === -1) {
                this.eof = true;
              }
            } else {
              for (var n2 = bufferLength; n2 < end; ++n2) {
                if ((b = str.getByte()) === -1) {
                  this.eof = true;
                  break;
                }
                buffer[n2] = b;
              }
            }
            return;
          }
          var litCodeTable;
          var distCodeTable;
          if (hdr === 1) {
            litCodeTable = fixedLitCodeTab;
            distCodeTable = fixedDistCodeTab;
          } else if (hdr === 2) {
            var numLitCodes = this.getBits(5) + 257;
            var numDistCodes = this.getBits(5) + 1;
            var numCodeLenCodes = this.getBits(4) + 4;
            var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
            var i = void 0;
            for (i = 0; i < numCodeLenCodes; ++i) {
              codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
            }
            var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
            len = 0;
            i = 0;
            var codes = numLitCodes + numDistCodes;
            var codeLengths = new Uint8Array(codes);
            var bitsLength = void 0;
            var bitsOffset = void 0;
            var what = void 0;
            while (i < codes) {
              var code = this.getCode(codeLenCodeTab);
              if (code === 16) {
                bitsLength = 2;
                bitsOffset = 3;
                what = len;
              } else if (code === 17) {
                bitsLength = 3;
                bitsOffset = 3;
                what = len = 0;
              } else if (code === 18) {
                bitsLength = 7;
                bitsOffset = 11;
                what = len = 0;
              } else {
                codeLengths[i++] = len = code;
                continue;
              }
              var repeatLength = this.getBits(bitsLength) + bitsOffset;
              while (repeatLength-- > 0) {
                codeLengths[i++] = what;
              }
            }
            litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
            distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
          } else {
            throw new Error("Unknown block type in flate stream");
          }
          buffer = this.buffer;
          var limit = buffer ? buffer.length : 0;
          var pos = this.bufferLength;
          while (true) {
            var code1 = this.getCode(litCodeTable);
            if (code1 < 256) {
              if (pos + 1 >= limit) {
                buffer = this.ensureBuffer(pos + 1);
                limit = buffer.length;
              }
              buffer[pos++] = code1;
              continue;
            }
            if (code1 === 256) {
              this.bufferLength = pos;
              return;
            }
            code1 -= 257;
            code1 = lengthDecode[code1];
            var code2 = code1 >> 16;
            if (code2 > 0) {
              code2 = this.getBits(code2);
            }
            len = (code1 & 65535) + code2;
            code1 = this.getCode(distCodeTable);
            code1 = distDecode[code1];
            code2 = code1 >> 16;
            if (code2 > 0) {
              code2 = this.getBits(code2);
            }
            var dist = (code1 & 65535) + code2;
            if (pos + len >= limit) {
              buffer = this.ensureBuffer(pos + len);
              limit = buffer.length;
            }
            for (var k = 0; k < len; ++k, ++pos) {
              buffer[pos] = buffer[pos - dist];
            }
          }
        };
        FlateStream2.prototype.getBits = function(bits) {
          var str = this.stream;
          var codeSize = this.codeSize;
          var codeBuf = this.codeBuf;
          var b;
          while (codeSize < bits) {
            if ((b = str.getByte()) === -1) {
              throw new Error("Bad encoding in flate stream");
            }
            codeBuf |= b << codeSize;
            codeSize += 8;
          }
          b = codeBuf & (1 << bits) - 1;
          this.codeBuf = codeBuf >> bits;
          this.codeSize = codeSize -= bits;
          return b;
        };
        FlateStream2.prototype.getCode = function(table) {
          var str = this.stream;
          var codes = table[0];
          var maxLen = table[1];
          var codeSize = this.codeSize;
          var codeBuf = this.codeBuf;
          var b;
          while (codeSize < maxLen) {
            if ((b = str.getByte()) === -1) {
              break;
            }
            codeBuf |= b << codeSize;
            codeSize += 8;
          }
          var code = codes[codeBuf & (1 << maxLen) - 1];
          if (typeof codes === "number") {
            console.log("FLATE:", code);
          }
          var codeLen = code >> 16;
          var codeVal = code & 65535;
          if (codeLen < 1 || codeSize < codeLen) {
            throw new Error("Bad encoding in flate stream");
          }
          this.codeBuf = codeBuf >> codeLen;
          this.codeSize = codeSize - codeLen;
          return codeVal;
        };
        FlateStream2.prototype.generateHuffmanTable = function(lengths) {
          var n2 = lengths.length;
          var maxLen = 0;
          var i;
          for (i = 0; i < n2; ++i) {
            if (lengths[i] > maxLen) {
              maxLen = lengths[i];
            }
          }
          var size = 1 << maxLen;
          var codes = new Int32Array(size);
          for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
            for (var val = 0; val < n2; ++val) {
              if (lengths[val] === len) {
                var code2 = 0;
                var t2 = code;
                for (i = 0; i < len; ++i) {
                  code2 = code2 << 1 | t2 & 1;
                  t2 >>= 1;
                }
                for (i = code2; i < size; i += skip) {
                  codes[i] = len << 16 | val;
                }
                ++code;
              }
            }
          }
          return [codes, maxLen];
        };
        return FlateStream2;
      }(DecodeStream_1.default)
    );
    exports.default = FlateStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/streams/LZWStream.js
var require_LZWStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/streams/LZWStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var DecodeStream_1 = tslib_1.__importDefault(require_DecodeStream());
    var LZWStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(LZWStream2, _super);
        function LZWStream2(stream, maybeLength, earlyChange) {
          var _this = _super.call(this, maybeLength) || this;
          _this.stream = stream;
          _this.cachedData = 0;
          _this.bitsCached = 0;
          var maxLzwDictionarySize = 4096;
          var lzwState = {
            earlyChange,
            codeLength: 9,
            nextCode: 258,
            dictionaryValues: new Uint8Array(maxLzwDictionarySize),
            dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
            dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
            currentSequence: new Uint8Array(maxLzwDictionarySize),
            currentSequenceLength: 0
          };
          for (var i = 0; i < 256; ++i) {
            lzwState.dictionaryValues[i] = i;
            lzwState.dictionaryLengths[i] = 1;
          }
          _this.lzwState = lzwState;
          return _this;
        }
        LZWStream2.prototype.readBlock = function() {
          var blockSize = 512;
          var estimatedDecodedSize = blockSize * 2;
          var decodedSizeDelta = blockSize;
          var i;
          var j;
          var q;
          var lzwState = this.lzwState;
          if (!lzwState) {
            return;
          }
          var earlyChange = lzwState.earlyChange;
          var nextCode = lzwState.nextCode;
          var dictionaryValues = lzwState.dictionaryValues;
          var dictionaryLengths = lzwState.dictionaryLengths;
          var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
          var codeLength = lzwState.codeLength;
          var prevCode = lzwState.prevCode;
          var currentSequence = lzwState.currentSequence;
          var currentSequenceLength = lzwState.currentSequenceLength;
          var decodedLength = 0;
          var currentBufferLength = this.bufferLength;
          var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
          for (i = 0; i < blockSize; i++) {
            var code = this.readBits(codeLength);
            var hasPrev = currentSequenceLength > 0;
            if (!code || code < 256) {
              currentSequence[0] = code;
              currentSequenceLength = 1;
            } else if (code >= 258) {
              if (code < nextCode) {
                currentSequenceLength = dictionaryLengths[code];
                for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                  currentSequence[j] = dictionaryValues[q];
                  q = dictionaryPrevCodes[q];
                }
              } else {
                currentSequence[currentSequenceLength++] = currentSequence[0];
              }
            } else if (code === 256) {
              codeLength = 9;
              nextCode = 258;
              currentSequenceLength = 0;
              continue;
            } else {
              this.eof = true;
              delete this.lzwState;
              break;
            }
            if (hasPrev) {
              dictionaryPrevCodes[nextCode] = prevCode;
              dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
              dictionaryValues[nextCode] = currentSequence[0];
              nextCode++;
              codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
            }
            prevCode = code;
            decodedLength += currentSequenceLength;
            if (estimatedDecodedSize < decodedLength) {
              do {
                estimatedDecodedSize += decodedSizeDelta;
              } while (estimatedDecodedSize < decodedLength);
              buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
            }
            for (j = 0; j < currentSequenceLength; j++) {
              buffer[currentBufferLength++] = currentSequence[j];
            }
          }
          lzwState.nextCode = nextCode;
          lzwState.codeLength = codeLength;
          lzwState.prevCode = prevCode;
          lzwState.currentSequenceLength = currentSequenceLength;
          this.bufferLength = currentBufferLength;
        };
        LZWStream2.prototype.readBits = function(n2) {
          var bitsCached = this.bitsCached;
          var cachedData = this.cachedData;
          while (bitsCached < n2) {
            var c = this.stream.getByte();
            if (c === -1) {
              this.eof = true;
              return null;
            }
            cachedData = cachedData << 8 | c;
            bitsCached += 8;
          }
          this.bitsCached = bitsCached -= n2;
          this.cachedData = cachedData;
          return cachedData >>> bitsCached & (1 << n2) - 1;
        };
        return LZWStream2;
      }(DecodeStream_1.default)
    );
    exports.default = LZWStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/streams/RunLengthStream.js
var require_RunLengthStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/streams/RunLengthStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var DecodeStream_1 = tslib_1.__importDefault(require_DecodeStream());
    var RunLengthStream = (
      /** @class */
      function(_super) {
        tslib_1.__extends(RunLengthStream2, _super);
        function RunLengthStream2(stream, maybeLength) {
          var _this = _super.call(this, maybeLength) || this;
          _this.stream = stream;
          return _this;
        }
        RunLengthStream2.prototype.readBlock = function() {
          var repeatHeader = this.stream.getBytes(2);
          if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
            this.eof = true;
            return;
          }
          var buffer;
          var bufferLength = this.bufferLength;
          var n2 = repeatHeader[0];
          if (n2 < 128) {
            buffer = this.ensureBuffer(bufferLength + n2 + 1);
            buffer[bufferLength++] = repeatHeader[1];
            if (n2 > 0) {
              var source = this.stream.getBytes(n2);
              buffer.set(source, bufferLength);
              bufferLength += n2;
            }
          } else {
            n2 = 257 - n2;
            var b = repeatHeader[1];
            buffer = this.ensureBuffer(bufferLength + n2 + 1);
            for (var i = 0; i < n2; i++) {
              buffer[bufferLength++] = b;
            }
          }
          this.bufferLength = bufferLength;
        };
        return RunLengthStream2;
      }(DecodeStream_1.default)
    );
    exports.default = RunLengthStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/streams/decode.js
var require_decode = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/streams/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodePDFRawStream = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var Ascii85Stream_1 = tslib_1.__importDefault(require_Ascii85Stream());
    var AsciiHexStream_1 = tslib_1.__importDefault(require_AsciiHexStream());
    var FlateStream_1 = tslib_1.__importDefault(require_FlateStream());
    var LZWStream_1 = tslib_1.__importDefault(require_LZWStream());
    var RunLengthStream_1 = tslib_1.__importDefault(require_RunLengthStream());
    var Stream_1 = tslib_1.__importDefault(require_Stream());
    var decodeStream = function(stream, encoding, params) {
      if (encoding === PDFName_1.default.of("FlateDecode")) {
        return new FlateStream_1.default(stream);
      }
      if (encoding === PDFName_1.default.of("LZWDecode")) {
        var earlyChange = 1;
        if (params instanceof PDFDict_1.default) {
          var EarlyChange = params.lookup(PDFName_1.default.of("EarlyChange"));
          if (EarlyChange instanceof PDFNumber_1.default) {
            earlyChange = EarlyChange.asNumber();
          }
        }
        return new LZWStream_1.default(stream, void 0, earlyChange);
      }
      if (encoding === PDFName_1.default.of("ASCII85Decode")) {
        return new Ascii85Stream_1.default(stream);
      }
      if (encoding === PDFName_1.default.of("ASCIIHexDecode")) {
        return new AsciiHexStream_1.default(stream);
      }
      if (encoding === PDFName_1.default.of("RunLengthDecode")) {
        return new RunLengthStream_1.default(stream);
      }
      throw new errors_1.UnsupportedEncodingError(encoding.asString());
    };
    exports.decodePDFRawStream = function(_a) {
      var dict = _a.dict, contents = _a.contents;
      var stream = new Stream_1.default(contents);
      var Filter = dict.lookup(PDFName_1.default.of("Filter"));
      var DecodeParms = dict.lookup(PDFName_1.default.of("DecodeParms"));
      if (Filter instanceof PDFName_1.default) {
        stream = decodeStream(stream, Filter, DecodeParms);
      } else if (Filter instanceof PDFArray_1.default) {
        for (var idx = 0, len = Filter.size(); idx < len; idx++) {
          stream = decodeStream(stream, Filter.lookup(idx, PDFName_1.default), DecodeParms && DecodeParms.lookupMaybe(idx, PDFDict_1.default));
        }
      } else if (!!Filter) {
        throw new errors_1.UnexpectedObjectTypeError([PDFName_1.default, PDFArray_1.default], Filter);
      }
      return stream;
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/core/embedders/PDFPageEmbedder.js
var require_PDFPageEmbedder = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/embedders/PDFPageEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFRawStream_1 = tslib_1.__importDefault(require_PDFRawStream());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var decode_1 = require_decode();
    var PDFContentStream_1 = tslib_1.__importDefault(require_PDFContentStream());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var utils_1 = require_utils2();
    var fullPageBoundingBox = function(page) {
      var mediaBox = page.MediaBox();
      var width = mediaBox.lookup(2, PDFNumber_1.default).asNumber() - mediaBox.lookup(0, PDFNumber_1.default).asNumber();
      var height = mediaBox.lookup(3, PDFNumber_1.default).asNumber() - mediaBox.lookup(1, PDFNumber_1.default).asNumber();
      return { left: 0, bottom: 0, right: width, top: height };
    };
    var boundingBoxAdjustedMatrix = function(bb) {
      return [1, 0, 0, 1, -bb.left, -bb.bottom];
    };
    var PDFPageEmbedder = (
      /** @class */
      function() {
        function PDFPageEmbedder2(page, boundingBox, transformationMatrix) {
          this.page = page;
          var bb = boundingBox !== null && boundingBox !== void 0 ? boundingBox : fullPageBoundingBox(page);
          this.width = bb.right - bb.left;
          this.height = bb.top - bb.bottom;
          this.boundingBox = bb;
          this.transformationMatrix = transformationMatrix !== null && transformationMatrix !== void 0 ? transformationMatrix : boundingBoxAdjustedMatrix(bb);
        }
        PDFPageEmbedder2.for = function(page, boundingBox, transformationMatrix) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              return [2, new PDFPageEmbedder2(page, boundingBox, transformationMatrix)];
            });
          });
        };
        PDFPageEmbedder2.prototype.embedIntoContext = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, Contents, Resources, decodedContents, _b, left, bottom, right, top, xObject;
            return tslib_1.__generator(this, function(_c) {
              _a = this.page.normalizedEntries(), Contents = _a.Contents, Resources = _a.Resources;
              if (!Contents)
                throw new errors_1.MissingPageContentsEmbeddingError();
              decodedContents = this.decodeContents(Contents);
              _b = this.boundingBox, left = _b.left, bottom = _b.bottom, right = _b.right, top = _b.top;
              xObject = context.flateStream(decodedContents, {
                Type: "XObject",
                Subtype: "Form",
                FormType: 1,
                BBox: [left, bottom, right, top],
                Matrix: this.transformationMatrix,
                Resources
              });
              if (ref) {
                context.assign(ref, xObject);
                return [2, ref];
              } else {
                return [2, context.register(xObject)];
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        PDFPageEmbedder2.prototype.decodeContents = function(contents) {
          var newline = Uint8Array.of(CharCodes_1.default.Newline);
          var decodedContents = [];
          for (var idx = 0, len = contents.size(); idx < len; idx++) {
            var stream = contents.lookup(idx, PDFStream_1.default);
            var content = void 0;
            if (stream instanceof PDFRawStream_1.default) {
              content = decode_1.decodePDFRawStream(stream).decode();
            } else if (stream instanceof PDFContentStream_1.default) {
              content = stream.getUnencodedContents();
            } else {
              throw new errors_1.UnrecognizedStreamTypeError(stream);
            }
            decodedContents.push(content, newline);
          }
          return utils_1.mergeIntoTypedArray.apply(void 0, decodedContents);
        };
        return PDFPageEmbedder2;
      }()
    );
    exports.default = PDFPageEmbedder;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/interactive/ViewerPreferences.js
var require_ViewerPreferences = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/interactive/ViewerPreferences.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Duplex = exports.PrintScaling = exports.ReadingDirection = exports.NonFullScreenPageMode = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFBool_1 = tslib_1.__importDefault(require_PDFBool());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var utils_1 = require_utils2();
    var asEnum = function(rawValue, enumType) {
      if (rawValue === void 0)
        return void 0;
      return enumType[rawValue];
    };
    var NonFullScreenPageMode;
    (function(NonFullScreenPageMode2) {
      NonFullScreenPageMode2["UseNone"] = "UseNone";
      NonFullScreenPageMode2["UseOutlines"] = "UseOutlines";
      NonFullScreenPageMode2["UseThumbs"] = "UseThumbs";
      NonFullScreenPageMode2["UseOC"] = "UseOC";
    })(NonFullScreenPageMode = exports.NonFullScreenPageMode || (exports.NonFullScreenPageMode = {}));
    var ReadingDirection;
    (function(ReadingDirection2) {
      ReadingDirection2["L2R"] = "L2R";
      ReadingDirection2["R2L"] = "R2L";
    })(ReadingDirection = exports.ReadingDirection || (exports.ReadingDirection = {}));
    var PrintScaling;
    (function(PrintScaling2) {
      PrintScaling2["None"] = "None";
      PrintScaling2["AppDefault"] = "AppDefault";
    })(PrintScaling = exports.PrintScaling || (exports.PrintScaling = {}));
    var Duplex;
    (function(Duplex2) {
      Duplex2["Simplex"] = "Simplex";
      Duplex2["DuplexFlipShortEdge"] = "DuplexFlipShortEdge";
      Duplex2["DuplexFlipLongEdge"] = "DuplexFlipLongEdge";
    })(Duplex = exports.Duplex || (exports.Duplex = {}));
    var ViewerPreferences = (
      /** @class */
      function() {
        function ViewerPreferences2(dict) {
          this.dict = dict;
        }
        ViewerPreferences2.prototype.lookupBool = function(key) {
          var returnObj = this.dict.lookup(PDFName_1.default.of(key));
          if (returnObj instanceof PDFBool_1.default)
            return returnObj;
          return void 0;
        };
        ViewerPreferences2.prototype.lookupName = function(key) {
          var returnObj = this.dict.lookup(PDFName_1.default.of(key));
          if (returnObj instanceof PDFName_1.default)
            return returnObj;
          return void 0;
        };
        ViewerPreferences2.prototype.HideToolbar = function() {
          return this.lookupBool("HideToolbar");
        };
        ViewerPreferences2.prototype.HideMenubar = function() {
          return this.lookupBool("HideMenubar");
        };
        ViewerPreferences2.prototype.HideWindowUI = function() {
          return this.lookupBool("HideWindowUI");
        };
        ViewerPreferences2.prototype.FitWindow = function() {
          return this.lookupBool("FitWindow");
        };
        ViewerPreferences2.prototype.CenterWindow = function() {
          return this.lookupBool("CenterWindow");
        };
        ViewerPreferences2.prototype.DisplayDocTitle = function() {
          return this.lookupBool("DisplayDocTitle");
        };
        ViewerPreferences2.prototype.NonFullScreenPageMode = function() {
          return this.lookupName("NonFullScreenPageMode");
        };
        ViewerPreferences2.prototype.Direction = function() {
          return this.lookupName("Direction");
        };
        ViewerPreferences2.prototype.PrintScaling = function() {
          return this.lookupName("PrintScaling");
        };
        ViewerPreferences2.prototype.Duplex = function() {
          return this.lookupName("Duplex");
        };
        ViewerPreferences2.prototype.PickTrayByPDFSize = function() {
          return this.lookupBool("PickTrayByPDFSize");
        };
        ViewerPreferences2.prototype.PrintPageRange = function() {
          var PrintPageRange = this.dict.lookup(PDFName_1.default.of("PrintPageRange"));
          if (PrintPageRange instanceof PDFArray_1.default)
            return PrintPageRange;
          return void 0;
        };
        ViewerPreferences2.prototype.NumCopies = function() {
          var NumCopies = this.dict.lookup(PDFName_1.default.of("NumCopies"));
          if (NumCopies instanceof PDFNumber_1.default)
            return NumCopies;
          return void 0;
        };
        ViewerPreferences2.prototype.getHideToolbar = function() {
          var _a, _b;
          return (_b = (_a = this.HideToolbar()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getHideMenubar = function() {
          var _a, _b;
          return (_b = (_a = this.HideMenubar()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getHideWindowUI = function() {
          var _a, _b;
          return (_b = (_a = this.HideWindowUI()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getFitWindow = function() {
          var _a, _b;
          return (_b = (_a = this.FitWindow()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getCenterWindow = function() {
          var _a, _b;
          return (_b = (_a = this.CenterWindow()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getDisplayDocTitle = function() {
          var _a, _b;
          return (_b = (_a = this.DisplayDocTitle()) === null || _a === void 0 ? void 0 : _a.asBoolean()) !== null && _b !== void 0 ? _b : false;
        };
        ViewerPreferences2.prototype.getNonFullScreenPageMode = function() {
          var _a, _b;
          var mode = (_a = this.NonFullScreenPageMode()) === null || _a === void 0 ? void 0 : _a.decodeText();
          return (_b = asEnum(mode, NonFullScreenPageMode)) !== null && _b !== void 0 ? _b : NonFullScreenPageMode.UseNone;
        };
        ViewerPreferences2.prototype.getReadingDirection = function() {
          var _a, _b;
          var direction = (_a = this.Direction()) === null || _a === void 0 ? void 0 : _a.decodeText();
          return (_b = asEnum(direction, ReadingDirection)) !== null && _b !== void 0 ? _b : ReadingDirection.L2R;
        };
        ViewerPreferences2.prototype.getPrintScaling = function() {
          var _a, _b;
          var scaling = (_a = this.PrintScaling()) === null || _a === void 0 ? void 0 : _a.decodeText();
          return (_b = asEnum(scaling, PrintScaling)) !== null && _b !== void 0 ? _b : PrintScaling.AppDefault;
        };
        ViewerPreferences2.prototype.getDuplex = function() {
          var _a;
          var duplex = (_a = this.Duplex()) === null || _a === void 0 ? void 0 : _a.decodeText();
          return asEnum(duplex, Duplex);
        };
        ViewerPreferences2.prototype.getPickTrayByPDFSize = function() {
          var _a;
          return (_a = this.PickTrayByPDFSize()) === null || _a === void 0 ? void 0 : _a.asBoolean();
        };
        ViewerPreferences2.prototype.getPrintPageRange = function() {
          var rng2 = this.PrintPageRange();
          if (!rng2)
            return [];
          var pageRanges = [];
          for (var i = 0; i < rng2.size(); i += 2) {
            var start = rng2.lookup(i, PDFNumber_1.default).asNumber();
            var end = rng2.lookup(i + 1, PDFNumber_1.default).asNumber();
            pageRanges.push({ start, end });
          }
          return pageRanges;
        };
        ViewerPreferences2.prototype.getNumCopies = function() {
          var _a, _b;
          return (_b = (_a = this.NumCopies()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 1;
        };
        ViewerPreferences2.prototype.setHideToolbar = function(hideToolbar) {
          var HideToolbar = this.dict.context.obj(hideToolbar);
          this.dict.set(PDFName_1.default.of("HideToolbar"), HideToolbar);
        };
        ViewerPreferences2.prototype.setHideMenubar = function(hideMenubar) {
          var HideMenubar = this.dict.context.obj(hideMenubar);
          this.dict.set(PDFName_1.default.of("HideMenubar"), HideMenubar);
        };
        ViewerPreferences2.prototype.setHideWindowUI = function(hideWindowUI) {
          var HideWindowUI = this.dict.context.obj(hideWindowUI);
          this.dict.set(PDFName_1.default.of("HideWindowUI"), HideWindowUI);
        };
        ViewerPreferences2.prototype.setFitWindow = function(fitWindow) {
          var FitWindow = this.dict.context.obj(fitWindow);
          this.dict.set(PDFName_1.default.of("FitWindow"), FitWindow);
        };
        ViewerPreferences2.prototype.setCenterWindow = function(centerWindow) {
          var CenterWindow = this.dict.context.obj(centerWindow);
          this.dict.set(PDFName_1.default.of("CenterWindow"), CenterWindow);
        };
        ViewerPreferences2.prototype.setDisplayDocTitle = function(displayTitle) {
          var DisplayDocTitle = this.dict.context.obj(displayTitle);
          this.dict.set(PDFName_1.default.of("DisplayDocTitle"), DisplayDocTitle);
        };
        ViewerPreferences2.prototype.setNonFullScreenPageMode = function(nonFullScreenPageMode) {
          utils_1.assertIsOneOf(nonFullScreenPageMode, "nonFullScreenPageMode", NonFullScreenPageMode);
          var mode = PDFName_1.default.of(nonFullScreenPageMode);
          this.dict.set(PDFName_1.default.of("NonFullScreenPageMode"), mode);
        };
        ViewerPreferences2.prototype.setReadingDirection = function(readingDirection) {
          utils_1.assertIsOneOf(readingDirection, "readingDirection", ReadingDirection);
          var direction = PDFName_1.default.of(readingDirection);
          this.dict.set(PDFName_1.default.of("Direction"), direction);
        };
        ViewerPreferences2.prototype.setPrintScaling = function(printScaling) {
          utils_1.assertIsOneOf(printScaling, "printScaling", PrintScaling);
          var scaling = PDFName_1.default.of(printScaling);
          this.dict.set(PDFName_1.default.of("PrintScaling"), scaling);
        };
        ViewerPreferences2.prototype.setDuplex = function(duplex) {
          utils_1.assertIsOneOf(duplex, "duplex", Duplex);
          var dup = PDFName_1.default.of(duplex);
          this.dict.set(PDFName_1.default.of("Duplex"), dup);
        };
        ViewerPreferences2.prototype.setPickTrayByPDFSize = function(pickTrayByPDFSize) {
          var PickTrayByPDFSize = this.dict.context.obj(pickTrayByPDFSize);
          this.dict.set(PDFName_1.default.of("PickTrayByPDFSize"), PickTrayByPDFSize);
        };
        ViewerPreferences2.prototype.setPrintPageRange = function(printPageRange) {
          if (!Array.isArray(printPageRange))
            printPageRange = [printPageRange];
          var flatRange = [];
          for (var idx = 0, len = printPageRange.length; idx < len; idx++) {
            flatRange.push(printPageRange[idx].start);
            flatRange.push(printPageRange[idx].end);
          }
          utils_1.assertEachIs(flatRange, "printPageRange", ["number"]);
          var pageRanges = this.dict.context.obj(flatRange);
          this.dict.set(PDFName_1.default.of("PrintPageRange"), pageRanges);
        };
        ViewerPreferences2.prototype.setNumCopies = function(numCopies) {
          utils_1.assertRange(numCopies, "numCopies", 1, Number.MAX_VALUE);
          utils_1.assertInteger(numCopies, "numCopies");
          var NumCopies = this.dict.context.obj(numCopies);
          this.dict.set(PDFName_1.default.of("NumCopies"), NumCopies);
        };
        ViewerPreferences2.fromDict = function(dict) {
          return new ViewerPreferences2(dict);
        };
        ViewerPreferences2.create = function(context) {
          var dict = context.obj({});
          return new ViewerPreferences2(dict);
        };
        return ViewerPreferences2;
      }()
    );
    exports.default = ViewerPreferences;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroField.js
var require_PDFAcroField = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroField.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var utils_1 = require_utils2();
    var errors_1 = require_errors2();
    var tfRegex = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+Tf/;
    var PDFAcroField = (
      /** @class */
      function() {
        function PDFAcroField2(dict, ref) {
          this.dict = dict;
          this.ref = ref;
        }
        PDFAcroField2.prototype.T = function() {
          return this.dict.lookupMaybe(PDFName_1.default.of("T"), PDFString_1.default, PDFHexString_1.default);
        };
        PDFAcroField2.prototype.Ff = function() {
          var numberOrRef = this.getInheritableAttribute(PDFName_1.default.of("Ff"));
          return this.dict.context.lookupMaybe(numberOrRef, PDFNumber_1.default);
        };
        PDFAcroField2.prototype.V = function() {
          var valueOrRef = this.getInheritableAttribute(PDFName_1.default.of("V"));
          return this.dict.context.lookup(valueOrRef);
        };
        PDFAcroField2.prototype.Kids = function() {
          return this.dict.lookupMaybe(PDFName_1.default.of("Kids"), PDFArray_1.default);
        };
        PDFAcroField2.prototype.DA = function() {
          var da = this.dict.lookup(PDFName_1.default.of("DA"));
          if (da instanceof PDFString_1.default || da instanceof PDFHexString_1.default)
            return da;
          return void 0;
        };
        PDFAcroField2.prototype.setKids = function(kids) {
          this.dict.set(PDFName_1.default.of("Kids"), this.dict.context.obj(kids));
        };
        PDFAcroField2.prototype.getParent = function() {
          var parentRef = this.dict.get(PDFName_1.default.of("Parent"));
          if (parentRef instanceof PDFRef_1.default) {
            var parent_1 = this.dict.lookup(PDFName_1.default.of("Parent"), PDFDict_1.default);
            return new PDFAcroField2(parent_1, parentRef);
          }
          return void 0;
        };
        PDFAcroField2.prototype.setParent = function(parent) {
          if (!parent)
            this.dict.delete(PDFName_1.default.of("Parent"));
          else
            this.dict.set(PDFName_1.default.of("Parent"), parent);
        };
        PDFAcroField2.prototype.getFullyQualifiedName = function() {
          var parent = this.getParent();
          if (!parent)
            return this.getPartialName();
          return parent.getFullyQualifiedName() + "." + this.getPartialName();
        };
        PDFAcroField2.prototype.getPartialName = function() {
          var _a;
          return (_a = this.T()) === null || _a === void 0 ? void 0 : _a.decodeText();
        };
        PDFAcroField2.prototype.setPartialName = function(partialName) {
          if (!partialName)
            this.dict.delete(PDFName_1.default.of("T"));
          else
            this.dict.set(PDFName_1.default.of("T"), PDFHexString_1.default.fromText(partialName));
        };
        PDFAcroField2.prototype.setDefaultAppearance = function(appearance) {
          this.dict.set(PDFName_1.default.of("DA"), PDFString_1.default.of(appearance));
        };
        PDFAcroField2.prototype.getDefaultAppearance = function() {
          var DA = this.DA();
          if (DA instanceof PDFHexString_1.default) {
            return DA.decodeText();
          }
          return DA === null || DA === void 0 ? void 0 : DA.asString();
        };
        PDFAcroField2.prototype.setFontSize = function(fontSize) {
          var _a;
          var name = (_a = this.getFullyQualifiedName()) !== null && _a !== void 0 ? _a : "";
          var da = this.getDefaultAppearance();
          if (!da)
            throw new errors_1.MissingDAEntryError(name);
          var daMatch = utils_1.findLastMatch(da, tfRegex);
          if (!daMatch.match)
            throw new errors_1.MissingTfOperatorError(name);
          var daStart = da.slice(0, daMatch.pos - daMatch.match[0].length);
          var daEnd = daMatch.pos <= da.length ? da.slice(daMatch.pos) : "";
          var fontName = daMatch.match[1];
          var modifiedDa = daStart + " /" + fontName + " " + fontSize + " Tf " + daEnd;
          this.setDefaultAppearance(modifiedDa);
        };
        PDFAcroField2.prototype.getFlags = function() {
          var _a, _b;
          return (_b = (_a = this.Ff()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 0;
        };
        PDFAcroField2.prototype.setFlags = function(flags) {
          this.dict.set(PDFName_1.default.of("Ff"), PDFNumber_1.default.of(flags));
        };
        PDFAcroField2.prototype.hasFlag = function(flag) {
          var flags = this.getFlags();
          return (flags & flag) !== 0;
        };
        PDFAcroField2.prototype.setFlag = function(flag) {
          var flags = this.getFlags();
          this.setFlags(flags | flag);
        };
        PDFAcroField2.prototype.clearFlag = function(flag) {
          var flags = this.getFlags();
          this.setFlags(flags & ~flag);
        };
        PDFAcroField2.prototype.setFlagTo = function(flag, enable) {
          if (enable)
            this.setFlag(flag);
          else
            this.clearFlag(flag);
        };
        PDFAcroField2.prototype.getInheritableAttribute = function(name) {
          var attribute;
          this.ascend(function(node) {
            if (!attribute)
              attribute = node.dict.get(name);
          });
          return attribute;
        };
        PDFAcroField2.prototype.ascend = function(visitor) {
          visitor(this);
          var parent = this.getParent();
          if (parent)
            parent.ascend(visitor);
        };
        return PDFAcroField2;
      }()
    );
    exports.default = PDFAcroField;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/annotation/BorderStyle.js
var require_BorderStyle = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/annotation/BorderStyle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var BorderStyle = (
      /** @class */
      function() {
        function BorderStyle2(dict) {
          this.dict = dict;
        }
        BorderStyle2.prototype.W = function() {
          var W = this.dict.lookup(PDFName_1.default.of("W"));
          if (W instanceof PDFNumber_1.default)
            return W;
          return void 0;
        };
        BorderStyle2.prototype.getWidth = function() {
          var _a, _b;
          return (_b = (_a = this.W()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 1;
        };
        BorderStyle2.prototype.setWidth = function(width) {
          var W = this.dict.context.obj(width);
          this.dict.set(PDFName_1.default.of("W"), W);
        };
        BorderStyle2.fromDict = function(dict) {
          return new BorderStyle2(dict);
        };
        return BorderStyle2;
      }()
    );
    exports.default = BorderStyle;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/annotation/PDFAnnotation.js
var require_PDFAnnotation = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/annotation/PDFAnnotation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFStream_1 = tslib_1.__importDefault(require_PDFStream());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFAnnotation = (
      /** @class */
      function() {
        function PDFAnnotation2(dict) {
          this.dict = dict;
        }
        PDFAnnotation2.prototype.Rect = function() {
          return this.dict.lookup(PDFName_1.default.of("Rect"), PDFArray_1.default);
        };
        PDFAnnotation2.prototype.AP = function() {
          return this.dict.lookupMaybe(PDFName_1.default.of("AP"), PDFDict_1.default);
        };
        PDFAnnotation2.prototype.F = function() {
          var numberOrRef = this.dict.lookup(PDFName_1.default.of("F"));
          return this.dict.context.lookupMaybe(numberOrRef, PDFNumber_1.default);
        };
        PDFAnnotation2.prototype.getRectangle = function() {
          var _a;
          var Rect = this.Rect();
          return (_a = Rect === null || Rect === void 0 ? void 0 : Rect.asRectangle()) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: 0, height: 0 };
        };
        PDFAnnotation2.prototype.setRectangle = function(rect) {
          var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
          var Rect = this.dict.context.obj([x, y, x + width, y + height]);
          this.dict.set(PDFName_1.default.of("Rect"), Rect);
        };
        PDFAnnotation2.prototype.getAppearanceState = function() {
          var AS = this.dict.lookup(PDFName_1.default.of("AS"));
          if (AS instanceof PDFName_1.default)
            return AS;
          return void 0;
        };
        PDFAnnotation2.prototype.setAppearanceState = function(state) {
          this.dict.set(PDFName_1.default.of("AS"), state);
        };
        PDFAnnotation2.prototype.setAppearances = function(appearances) {
          this.dict.set(PDFName_1.default.of("AP"), appearances);
        };
        PDFAnnotation2.prototype.ensureAP = function() {
          var AP = this.AP();
          if (!AP) {
            AP = this.dict.context.obj({});
            this.dict.set(PDFName_1.default.of("AP"), AP);
          }
          return AP;
        };
        PDFAnnotation2.prototype.getNormalAppearance = function() {
          var AP = this.ensureAP();
          var N = AP.get(PDFName_1.default.of("N"));
          if (N instanceof PDFRef_1.default || N instanceof PDFDict_1.default)
            return N;
          throw new Error("Unexpected N type: " + (N === null || N === void 0 ? void 0 : N.constructor.name));
        };
        PDFAnnotation2.prototype.setNormalAppearance = function(appearance) {
          var AP = this.ensureAP();
          AP.set(PDFName_1.default.of("N"), appearance);
        };
        PDFAnnotation2.prototype.setRolloverAppearance = function(appearance) {
          var AP = this.ensureAP();
          AP.set(PDFName_1.default.of("R"), appearance);
        };
        PDFAnnotation2.prototype.setDownAppearance = function(appearance) {
          var AP = this.ensureAP();
          AP.set(PDFName_1.default.of("D"), appearance);
        };
        PDFAnnotation2.prototype.removeRolloverAppearance = function() {
          var AP = this.AP();
          AP === null || AP === void 0 ? void 0 : AP.delete(PDFName_1.default.of("R"));
        };
        PDFAnnotation2.prototype.removeDownAppearance = function() {
          var AP = this.AP();
          AP === null || AP === void 0 ? void 0 : AP.delete(PDFName_1.default.of("D"));
        };
        PDFAnnotation2.prototype.getAppearances = function() {
          var AP = this.AP();
          if (!AP)
            return void 0;
          var N = AP.lookup(PDFName_1.default.of("N"), PDFDict_1.default, PDFStream_1.default);
          var R = AP.lookupMaybe(PDFName_1.default.of("R"), PDFDict_1.default, PDFStream_1.default);
          var D = AP.lookupMaybe(PDFName_1.default.of("D"), PDFDict_1.default, PDFStream_1.default);
          return { normal: N, rollover: R, down: D };
        };
        PDFAnnotation2.prototype.getFlags = function() {
          var _a, _b;
          return (_b = (_a = this.F()) === null || _a === void 0 ? void 0 : _a.asNumber()) !== null && _b !== void 0 ? _b : 0;
        };
        PDFAnnotation2.prototype.setFlags = function(flags) {
          this.dict.set(PDFName_1.default.of("F"), PDFNumber_1.default.of(flags));
        };
        PDFAnnotation2.prototype.hasFlag = function(flag) {
          var flags = this.getFlags();
          return (flags & flag) !== 0;
        };
        PDFAnnotation2.prototype.setFlag = function(flag) {
          var flags = this.getFlags();
          this.setFlags(flags | flag);
        };
        PDFAnnotation2.prototype.clearFlag = function(flag) {
          var flags = this.getFlags();
          this.setFlags(flags & ~flag);
        };
        PDFAnnotation2.prototype.setFlagTo = function(flag, enable) {
          if (enable)
            this.setFlag(flag);
          else
            this.clearFlag(flag);
        };
        PDFAnnotation2.fromDict = function(dict) {
          return new PDFAnnotation2(dict);
        };
        return PDFAnnotation2;
      }()
    );
    exports.default = PDFAnnotation;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/annotation/AppearanceCharacteristics.js
var require_AppearanceCharacteristics = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/annotation/AppearanceCharacteristics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var AppearanceCharacteristics = (
      /** @class */
      function() {
        function AppearanceCharacteristics2(dict) {
          this.dict = dict;
        }
        AppearanceCharacteristics2.prototype.R = function() {
          var R = this.dict.lookup(PDFName_1.default.of("R"));
          if (R instanceof PDFNumber_1.default)
            return R;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.BC = function() {
          var BC = this.dict.lookup(PDFName_1.default.of("BC"));
          if (BC instanceof PDFArray_1.default)
            return BC;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.BG = function() {
          var BG = this.dict.lookup(PDFName_1.default.of("BG"));
          if (BG instanceof PDFArray_1.default)
            return BG;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.CA = function() {
          var CA = this.dict.lookup(PDFName_1.default.of("CA"));
          if (CA instanceof PDFHexString_1.default || CA instanceof PDFString_1.default)
            return CA;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.RC = function() {
          var RC = this.dict.lookup(PDFName_1.default.of("RC"));
          if (RC instanceof PDFHexString_1.default || RC instanceof PDFString_1.default)
            return RC;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.AC = function() {
          var AC = this.dict.lookup(PDFName_1.default.of("AC"));
          if (AC instanceof PDFHexString_1.default || AC instanceof PDFString_1.default)
            return AC;
          return void 0;
        };
        AppearanceCharacteristics2.prototype.getRotation = function() {
          var _a;
          return (_a = this.R()) === null || _a === void 0 ? void 0 : _a.asNumber();
        };
        AppearanceCharacteristics2.prototype.getBorderColor = function() {
          var BC = this.BC();
          if (!BC)
            return void 0;
          var components = [];
          for (var idx = 0, len = BC === null || BC === void 0 ? void 0 : BC.size(); idx < len; idx++) {
            var component = BC.get(idx);
            if (component instanceof PDFNumber_1.default)
              components.push(component.asNumber());
          }
          return components;
        };
        AppearanceCharacteristics2.prototype.getBackgroundColor = function() {
          var BG = this.BG();
          if (!BG)
            return void 0;
          var components = [];
          for (var idx = 0, len = BG === null || BG === void 0 ? void 0 : BG.size(); idx < len; idx++) {
            var component = BG.get(idx);
            if (component instanceof PDFNumber_1.default)
              components.push(component.asNumber());
          }
          return components;
        };
        AppearanceCharacteristics2.prototype.getCaptions = function() {
          var CA = this.CA();
          var RC = this.RC();
          var AC = this.AC();
          return {
            normal: CA === null || CA === void 0 ? void 0 : CA.decodeText(),
            rollover: RC === null || RC === void 0 ? void 0 : RC.decodeText(),
            down: AC === null || AC === void 0 ? void 0 : AC.decodeText()
          };
        };
        AppearanceCharacteristics2.prototype.setRotation = function(rotation) {
          var R = this.dict.context.obj(rotation);
          this.dict.set(PDFName_1.default.of("R"), R);
        };
        AppearanceCharacteristics2.prototype.setBorderColor = function(color) {
          var BC = this.dict.context.obj(color);
          this.dict.set(PDFName_1.default.of("BC"), BC);
        };
        AppearanceCharacteristics2.prototype.setBackgroundColor = function(color) {
          var BG = this.dict.context.obj(color);
          this.dict.set(PDFName_1.default.of("BG"), BG);
        };
        AppearanceCharacteristics2.prototype.setCaptions = function(captions) {
          var CA = PDFHexString_1.default.fromText(captions.normal);
          this.dict.set(PDFName_1.default.of("CA"), CA);
          if (captions.rollover) {
            var RC = PDFHexString_1.default.fromText(captions.rollover);
            this.dict.set(PDFName_1.default.of("RC"), RC);
          } else {
            this.dict.delete(PDFName_1.default.of("RC"));
          }
          if (captions.down) {
            var AC = PDFHexString_1.default.fromText(captions.down);
            this.dict.set(PDFName_1.default.of("AC"), AC);
          } else {
            this.dict.delete(PDFName_1.default.of("AC"));
          }
        };
        AppearanceCharacteristics2.fromDict = function(dict) {
          return new AppearanceCharacteristics2(dict);
        };
        return AppearanceCharacteristics2;
      }()
    );
    exports.default = AppearanceCharacteristics;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/annotation/PDFWidgetAnnotation.js
var require_PDFWidgetAnnotation = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/annotation/PDFWidgetAnnotation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var BorderStyle_1 = tslib_1.__importDefault(require_BorderStyle());
    var PDFAnnotation_1 = tslib_1.__importDefault(require_PDFAnnotation());
    var AppearanceCharacteristics_1 = tslib_1.__importDefault(require_AppearanceCharacteristics());
    var PDFWidgetAnnotation = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFWidgetAnnotation2, _super);
        function PDFWidgetAnnotation2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFWidgetAnnotation2.prototype.MK = function() {
          var MK = this.dict.lookup(PDFName_1.default.of("MK"));
          if (MK instanceof PDFDict_1.default)
            return MK;
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.BS = function() {
          var BS = this.dict.lookup(PDFName_1.default.of("BS"));
          if (BS instanceof PDFDict_1.default)
            return BS;
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.DA = function() {
          var da = this.dict.lookup(PDFName_1.default.of("DA"));
          if (da instanceof PDFString_1.default || da instanceof PDFHexString_1.default)
            return da;
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.P = function() {
          var P = this.dict.get(PDFName_1.default.of("P"));
          if (P instanceof PDFRef_1.default)
            return P;
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.setP = function(page) {
          this.dict.set(PDFName_1.default.of("P"), page);
        };
        PDFWidgetAnnotation2.prototype.setDefaultAppearance = function(appearance) {
          this.dict.set(PDFName_1.default.of("DA"), PDFString_1.default.of(appearance));
        };
        PDFWidgetAnnotation2.prototype.getDefaultAppearance = function() {
          var DA = this.DA();
          if (DA instanceof PDFHexString_1.default) {
            return DA.decodeText();
          }
          return DA === null || DA === void 0 ? void 0 : DA.asString();
        };
        PDFWidgetAnnotation2.prototype.getAppearanceCharacteristics = function() {
          var MK = this.MK();
          if (MK)
            return AppearanceCharacteristics_1.default.fromDict(MK);
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.getOrCreateAppearanceCharacteristics = function() {
          var MK = this.MK();
          if (MK)
            return AppearanceCharacteristics_1.default.fromDict(MK);
          var ac = AppearanceCharacteristics_1.default.fromDict(this.dict.context.obj({}));
          this.dict.set(PDFName_1.default.of("MK"), ac.dict);
          return ac;
        };
        PDFWidgetAnnotation2.prototype.getBorderStyle = function() {
          var BS = this.BS();
          if (BS)
            return BorderStyle_1.default.fromDict(BS);
          return void 0;
        };
        PDFWidgetAnnotation2.prototype.getOrCreateBorderStyle = function() {
          var BS = this.BS();
          if (BS)
            return BorderStyle_1.default.fromDict(BS);
          var bs = BorderStyle_1.default.fromDict(this.dict.context.obj({}));
          this.dict.set(PDFName_1.default.of("BS"), bs.dict);
          return bs;
        };
        PDFWidgetAnnotation2.prototype.getOnValue = function() {
          var _a;
          var normal = (_a = this.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
          if (normal instanceof PDFDict_1.default) {
            var keys = normal.keys();
            for (var idx = 0, len = keys.length; idx < len; idx++) {
              var key = keys[idx];
              if (key !== PDFName_1.default.of("Off"))
                return key;
            }
          }
          return void 0;
        };
        PDFWidgetAnnotation2.fromDict = function(dict) {
          return new PDFWidgetAnnotation2(dict);
        };
        PDFWidgetAnnotation2.create = function(context, parent) {
          var dict = context.obj({
            Type: "Annot",
            Subtype: "Widget",
            Rect: [0, 0, 0, 0],
            Parent: parent
          });
          return new PDFWidgetAnnotation2(dict);
        };
        return PDFWidgetAnnotation2;
      }(PDFAnnotation_1.default)
    );
    exports.default = PDFWidgetAnnotation;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroTerminal.js
var require_PDFAcroTerminal = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroTerminal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroField_1 = tslib_1.__importDefault(require_PDFAcroField());
    var PDFWidgetAnnotation_1 = tslib_1.__importDefault(require_PDFWidgetAnnotation());
    var errors_1 = require_errors2();
    var PDFAcroTerminal = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroTerminal2, _super);
        function PDFAcroTerminal2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroTerminal2.prototype.FT = function() {
          var nameOrRef = this.getInheritableAttribute(PDFName_1.default.of("FT"));
          return this.dict.context.lookup(nameOrRef, PDFName_1.default);
        };
        PDFAcroTerminal2.prototype.getWidgets = function() {
          var kidDicts = this.Kids();
          if (!kidDicts)
            return [PDFWidgetAnnotation_1.default.fromDict(this.dict)];
          var widgets = new Array(kidDicts.size());
          for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {
            var dict = kidDicts.lookup(idx, PDFDict_1.default);
            widgets[idx] = PDFWidgetAnnotation_1.default.fromDict(dict);
          }
          return widgets;
        };
        PDFAcroTerminal2.prototype.addWidget = function(ref) {
          var Kids = this.normalizedEntries().Kids;
          Kids.push(ref);
        };
        PDFAcroTerminal2.prototype.removeWidget = function(idx) {
          var kidDicts = this.Kids();
          if (!kidDicts) {
            if (idx !== 0)
              throw new errors_1.IndexOutOfBoundsError(idx, 0, 0);
            this.setKids([]);
          } else {
            if (idx < 0 || idx > kidDicts.size()) {
              throw new errors_1.IndexOutOfBoundsError(idx, 0, kidDicts.size());
            }
            kidDicts.remove(idx);
          }
        };
        PDFAcroTerminal2.prototype.normalizedEntries = function() {
          var Kids = this.Kids();
          if (!Kids) {
            Kids = this.dict.context.obj([this.ref]);
            this.dict.set(PDFName_1.default.of("Kids"), Kids);
          }
          return { Kids };
        };
        PDFAcroTerminal2.fromDict = function(dict, ref) {
          return new PDFAcroTerminal2(dict, ref);
        };
        return PDFAcroTerminal2;
      }(PDFAcroField_1.default)
    );
    exports.default = PDFAcroTerminal;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroButton.js
var require_PDFAcroButton = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroButton.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroTerminal_1 = tslib_1.__importDefault(require_PDFAcroTerminal());
    var errors_1 = require_errors2();
    var PDFAcroButton = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroButton2, _super);
        function PDFAcroButton2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroButton2.prototype.Opt = function() {
          return this.dict.lookupMaybe(PDFName_1.default.of("Opt"), PDFString_1.default, PDFHexString_1.default, PDFArray_1.default);
        };
        PDFAcroButton2.prototype.setOpt = function(opt) {
          this.dict.set(PDFName_1.default.of("Opt"), this.dict.context.obj(opt));
        };
        PDFAcroButton2.prototype.getExportValues = function() {
          var opt = this.Opt();
          if (!opt)
            return void 0;
          if (opt instanceof PDFString_1.default || opt instanceof PDFHexString_1.default) {
            return [opt];
          }
          var values = [];
          for (var idx = 0, len = opt.size(); idx < len; idx++) {
            var value = opt.lookup(idx);
            if (value instanceof PDFString_1.default || value instanceof PDFHexString_1.default) {
              values.push(value);
            }
          }
          return values;
        };
        PDFAcroButton2.prototype.removeExportValue = function(idx) {
          var opt = this.Opt();
          if (!opt)
            return;
          if (opt instanceof PDFString_1.default || opt instanceof PDFHexString_1.default) {
            if (idx !== 0)
              throw new errors_1.IndexOutOfBoundsError(idx, 0, 0);
            this.setOpt([]);
          } else {
            if (idx < 0 || idx > opt.size()) {
              throw new errors_1.IndexOutOfBoundsError(idx, 0, opt.size());
            }
            opt.remove(idx);
          }
        };
        PDFAcroButton2.prototype.normalizeExportValues = function() {
          var _a, _b, _c, _d;
          var exportValues = (_a = this.getExportValues()) !== null && _a !== void 0 ? _a : [];
          var Opt = [];
          var widgets = this.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var exportVal = (_b = exportValues[idx]) !== null && _b !== void 0 ? _b : PDFHexString_1.default.fromText((_d = (_c = widget.getOnValue()) === null || _c === void 0 ? void 0 : _c.decodeText()) !== null && _d !== void 0 ? _d : "");
            Opt.push(exportVal);
          }
          this.setOpt(Opt);
        };
        PDFAcroButton2.prototype.addOpt = function(opt, useExistingOptIdx) {
          var _a;
          this.normalizeExportValues();
          var optText = opt.decodeText();
          var existingIdx;
          if (useExistingOptIdx) {
            var exportValues = (_a = this.getExportValues()) !== null && _a !== void 0 ? _a : [];
            for (var idx = 0, len = exportValues.length; idx < len; idx++) {
              var exportVal = exportValues[idx];
              if (exportVal.decodeText() === optText)
                existingIdx = idx;
            }
          }
          var Opt = this.Opt();
          Opt.push(opt);
          return existingIdx !== null && existingIdx !== void 0 ? existingIdx : Opt.size() - 1;
        };
        PDFAcroButton2.prototype.addWidgetWithOpt = function(widget, opt, useExistingOptIdx) {
          var optIdx = this.addOpt(opt, useExistingOptIdx);
          var apStateValue = PDFName_1.default.of(String(optIdx));
          this.addWidget(widget);
          return apStateValue;
        };
        return PDFAcroButton2;
      }(PDFAcroTerminal_1.default)
    );
    exports.default = PDFAcroButton;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroCheckBox.js
var require_PDFAcroCheckBox = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroCheckBox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroButton_1 = tslib_1.__importDefault(require_PDFAcroButton());
    var errors_1 = require_errors2();
    var PDFAcroCheckBox = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroCheckBox2, _super);
        function PDFAcroCheckBox2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroCheckBox2.prototype.setValue = function(value) {
          var _a;
          var onValue = (_a = this.getOnValue()) !== null && _a !== void 0 ? _a : PDFName_1.default.of("Yes");
          if (value !== onValue && value !== PDFName_1.default.of("Off")) {
            throw new errors_1.InvalidAcroFieldValueError();
          }
          this.dict.set(PDFName_1.default.of("V"), value);
          var widgets = this.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var state = widget.getOnValue() === value ? value : PDFName_1.default.of("Off");
            widget.setAppearanceState(state);
          }
        };
        PDFAcroCheckBox2.prototype.getValue = function() {
          var v = this.V();
          if (v instanceof PDFName_1.default)
            return v;
          return PDFName_1.default.of("Off");
        };
        PDFAcroCheckBox2.prototype.getOnValue = function() {
          var widget = this.getWidgets()[0];
          return widget === null || widget === void 0 ? void 0 : widget.getOnValue();
        };
        PDFAcroCheckBox2.fromDict = function(dict, ref) {
          return new PDFAcroCheckBox2(dict, ref);
        };
        PDFAcroCheckBox2.create = function(context) {
          var dict = context.obj({
            FT: "Btn",
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroCheckBox2(dict, ref);
        };
        return PDFAcroCheckBox2;
      }(PDFAcroButton_1.default)
    );
    exports.default = PDFAcroCheckBox;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/flags.js
var require_flags = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/flags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AcroChoiceFlags = exports.AcroTextFlags = exports.AcroButtonFlags = exports.AcroFieldFlags = void 0;
    var flag = function(bitIndex) {
      return 1 << bitIndex;
    };
    var AcroFieldFlags;
    (function(AcroFieldFlags2) {
      AcroFieldFlags2[AcroFieldFlags2["ReadOnly"] = flag(1 - 1)] = "ReadOnly";
      AcroFieldFlags2[AcroFieldFlags2["Required"] = flag(2 - 1)] = "Required";
      AcroFieldFlags2[AcroFieldFlags2["NoExport"] = flag(3 - 1)] = "NoExport";
    })(AcroFieldFlags = exports.AcroFieldFlags || (exports.AcroFieldFlags = {}));
    var AcroButtonFlags;
    (function(AcroButtonFlags2) {
      AcroButtonFlags2[AcroButtonFlags2["NoToggleToOff"] = flag(15 - 1)] = "NoToggleToOff";
      AcroButtonFlags2[AcroButtonFlags2["Radio"] = flag(16 - 1)] = "Radio";
      AcroButtonFlags2[AcroButtonFlags2["PushButton"] = flag(17 - 1)] = "PushButton";
      AcroButtonFlags2[AcroButtonFlags2["RadiosInUnison"] = flag(26 - 1)] = "RadiosInUnison";
    })(AcroButtonFlags = exports.AcroButtonFlags || (exports.AcroButtonFlags = {}));
    var AcroTextFlags;
    (function(AcroTextFlags2) {
      AcroTextFlags2[AcroTextFlags2["Multiline"] = flag(13 - 1)] = "Multiline";
      AcroTextFlags2[AcroTextFlags2["Password"] = flag(14 - 1)] = "Password";
      AcroTextFlags2[AcroTextFlags2["FileSelect"] = flag(21 - 1)] = "FileSelect";
      AcroTextFlags2[AcroTextFlags2["DoNotSpellCheck"] = flag(23 - 1)] = "DoNotSpellCheck";
      AcroTextFlags2[AcroTextFlags2["DoNotScroll"] = flag(24 - 1)] = "DoNotScroll";
      AcroTextFlags2[AcroTextFlags2["Comb"] = flag(25 - 1)] = "Comb";
      AcroTextFlags2[AcroTextFlags2["RichText"] = flag(26 - 1)] = "RichText";
    })(AcroTextFlags = exports.AcroTextFlags || (exports.AcroTextFlags = {}));
    var AcroChoiceFlags;
    (function(AcroChoiceFlags2) {
      AcroChoiceFlags2[AcroChoiceFlags2["Combo"] = flag(18 - 1)] = "Combo";
      AcroChoiceFlags2[AcroChoiceFlags2["Edit"] = flag(19 - 1)] = "Edit";
      AcroChoiceFlags2[AcroChoiceFlags2["Sort"] = flag(20 - 1)] = "Sort";
      AcroChoiceFlags2[AcroChoiceFlags2["MultiSelect"] = flag(22 - 1)] = "MultiSelect";
      AcroChoiceFlags2[AcroChoiceFlags2["DoNotSpellCheck"] = flag(23 - 1)] = "DoNotSpellCheck";
      AcroChoiceFlags2[AcroChoiceFlags2["CommitOnSelChange"] = flag(27 - 1)] = "CommitOnSelChange";
    })(AcroChoiceFlags = exports.AcroChoiceFlags || (exports.AcroChoiceFlags = {}));
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroChoice.js
var require_PDFAcroChoice = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroChoice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroTerminal_1 = tslib_1.__importDefault(require_PDFAcroTerminal());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var flags_1 = require_flags();
    var errors_1 = require_errors2();
    var PDFAcroChoice = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroChoice2, _super);
        function PDFAcroChoice2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroChoice2.prototype.setValues = function(values) {
          if (this.hasFlag(flags_1.AcroChoiceFlags.Combo) && !this.hasFlag(flags_1.AcroChoiceFlags.Edit) && !this.valuesAreValid(values)) {
            throw new errors_1.InvalidAcroFieldValueError();
          }
          if (values.length === 0) {
            this.dict.delete(PDFName_1.default.of("V"));
          }
          if (values.length === 1) {
            this.dict.set(PDFName_1.default.of("V"), values[0]);
          }
          if (values.length > 1) {
            if (!this.hasFlag(flags_1.AcroChoiceFlags.MultiSelect)) {
              throw new errors_1.MultiSelectValueError();
            }
            this.dict.set(PDFName_1.default.of("V"), this.dict.context.obj(values));
          }
          this.updateSelectedIndices(values);
        };
        PDFAcroChoice2.prototype.valuesAreValid = function(values) {
          var options = this.getOptions();
          var _loop_1 = function(idx2, len2) {
            var val = values[idx2].decodeText();
            if (!options.find(function(o) {
              return val === (o.display || o.value).decodeText();
            })) {
              return { value: false };
            }
          };
          for (var idx = 0, len = values.length; idx < len; idx++) {
            var state_1 = _loop_1(idx, len);
            if (typeof state_1 === "object")
              return state_1.value;
          }
          return true;
        };
        PDFAcroChoice2.prototype.updateSelectedIndices = function(values) {
          if (values.length > 1) {
            var indices = new Array(values.length);
            var options = this.getOptions();
            var _loop_2 = function(idx2, len2) {
              var val = values[idx2].decodeText();
              indices[idx2] = options.findIndex(function(o) {
                return val === (o.display || o.value).decodeText();
              });
            };
            for (var idx = 0, len = values.length; idx < len; idx++) {
              _loop_2(idx, len);
            }
            this.dict.set(PDFName_1.default.of("I"), this.dict.context.obj(indices.sort()));
          } else {
            this.dict.delete(PDFName_1.default.of("I"));
          }
        };
        PDFAcroChoice2.prototype.getValues = function() {
          var v = this.V();
          if (v instanceof PDFString_1.default || v instanceof PDFHexString_1.default)
            return [v];
          if (v instanceof PDFArray_1.default) {
            var values = [];
            for (var idx = 0, len = v.size(); idx < len; idx++) {
              var value = v.lookup(idx);
              if (value instanceof PDFString_1.default || value instanceof PDFHexString_1.default) {
                values.push(value);
              }
            }
            return values;
          }
          return [];
        };
        PDFAcroChoice2.prototype.Opt = function() {
          return this.dict.lookupMaybe(PDFName_1.default.of("Opt"), PDFString_1.default, PDFHexString_1.default, PDFArray_1.default);
        };
        PDFAcroChoice2.prototype.setOptions = function(options) {
          var newOpt = new Array(options.length);
          for (var idx = 0, len = options.length; idx < len; idx++) {
            var _a = options[idx], value = _a.value, display = _a.display;
            newOpt[idx] = this.dict.context.obj([value, display || value]);
          }
          this.dict.set(PDFName_1.default.of("Opt"), this.dict.context.obj(newOpt));
        };
        PDFAcroChoice2.prototype.getOptions = function() {
          var Opt = this.Opt();
          if (Opt instanceof PDFString_1.default || Opt instanceof PDFHexString_1.default) {
            return [{ value: Opt, display: Opt }];
          }
          if (Opt instanceof PDFArray_1.default) {
            var res = [];
            for (var idx = 0, len = Opt.size(); idx < len; idx++) {
              var item = Opt.lookup(idx);
              if (item instanceof PDFString_1.default || item instanceof PDFHexString_1.default) {
                res.push({ value: item, display: item });
              }
              if (item instanceof PDFArray_1.default) {
                if (item.size() > 0) {
                  var first = item.lookup(0, PDFString_1.default, PDFHexString_1.default);
                  var second = item.lookupMaybe(1, PDFString_1.default, PDFHexString_1.default);
                  res.push({ value: first, display: second || first });
                }
              }
            }
            return res;
          }
          return [];
        };
        return PDFAcroChoice2;
      }(PDFAcroTerminal_1.default)
    );
    exports.default = PDFAcroChoice;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroComboBox.js
var require_PDFAcroComboBox = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroComboBox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroChoice_1 = tslib_1.__importDefault(require_PDFAcroChoice());
    var flags_1 = require_flags();
    var PDFAcroComboBox = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroComboBox2, _super);
        function PDFAcroComboBox2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroComboBox2.fromDict = function(dict, ref) {
          return new PDFAcroComboBox2(dict, ref);
        };
        PDFAcroComboBox2.create = function(context) {
          var dict = context.obj({
            FT: "Ch",
            Ff: flags_1.AcroChoiceFlags.Combo,
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroComboBox2(dict, ref);
        };
        return PDFAcroComboBox2;
      }(PDFAcroChoice_1.default)
    );
    exports.default = PDFAcroComboBox;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroNonTerminal.js
var require_PDFAcroNonTerminal = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroNonTerminal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroField_1 = tslib_1.__importDefault(require_PDFAcroField());
    var PDFAcroNonTerminal = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroNonTerminal2, _super);
        function PDFAcroNonTerminal2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroNonTerminal2.prototype.addField = function(field) {
          var Kids = this.normalizedEntries().Kids;
          Kids === null || Kids === void 0 ? void 0 : Kids.push(field);
        };
        PDFAcroNonTerminal2.prototype.normalizedEntries = function() {
          var Kids = this.Kids();
          if (!Kids) {
            Kids = this.dict.context.obj([]);
            this.dict.set(PDFName_1.default.of("Kids"), Kids);
          }
          return { Kids };
        };
        PDFAcroNonTerminal2.fromDict = function(dict, ref) {
          return new PDFAcroNonTerminal2(dict, ref);
        };
        PDFAcroNonTerminal2.create = function(context) {
          var dict = context.obj({});
          var ref = context.register(dict);
          return new PDFAcroNonTerminal2(dict, ref);
        };
        return PDFAcroNonTerminal2;
      }(PDFAcroField_1.default)
    );
    exports.default = PDFAcroNonTerminal;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroSignature.js
var require_PDFAcroSignature = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroSignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroTerminal_1 = tslib_1.__importDefault(require_PDFAcroTerminal());
    var PDFAcroSignature = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroSignature2, _super);
        function PDFAcroSignature2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroSignature2.fromDict = function(dict, ref) {
          return new PDFAcroSignature2(dict, ref);
        };
        return PDFAcroSignature2;
      }(PDFAcroTerminal_1.default)
    );
    exports.default = PDFAcroSignature;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroText.js
var require_PDFAcroText = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroText.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroTerminal_1 = tslib_1.__importDefault(require_PDFAcroTerminal());
    var PDFAcroText = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroText2, _super);
        function PDFAcroText2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroText2.prototype.MaxLen = function() {
          var maxLen = this.dict.lookup(PDFName_1.default.of("MaxLen"));
          if (maxLen instanceof PDFNumber_1.default)
            return maxLen;
          return void 0;
        };
        PDFAcroText2.prototype.Q = function() {
          var q = this.dict.lookup(PDFName_1.default.of("Q"));
          if (q instanceof PDFNumber_1.default)
            return q;
          return void 0;
        };
        PDFAcroText2.prototype.setMaxLength = function(maxLength) {
          this.dict.set(PDFName_1.default.of("MaxLen"), PDFNumber_1.default.of(maxLength));
        };
        PDFAcroText2.prototype.removeMaxLength = function() {
          this.dict.delete(PDFName_1.default.of("MaxLen"));
        };
        PDFAcroText2.prototype.getMaxLength = function() {
          var _a;
          return (_a = this.MaxLen()) === null || _a === void 0 ? void 0 : _a.asNumber();
        };
        PDFAcroText2.prototype.setQuadding = function(quadding) {
          this.dict.set(PDFName_1.default.of("Q"), PDFNumber_1.default.of(quadding));
        };
        PDFAcroText2.prototype.getQuadding = function() {
          var _a;
          return (_a = this.Q()) === null || _a === void 0 ? void 0 : _a.asNumber();
        };
        PDFAcroText2.prototype.setValue = function(value) {
          this.dict.set(PDFName_1.default.of("V"), value);
        };
        PDFAcroText2.prototype.removeValue = function() {
          this.dict.delete(PDFName_1.default.of("V"));
        };
        PDFAcroText2.prototype.getValue = function() {
          var v = this.V();
          if (v instanceof PDFString_1.default || v instanceof PDFHexString_1.default)
            return v;
          return void 0;
        };
        PDFAcroText2.fromDict = function(dict, ref) {
          return new PDFAcroText2(dict, ref);
        };
        PDFAcroText2.create = function(context) {
          var dict = context.obj({
            FT: "Tx",
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroText2(dict, ref);
        };
        return PDFAcroText2;
      }(PDFAcroTerminal_1.default)
    );
    exports.default = PDFAcroText;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroPushButton.js
var require_PDFAcroPushButton = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroPushButton.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroButton_1 = tslib_1.__importDefault(require_PDFAcroButton());
    var flags_1 = require_flags();
    var PDFAcroPushButton = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroPushButton2, _super);
        function PDFAcroPushButton2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroPushButton2.fromDict = function(dict, ref) {
          return new PDFAcroPushButton2(dict, ref);
        };
        PDFAcroPushButton2.create = function(context) {
          var dict = context.obj({
            FT: "Btn",
            Ff: flags_1.AcroButtonFlags.PushButton,
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroPushButton2(dict, ref);
        };
        return PDFAcroPushButton2;
      }(PDFAcroButton_1.default)
    );
    exports.default = PDFAcroPushButton;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroRadioButton.js
var require_PDFAcroRadioButton = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroRadioButton.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroButton_1 = tslib_1.__importDefault(require_PDFAcroButton());
    var flags_1 = require_flags();
    var errors_1 = require_errors2();
    var PDFAcroRadioButton = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroRadioButton2, _super);
        function PDFAcroRadioButton2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroRadioButton2.prototype.setValue = function(value) {
          var onValues = this.getOnValues();
          if (!onValues.includes(value) && value !== PDFName_1.default.of("Off")) {
            throw new errors_1.InvalidAcroFieldValueError();
          }
          this.dict.set(PDFName_1.default.of("V"), value);
          var widgets = this.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var state = widget.getOnValue() === value ? value : PDFName_1.default.of("Off");
            widget.setAppearanceState(state);
          }
        };
        PDFAcroRadioButton2.prototype.getValue = function() {
          var v = this.V();
          if (v instanceof PDFName_1.default)
            return v;
          return PDFName_1.default.of("Off");
        };
        PDFAcroRadioButton2.prototype.getOnValues = function() {
          var widgets = this.getWidgets();
          var onValues = [];
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var onValue = widgets[idx].getOnValue();
            if (onValue)
              onValues.push(onValue);
          }
          return onValues;
        };
        PDFAcroRadioButton2.fromDict = function(dict, ref) {
          return new PDFAcroRadioButton2(dict, ref);
        };
        PDFAcroRadioButton2.create = function(context) {
          var dict = context.obj({
            FT: "Btn",
            Ff: flags_1.AcroButtonFlags.Radio,
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroRadioButton2(dict, ref);
        };
        return PDFAcroRadioButton2;
      }(PDFAcroButton_1.default)
    );
    exports.default = PDFAcroRadioButton;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroListBox.js
var require_PDFAcroListBox = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroListBox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroChoice_1 = tslib_1.__importDefault(require_PDFAcroChoice());
    var PDFAcroListBox = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFAcroListBox2, _super);
        function PDFAcroListBox2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFAcroListBox2.fromDict = function(dict, ref) {
          return new PDFAcroListBox2(dict, ref);
        };
        PDFAcroListBox2.create = function(context) {
          var dict = context.obj({
            FT: "Ch",
            Kids: []
          });
          var ref = context.register(dict);
          return new PDFAcroListBox2(dict, ref);
        };
        return PDFAcroListBox2;
      }(PDFAcroChoice_1.default)
    );
    exports.default = PDFAcroListBox;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/utils.js
var require_utils3 = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPDFAcroField = exports.createPDFAcroFields = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFAcroTerminal_1 = tslib_1.__importDefault(require_PDFAcroTerminal());
    var PDFAcroNonTerminal_1 = tslib_1.__importDefault(require_PDFAcroNonTerminal());
    var PDFAcroSignature_1 = tslib_1.__importDefault(require_PDFAcroSignature());
    var PDFAcroText_1 = tslib_1.__importDefault(require_PDFAcroText());
    var PDFAcroPushButton_1 = tslib_1.__importDefault(require_PDFAcroPushButton());
    var PDFAcroRadioButton_1 = tslib_1.__importDefault(require_PDFAcroRadioButton());
    var PDFAcroCheckBox_1 = tslib_1.__importDefault(require_PDFAcroCheckBox());
    var PDFAcroComboBox_1 = tslib_1.__importDefault(require_PDFAcroComboBox());
    var PDFAcroListBox_1 = tslib_1.__importDefault(require_PDFAcroListBox());
    var flags_1 = require_flags();
    exports.createPDFAcroFields = function(kidDicts) {
      if (!kidDicts)
        return [];
      var kids = [];
      for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {
        var ref = kidDicts.get(idx);
        var dict = kidDicts.lookup(idx);
        if (ref instanceof PDFRef_1.default && dict instanceof PDFDict_1.default) {
          kids.push([exports.createPDFAcroField(dict, ref), ref]);
        }
      }
      return kids;
    };
    exports.createPDFAcroField = function(dict, ref) {
      var isNonTerminal = isNonTerminalAcroField(dict);
      if (isNonTerminal)
        return PDFAcroNonTerminal_1.default.fromDict(dict, ref);
      return createPDFAcroTerminal(dict, ref);
    };
    var isNonTerminalAcroField = function(dict) {
      var kids = dict.lookup(PDFName_1.default.of("Kids"));
      if (kids instanceof PDFArray_1.default) {
        for (var idx = 0, len = kids.size(); idx < len; idx++) {
          var kid = kids.lookup(idx);
          var kidIsField = kid instanceof PDFDict_1.default && kid.has(PDFName_1.default.of("T"));
          if (kidIsField)
            return true;
        }
      }
      return false;
    };
    var createPDFAcroTerminal = function(dict, ref) {
      var ftNameOrRef = getInheritableAttribute(dict, PDFName_1.default.of("FT"));
      var type = dict.context.lookup(ftNameOrRef, PDFName_1.default);
      if (type === PDFName_1.default.of("Btn"))
        return createPDFAcroButton(dict, ref);
      if (type === PDFName_1.default.of("Ch"))
        return createPDFAcroChoice(dict, ref);
      if (type === PDFName_1.default.of("Tx"))
        return PDFAcroText_1.default.fromDict(dict, ref);
      if (type === PDFName_1.default.of("Sig"))
        return PDFAcroSignature_1.default.fromDict(dict, ref);
      return PDFAcroTerminal_1.default.fromDict(dict, ref);
    };
    var createPDFAcroButton = function(dict, ref) {
      var _a;
      var ffNumberOrRef = getInheritableAttribute(dict, PDFName_1.default.of("Ff"));
      var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber_1.default);
      var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;
      if (flagIsSet(flags, flags_1.AcroButtonFlags.PushButton)) {
        return PDFAcroPushButton_1.default.fromDict(dict, ref);
      } else if (flagIsSet(flags, flags_1.AcroButtonFlags.Radio)) {
        return PDFAcroRadioButton_1.default.fromDict(dict, ref);
      } else {
        return PDFAcroCheckBox_1.default.fromDict(dict, ref);
      }
    };
    var createPDFAcroChoice = function(dict, ref) {
      var _a;
      var ffNumberOrRef = getInheritableAttribute(dict, PDFName_1.default.of("Ff"));
      var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber_1.default);
      var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;
      if (flagIsSet(flags, flags_1.AcroChoiceFlags.Combo)) {
        return PDFAcroComboBox_1.default.fromDict(dict, ref);
      } else {
        return PDFAcroListBox_1.default.fromDict(dict, ref);
      }
    };
    var flagIsSet = function(flags, flag) {
      return (flags & flag) !== 0;
    };
    var getInheritableAttribute = function(startNode, name) {
      var attribute;
      ascend(startNode, function(node) {
        if (!attribute)
          attribute = node.get(name);
      });
      return attribute;
    };
    var ascend = function(startNode, visitor) {
      visitor(startNode);
      var Parent = startNode.lookupMaybe(PDFName_1.default.of("Parent"), PDFDict_1.default);
      if (Parent)
        ascend(Parent, visitor);
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroForm.js
var require_PDFAcroForm = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/PDFAcroForm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFAcroNonTerminal_1 = tslib_1.__importDefault(require_PDFAcroNonTerminal());
    var utils_1 = require_utils3();
    var PDFAcroForm = (
      /** @class */
      function() {
        function PDFAcroForm2(dict) {
          this.dict = dict;
        }
        PDFAcroForm2.prototype.Fields = function() {
          var fields = this.dict.lookup(PDFName_1.default.of("Fields"));
          if (fields instanceof PDFArray_1.default)
            return fields;
          return void 0;
        };
        PDFAcroForm2.prototype.getFields = function() {
          var Fields = this.normalizedEntries().Fields;
          var fields = new Array(Fields.size());
          for (var idx = 0, len = Fields.size(); idx < len; idx++) {
            var ref = Fields.get(idx);
            var dict = Fields.lookup(idx, PDFDict_1.default);
            fields[idx] = [utils_1.createPDFAcroField(dict, ref), ref];
          }
          return fields;
        };
        PDFAcroForm2.prototype.getAllFields = function() {
          var allFields = [];
          var pushFields = function(fields) {
            if (!fields)
              return;
            for (var idx = 0, len = fields.length; idx < len; idx++) {
              var field = fields[idx];
              allFields.push(field);
              var fieldModel = field[0];
              if (fieldModel instanceof PDFAcroNonTerminal_1.default) {
                pushFields(utils_1.createPDFAcroFields(fieldModel.Kids()));
              }
            }
          };
          pushFields(this.getFields());
          return allFields;
        };
        PDFAcroForm2.prototype.addField = function(field) {
          var Fields = this.normalizedEntries().Fields;
          Fields === null || Fields === void 0 ? void 0 : Fields.push(field);
        };
        PDFAcroForm2.prototype.removeField = function(field) {
          var parent = field.getParent();
          var fields = parent === void 0 ? this.normalizedEntries().Fields : parent.Kids();
          var index2 = fields === null || fields === void 0 ? void 0 : fields.indexOf(field.ref);
          if (fields === void 0 || index2 === void 0) {
            throw new Error("Tried to remove inexistent field " + field.getFullyQualifiedName());
          }
          fields.remove(index2);
          if (parent !== void 0 && fields.size() === 0) {
            this.removeField(parent);
          }
        };
        PDFAcroForm2.prototype.normalizedEntries = function() {
          var Fields = this.Fields();
          if (!Fields) {
            Fields = this.dict.context.obj([]);
            this.dict.set(PDFName_1.default.of("Fields"), Fields);
          }
          return { Fields };
        };
        PDFAcroForm2.fromDict = function(dict) {
          return new PDFAcroForm2(dict);
        };
        PDFAcroForm2.create = function(context) {
          var dict = context.obj({ Fields: [] });
          return new PDFAcroForm2(dict);
        };
        return PDFAcroForm2;
      }()
    );
    exports.default = PDFAcroForm;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/acroform/index.js
var require_acroform = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/acroform/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAcroButton_1 = require_PDFAcroButton();
    Object.defineProperty(exports, "PDFAcroButton", { enumerable: true, get: function() {
      return PDFAcroButton_1.default;
    } });
    var PDFAcroCheckBox_1 = require_PDFAcroCheckBox();
    Object.defineProperty(exports, "PDFAcroCheckBox", { enumerable: true, get: function() {
      return PDFAcroCheckBox_1.default;
    } });
    var PDFAcroChoice_1 = require_PDFAcroChoice();
    Object.defineProperty(exports, "PDFAcroChoice", { enumerable: true, get: function() {
      return PDFAcroChoice_1.default;
    } });
    var PDFAcroComboBox_1 = require_PDFAcroComboBox();
    Object.defineProperty(exports, "PDFAcroComboBox", { enumerable: true, get: function() {
      return PDFAcroComboBox_1.default;
    } });
    var PDFAcroField_1 = require_PDFAcroField();
    Object.defineProperty(exports, "PDFAcroField", { enumerable: true, get: function() {
      return PDFAcroField_1.default;
    } });
    var PDFAcroForm_1 = require_PDFAcroForm();
    Object.defineProperty(exports, "PDFAcroForm", { enumerable: true, get: function() {
      return PDFAcroForm_1.default;
    } });
    var PDFAcroListBox_1 = require_PDFAcroListBox();
    Object.defineProperty(exports, "PDFAcroListBox", { enumerable: true, get: function() {
      return PDFAcroListBox_1.default;
    } });
    var PDFAcroNonTerminal_1 = require_PDFAcroNonTerminal();
    Object.defineProperty(exports, "PDFAcroNonTerminal", { enumerable: true, get: function() {
      return PDFAcroNonTerminal_1.default;
    } });
    var PDFAcroPushButton_1 = require_PDFAcroPushButton();
    Object.defineProperty(exports, "PDFAcroPushButton", { enumerable: true, get: function() {
      return PDFAcroPushButton_1.default;
    } });
    var PDFAcroRadioButton_1 = require_PDFAcroRadioButton();
    Object.defineProperty(exports, "PDFAcroRadioButton", { enumerable: true, get: function() {
      return PDFAcroRadioButton_1.default;
    } });
    var PDFAcroSignature_1 = require_PDFAcroSignature();
    Object.defineProperty(exports, "PDFAcroSignature", { enumerable: true, get: function() {
      return PDFAcroSignature_1.default;
    } });
    var PDFAcroTerminal_1 = require_PDFAcroTerminal();
    Object.defineProperty(exports, "PDFAcroTerminal", { enumerable: true, get: function() {
      return PDFAcroTerminal_1.default;
    } });
    var PDFAcroText_1 = require_PDFAcroText();
    Object.defineProperty(exports, "PDFAcroText", { enumerable: true, get: function() {
      return PDFAcroText_1.default;
    } });
    tslib_1.__exportStar(require_flags(), exports);
    tslib_1.__exportStar(require_utils3(), exports);
  }
});

// ../../../node_modules/pdf-lib/cjs/core/structures/PDFCatalog.js
var require_PDFCatalog = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/structures/PDFCatalog.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var acroform_1 = require_acroform();
    var ViewerPreferences_1 = tslib_1.__importDefault(require_ViewerPreferences());
    var PDFCatalog = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFCatalog2, _super);
        function PDFCatalog2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFCatalog2.prototype.Pages = function() {
          return this.lookup(PDFName_1.default.of("Pages"), PDFDict_1.default);
        };
        PDFCatalog2.prototype.AcroForm = function() {
          return this.lookupMaybe(PDFName_1.default.of("AcroForm"), PDFDict_1.default);
        };
        PDFCatalog2.prototype.getAcroForm = function() {
          var dict = this.AcroForm();
          if (!dict)
            return void 0;
          return acroform_1.PDFAcroForm.fromDict(dict);
        };
        PDFCatalog2.prototype.getOrCreateAcroForm = function() {
          var acroForm = this.getAcroForm();
          if (!acroForm) {
            acroForm = acroform_1.PDFAcroForm.create(this.context);
            var acroFormRef = this.context.register(acroForm.dict);
            this.set(PDFName_1.default.of("AcroForm"), acroFormRef);
          }
          return acroForm;
        };
        PDFCatalog2.prototype.ViewerPreferences = function() {
          return this.lookupMaybe(PDFName_1.default.of("ViewerPreferences"), PDFDict_1.default);
        };
        PDFCatalog2.prototype.getViewerPreferences = function() {
          var dict = this.ViewerPreferences();
          if (!dict)
            return void 0;
          return ViewerPreferences_1.default.fromDict(dict);
        };
        PDFCatalog2.prototype.getOrCreateViewerPreferences = function() {
          var viewerPrefs = this.getViewerPreferences();
          if (!viewerPrefs) {
            viewerPrefs = ViewerPreferences_1.default.create(this.context);
            var viewerPrefsRef = this.context.register(viewerPrefs.dict);
            this.set(PDFName_1.default.of("ViewerPreferences"), viewerPrefsRef);
          }
          return viewerPrefs;
        };
        PDFCatalog2.prototype.insertLeafNode = function(leafRef, index2) {
          var pagesRef = this.get(PDFName_1.default.of("Pages"));
          var maybeParentRef = this.Pages().insertLeafNode(leafRef, index2);
          return maybeParentRef || pagesRef;
        };
        PDFCatalog2.prototype.removeLeafNode = function(index2) {
          this.Pages().removeLeafNode(index2);
        };
        PDFCatalog2.withContextAndPages = function(context, pages) {
          var dict = /* @__PURE__ */ new Map();
          dict.set(PDFName_1.default.of("Type"), PDFName_1.default.of("Catalog"));
          dict.set(PDFName_1.default.of("Pages"), pages);
          return new PDFCatalog2(dict, context);
        };
        PDFCatalog2.fromMapWithContext = function(map, context) {
          return new PDFCatalog2(map, context);
        };
        return PDFCatalog2;
      }(PDFDict_1.default)
    );
    exports.default = PDFCatalog;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/structures/PDFPageTree.js
var require_PDFPageTree = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/structures/PDFPageTree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFPageLeaf_1 = tslib_1.__importDefault(require_PDFPageLeaf());
    var errors_1 = require_errors2();
    var PDFPageTree = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFPageTree2, _super);
        function PDFPageTree2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        PDFPageTree2.prototype.Parent = function() {
          return this.lookup(PDFName_1.default.of("Parent"));
        };
        PDFPageTree2.prototype.Kids = function() {
          return this.lookup(PDFName_1.default.of("Kids"), PDFArray_1.default);
        };
        PDFPageTree2.prototype.Count = function() {
          return this.lookup(PDFName_1.default.of("Count"), PDFNumber_1.default);
        };
        PDFPageTree2.prototype.pushTreeNode = function(treeRef) {
          var Kids = this.Kids();
          Kids.push(treeRef);
        };
        PDFPageTree2.prototype.pushLeafNode = function(leafRef) {
          var Kids = this.Kids();
          this.insertLeafKid(Kids.size(), leafRef);
        };
        PDFPageTree2.prototype.insertLeafNode = function(leafRef, targetIndex) {
          var Kids = this.Kids();
          var Count = this.Count().asNumber();
          if (targetIndex > Count) {
            throw new errors_1.InvalidTargetIndexError(targetIndex, Count);
          }
          var leafsRemainingUntilTarget = targetIndex;
          for (var idx = 0, len = Kids.size(); idx < len; idx++) {
            if (leafsRemainingUntilTarget === 0) {
              this.insertLeafKid(idx, leafRef);
              return void 0;
            }
            var kidRef = Kids.get(idx);
            var kid = this.context.lookup(kidRef);
            if (kid instanceof PDFPageTree2) {
              if (kid.Count().asNumber() > leafsRemainingUntilTarget) {
                return kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef;
              } else {
                leafsRemainingUntilTarget -= kid.Count().asNumber();
              }
            }
            if (kid instanceof PDFPageLeaf_1.default) {
              leafsRemainingUntilTarget -= 1;
            }
          }
          if (leafsRemainingUntilTarget === 0) {
            this.insertLeafKid(Kids.size(), leafRef);
            return void 0;
          }
          throw new errors_1.CorruptPageTreeError(targetIndex, "insertLeafNode");
        };
        PDFPageTree2.prototype.removeLeafNode = function(targetIndex, prune) {
          if (prune === void 0) {
            prune = true;
          }
          var Kids = this.Kids();
          var Count = this.Count().asNumber();
          if (targetIndex >= Count) {
            throw new errors_1.InvalidTargetIndexError(targetIndex, Count);
          }
          var leafsRemainingUntilTarget = targetIndex;
          for (var idx = 0, len = Kids.size(); idx < len; idx++) {
            var kidRef = Kids.get(idx);
            var kid = this.context.lookup(kidRef);
            if (kid instanceof PDFPageTree2) {
              if (kid.Count().asNumber() > leafsRemainingUntilTarget) {
                kid.removeLeafNode(leafsRemainingUntilTarget, prune);
                if (prune && kid.Kids().size() === 0)
                  Kids.remove(idx);
                return;
              } else {
                leafsRemainingUntilTarget -= kid.Count().asNumber();
              }
            }
            if (kid instanceof PDFPageLeaf_1.default) {
              if (leafsRemainingUntilTarget === 0) {
                this.removeKid(idx);
                return;
              } else {
                leafsRemainingUntilTarget -= 1;
              }
            }
          }
          throw new errors_1.CorruptPageTreeError(targetIndex, "removeLeafNode");
        };
        PDFPageTree2.prototype.ascend = function(visitor) {
          visitor(this);
          var Parent = this.Parent();
          if (Parent)
            Parent.ascend(visitor);
        };
        PDFPageTree2.prototype.traverse = function(visitor) {
          var Kids = this.Kids();
          for (var idx = 0, len = Kids.size(); idx < len; idx++) {
            var kidRef = Kids.get(idx);
            var kid = this.context.lookup(kidRef);
            if (kid instanceof PDFPageTree2)
              kid.traverse(visitor);
            visitor(kid, kidRef);
          }
        };
        PDFPageTree2.prototype.insertLeafKid = function(kidIdx, leafRef) {
          var Kids = this.Kids();
          this.ascend(function(node) {
            var newCount = node.Count().asNumber() + 1;
            node.set(PDFName_1.default.of("Count"), PDFNumber_1.default.of(newCount));
          });
          Kids.insert(kidIdx, leafRef);
        };
        PDFPageTree2.prototype.removeKid = function(kidIdx) {
          var Kids = this.Kids();
          var kid = Kids.lookup(kidIdx);
          if (kid instanceof PDFPageLeaf_1.default) {
            this.ascend(function(node) {
              var newCount = node.Count().asNumber() - 1;
              node.set(PDFName_1.default.of("Count"), PDFNumber_1.default.of(newCount));
            });
          }
          Kids.remove(kidIdx);
        };
        PDFPageTree2.withContext = function(context, parent) {
          var dict = /* @__PURE__ */ new Map();
          dict.set(PDFName_1.default.of("Type"), PDFName_1.default.of("Pages"));
          dict.set(PDFName_1.default.of("Kids"), context.obj([]));
          dict.set(PDFName_1.default.of("Count"), context.obj(0));
          if (parent)
            dict.set(PDFName_1.default.of("Parent"), parent);
          return new PDFPageTree2(dict, context);
        };
        PDFPageTree2.fromMapWithContext = function(map, context) {
          return new PDFPageTree2(map, context);
        };
        return PDFPageTree2;
      }(PDFDict_1.default)
    );
    exports.default = PDFPageTree;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/syntax/Numeric.js
var require_Numeric = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/syntax/Numeric.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsNumeric = exports.IsNumericPrefix = exports.IsDigit = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    exports.IsDigit = new Uint8Array(256);
    exports.IsDigit[CharCodes_1.default.Zero] = 1;
    exports.IsDigit[CharCodes_1.default.One] = 1;
    exports.IsDigit[CharCodes_1.default.Two] = 1;
    exports.IsDigit[CharCodes_1.default.Three] = 1;
    exports.IsDigit[CharCodes_1.default.Four] = 1;
    exports.IsDigit[CharCodes_1.default.Five] = 1;
    exports.IsDigit[CharCodes_1.default.Six] = 1;
    exports.IsDigit[CharCodes_1.default.Seven] = 1;
    exports.IsDigit[CharCodes_1.default.Eight] = 1;
    exports.IsDigit[CharCodes_1.default.Nine] = 1;
    exports.IsNumericPrefix = new Uint8Array(256);
    exports.IsNumericPrefix[CharCodes_1.default.Period] = 1;
    exports.IsNumericPrefix[CharCodes_1.default.Plus] = 1;
    exports.IsNumericPrefix[CharCodes_1.default.Minus] = 1;
    exports.IsNumeric = new Uint8Array(256);
    for (idx = 0, len = 256; idx < len; idx++) {
      exports.IsNumeric[idx] = exports.IsDigit[idx] || exports.IsNumericPrefix[idx] ? 1 : 0;
    }
    var idx;
    var len;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/parser/BaseParser.js
var require_BaseParser = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/parser/BaseParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Numeric_1 = require_Numeric();
    var Whitespace_1 = require_Whitespace();
    var utils_1 = require_utils2();
    var Newline = CharCodes_1.default.Newline;
    var CarriageReturn = CharCodes_1.default.CarriageReturn;
    var BaseParser = (
      /** @class */
      function() {
        function BaseParser2(bytes, capNumbers) {
          if (capNumbers === void 0) {
            capNumbers = false;
          }
          this.bytes = bytes;
          this.capNumbers = capNumbers;
        }
        BaseParser2.prototype.parseRawInt = function() {
          var value = "";
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (!Numeric_1.IsDigit[byte])
              break;
            value += utils_1.charFromCode(this.bytes.next());
          }
          var numberValue = Number(value);
          if (!value || !isFinite(numberValue)) {
            throw new errors_1.NumberParsingError(this.bytes.position(), value);
          }
          return numberValue;
        };
        BaseParser2.prototype.parseRawNumber = function() {
          var value = "";
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (!Numeric_1.IsNumeric[byte])
              break;
            value += utils_1.charFromCode(this.bytes.next());
            if (byte === CharCodes_1.default.Period)
              break;
          }
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (!Numeric_1.IsDigit[byte])
              break;
            value += utils_1.charFromCode(this.bytes.next());
          }
          var numberValue = Number(value);
          if (!value || !isFinite(numberValue)) {
            throw new errors_1.NumberParsingError(this.bytes.position(), value);
          }
          if (numberValue > Number.MAX_SAFE_INTEGER) {
            if (this.capNumbers) {
              var msg = "Parsed number that is too large for some PDF readers: " + value + ", using Number.MAX_SAFE_INTEGER instead.";
              console.warn(msg);
              return Number.MAX_SAFE_INTEGER;
            } else {
              var msg = "Parsed number that is too large for some PDF readers: " + value + ", not capping.";
              console.warn(msg);
            }
          }
          return numberValue;
        };
        BaseParser2.prototype.skipWhitespace = function() {
          while (!this.bytes.done() && Whitespace_1.IsWhitespace[this.bytes.peek()]) {
            this.bytes.next();
          }
        };
        BaseParser2.prototype.skipLine = function() {
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (byte === Newline || byte === CarriageReturn)
              return;
            this.bytes.next();
          }
        };
        BaseParser2.prototype.skipComment = function() {
          if (this.bytes.peek() !== CharCodes_1.default.Percent)
            return false;
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (byte === Newline || byte === CarriageReturn)
              return true;
            this.bytes.next();
          }
          return true;
        };
        BaseParser2.prototype.skipWhitespaceAndComments = function() {
          this.skipWhitespace();
          while (this.skipComment())
            this.skipWhitespace();
        };
        BaseParser2.prototype.matchKeyword = function(keyword) {
          var initialOffset = this.bytes.offset();
          for (var idx = 0, len = keyword.length; idx < len; idx++) {
            if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {
              this.bytes.moveTo(initialOffset);
              return false;
            }
          }
          return true;
        };
        return BaseParser2;
      }()
    );
    exports.default = BaseParser;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/parser/ByteStream.js
var require_ByteStream = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/parser/ByteStream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var decode_1 = require_decode();
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var ByteStream = (
      /** @class */
      function() {
        function ByteStream2(bytes) {
          this.idx = 0;
          this.line = 0;
          this.column = 0;
          this.bytes = bytes;
          this.length = this.bytes.length;
        }
        ByteStream2.prototype.moveTo = function(offset2) {
          this.idx = offset2;
        };
        ByteStream2.prototype.next = function() {
          var byte = this.bytes[this.idx++];
          if (byte === CharCodes_1.default.Newline) {
            this.line += 1;
            this.column = 0;
          } else {
            this.column += 1;
          }
          return byte;
        };
        ByteStream2.prototype.assertNext = function(expected) {
          if (this.peek() !== expected) {
            throw new errors_1.NextByteAssertionError(this.position(), expected, this.peek());
          }
          return this.next();
        };
        ByteStream2.prototype.peek = function() {
          return this.bytes[this.idx];
        };
        ByteStream2.prototype.peekAhead = function(steps) {
          return this.bytes[this.idx + steps];
        };
        ByteStream2.prototype.peekAt = function(offset2) {
          return this.bytes[offset2];
        };
        ByteStream2.prototype.done = function() {
          return this.idx >= this.length;
        };
        ByteStream2.prototype.offset = function() {
          return this.idx;
        };
        ByteStream2.prototype.slice = function(start, end) {
          return this.bytes.slice(start, end);
        };
        ByteStream2.prototype.position = function() {
          return { line: this.line, column: this.column, offset: this.idx };
        };
        ByteStream2.of = function(bytes) {
          return new ByteStream2(bytes);
        };
        ByteStream2.fromPDFRawStream = function(rawStream) {
          return ByteStream2.of(decode_1.decodePDFRawStream(rawStream).decode());
        };
        return ByteStream2;
      }()
    );
    exports.default = ByteStream;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/syntax/Keywords.js
var require_Keywords = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/syntax/Keywords.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Keywords = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Space = CharCodes_1.default.Space;
    var CarriageReturn = CharCodes_1.default.CarriageReturn;
    var Newline = CharCodes_1.default.Newline;
    var stream = [
      CharCodes_1.default.s,
      CharCodes_1.default.t,
      CharCodes_1.default.r,
      CharCodes_1.default.e,
      CharCodes_1.default.a,
      CharCodes_1.default.m
    ];
    var endstream = [
      CharCodes_1.default.e,
      CharCodes_1.default.n,
      CharCodes_1.default.d,
      CharCodes_1.default.s,
      CharCodes_1.default.t,
      CharCodes_1.default.r,
      CharCodes_1.default.e,
      CharCodes_1.default.a,
      CharCodes_1.default.m
    ];
    exports.Keywords = {
      header: [
        CharCodes_1.default.Percent,
        CharCodes_1.default.P,
        CharCodes_1.default.D,
        CharCodes_1.default.F,
        CharCodes_1.default.Dash
      ],
      eof: [
        CharCodes_1.default.Percent,
        CharCodes_1.default.Percent,
        CharCodes_1.default.E,
        CharCodes_1.default.O,
        CharCodes_1.default.F
      ],
      obj: [CharCodes_1.default.o, CharCodes_1.default.b, CharCodes_1.default.j],
      endobj: [
        CharCodes_1.default.e,
        CharCodes_1.default.n,
        CharCodes_1.default.d,
        CharCodes_1.default.o,
        CharCodes_1.default.b,
        CharCodes_1.default.j
      ],
      xref: [CharCodes_1.default.x, CharCodes_1.default.r, CharCodes_1.default.e, CharCodes_1.default.f],
      trailer: [
        CharCodes_1.default.t,
        CharCodes_1.default.r,
        CharCodes_1.default.a,
        CharCodes_1.default.i,
        CharCodes_1.default.l,
        CharCodes_1.default.e,
        CharCodes_1.default.r
      ],
      startxref: [
        CharCodes_1.default.s,
        CharCodes_1.default.t,
        CharCodes_1.default.a,
        CharCodes_1.default.r,
        CharCodes_1.default.t,
        CharCodes_1.default.x,
        CharCodes_1.default.r,
        CharCodes_1.default.e,
        CharCodes_1.default.f
      ],
      true: [CharCodes_1.default.t, CharCodes_1.default.r, CharCodes_1.default.u, CharCodes_1.default.e],
      false: [CharCodes_1.default.f, CharCodes_1.default.a, CharCodes_1.default.l, CharCodes_1.default.s, CharCodes_1.default.e],
      null: [CharCodes_1.default.n, CharCodes_1.default.u, CharCodes_1.default.l, CharCodes_1.default.l],
      stream,
      streamEOF1: tslib_1.__spreadArrays(stream, [Space, CarriageReturn, Newline]),
      streamEOF2: tslib_1.__spreadArrays(stream, [CarriageReturn, Newline]),
      streamEOF3: tslib_1.__spreadArrays(stream, [CarriageReturn]),
      streamEOF4: tslib_1.__spreadArrays(stream, [Newline]),
      endstream,
      EOF1endstream: tslib_1.__spreadArrays([CarriageReturn, Newline], endstream),
      EOF2endstream: tslib_1.__spreadArrays([CarriageReturn], endstream),
      EOF3endstream: tslib_1.__spreadArrays([Newline], endstream)
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/core/parser/PDFObjectParser.js
var require_PDFObjectParser = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/parser/PDFObjectParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFBool_1 = tslib_1.__importDefault(require_PDFBool());
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNull_1 = tslib_1.__importDefault(require_PDFNull());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFRawStream_1 = tslib_1.__importDefault(require_PDFRawStream());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var PDFString_1 = tslib_1.__importDefault(require_PDFString());
    var BaseParser_1 = tslib_1.__importDefault(require_BaseParser());
    var ByteStream_1 = tslib_1.__importDefault(require_ByteStream());
    var PDFCatalog_1 = tslib_1.__importDefault(require_PDFCatalog());
    var PDFPageLeaf_1 = tslib_1.__importDefault(require_PDFPageLeaf());
    var PDFPageTree_1 = tslib_1.__importDefault(require_PDFPageTree());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Delimiters_1 = require_Delimiters();
    var Keywords_1 = require_Keywords();
    var Numeric_1 = require_Numeric();
    var Whitespace_1 = require_Whitespace();
    var utils_1 = require_utils2();
    var PDFObjectParser = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFObjectParser2, _super);
        function PDFObjectParser2(byteStream, context, capNumbers) {
          if (capNumbers === void 0) {
            capNumbers = false;
          }
          var _this = _super.call(this, byteStream, capNumbers) || this;
          _this.context = context;
          return _this;
        }
        PDFObjectParser2.prototype.parseObject = function() {
          this.skipWhitespaceAndComments();
          if (this.matchKeyword(Keywords_1.Keywords.true))
            return PDFBool_1.default.True;
          if (this.matchKeyword(Keywords_1.Keywords.false))
            return PDFBool_1.default.False;
          if (this.matchKeyword(Keywords_1.Keywords.null))
            return PDFNull_1.default;
          var byte = this.bytes.peek();
          if (byte === CharCodes_1.default.LessThan && this.bytes.peekAhead(1) === CharCodes_1.default.LessThan) {
            return this.parseDictOrStream();
          }
          if (byte === CharCodes_1.default.LessThan)
            return this.parseHexString();
          if (byte === CharCodes_1.default.LeftParen)
            return this.parseString();
          if (byte === CharCodes_1.default.ForwardSlash)
            return this.parseName();
          if (byte === CharCodes_1.default.LeftSquareBracket)
            return this.parseArray();
          if (Numeric_1.IsNumeric[byte])
            return this.parseNumberOrRef();
          throw new errors_1.PDFObjectParsingError(this.bytes.position(), byte);
        };
        PDFObjectParser2.prototype.parseNumberOrRef = function() {
          var firstNum = this.parseRawNumber();
          this.skipWhitespaceAndComments();
          var lookaheadStart = this.bytes.offset();
          if (Numeric_1.IsDigit[this.bytes.peek()]) {
            var secondNum = this.parseRawNumber();
            this.skipWhitespaceAndComments();
            if (this.bytes.peek() === CharCodes_1.default.R) {
              this.bytes.assertNext(CharCodes_1.default.R);
              return PDFRef_1.default.of(firstNum, secondNum);
            }
          }
          this.bytes.moveTo(lookaheadStart);
          return PDFNumber_1.default.of(firstNum);
        };
        PDFObjectParser2.prototype.parseHexString = function() {
          var value = "";
          this.bytes.assertNext(CharCodes_1.default.LessThan);
          while (!this.bytes.done() && this.bytes.peek() !== CharCodes_1.default.GreaterThan) {
            value += utils_1.charFromCode(this.bytes.next());
          }
          this.bytes.assertNext(CharCodes_1.default.GreaterThan);
          return PDFHexString_1.default.of(value);
        };
        PDFObjectParser2.prototype.parseString = function() {
          var nestingLvl = 0;
          var isEscaped = false;
          var value = "";
          while (!this.bytes.done()) {
            var byte = this.bytes.next();
            value += utils_1.charFromCode(byte);
            if (!isEscaped) {
              if (byte === CharCodes_1.default.LeftParen)
                nestingLvl += 1;
              if (byte === CharCodes_1.default.RightParen)
                nestingLvl -= 1;
            }
            if (byte === CharCodes_1.default.BackSlash) {
              isEscaped = !isEscaped;
            } else if (isEscaped) {
              isEscaped = false;
            }
            if (nestingLvl === 0) {
              return PDFString_1.default.of(value.substring(1, value.length - 1));
            }
          }
          throw new errors_1.UnbalancedParenthesisError(this.bytes.position());
        };
        PDFObjectParser2.prototype.parseName = function() {
          this.bytes.assertNext(CharCodes_1.default.ForwardSlash);
          var name = "";
          while (!this.bytes.done()) {
            var byte = this.bytes.peek();
            if (Whitespace_1.IsWhitespace[byte] || Delimiters_1.IsDelimiter[byte])
              break;
            name += utils_1.charFromCode(byte);
            this.bytes.next();
          }
          return PDFName_1.default.of(name);
        };
        PDFObjectParser2.prototype.parseArray = function() {
          this.bytes.assertNext(CharCodes_1.default.LeftSquareBracket);
          this.skipWhitespaceAndComments();
          var pdfArray = PDFArray_1.default.withContext(this.context);
          while (this.bytes.peek() !== CharCodes_1.default.RightSquareBracket) {
            var element = this.parseObject();
            pdfArray.push(element);
            this.skipWhitespaceAndComments();
          }
          this.bytes.assertNext(CharCodes_1.default.RightSquareBracket);
          return pdfArray;
        };
        PDFObjectParser2.prototype.parseDict = function() {
          this.bytes.assertNext(CharCodes_1.default.LessThan);
          this.bytes.assertNext(CharCodes_1.default.LessThan);
          this.skipWhitespaceAndComments();
          var dict = /* @__PURE__ */ new Map();
          while (!this.bytes.done() && this.bytes.peek() !== CharCodes_1.default.GreaterThan && this.bytes.peekAhead(1) !== CharCodes_1.default.GreaterThan) {
            var key = this.parseName();
            var value = this.parseObject();
            dict.set(key, value);
            this.skipWhitespaceAndComments();
          }
          this.skipWhitespaceAndComments();
          this.bytes.assertNext(CharCodes_1.default.GreaterThan);
          this.bytes.assertNext(CharCodes_1.default.GreaterThan);
          var Type = dict.get(PDFName_1.default.of("Type"));
          if (Type === PDFName_1.default.of("Catalog")) {
            return PDFCatalog_1.default.fromMapWithContext(dict, this.context);
          } else if (Type === PDFName_1.default.of("Pages")) {
            return PDFPageTree_1.default.fromMapWithContext(dict, this.context);
          } else if (Type === PDFName_1.default.of("Page")) {
            return PDFPageLeaf_1.default.fromMapWithContext(dict, this.context);
          } else {
            return PDFDict_1.default.fromMapWithContext(dict, this.context);
          }
        };
        PDFObjectParser2.prototype.parseDictOrStream = function() {
          var startPos = this.bytes.position();
          var dict = this.parseDict();
          this.skipWhitespaceAndComments();
          if (!this.matchKeyword(Keywords_1.Keywords.streamEOF1) && !this.matchKeyword(Keywords_1.Keywords.streamEOF2) && !this.matchKeyword(Keywords_1.Keywords.streamEOF3) && !this.matchKeyword(Keywords_1.Keywords.streamEOF4) && !this.matchKeyword(Keywords_1.Keywords.stream)) {
            return dict;
          }
          var start = this.bytes.offset();
          var end;
          var Length = dict.get(PDFName_1.default.of("Length"));
          if (Length instanceof PDFNumber_1.default) {
            end = start + Length.asNumber();
            this.bytes.moveTo(end);
            this.skipWhitespaceAndComments();
            if (!this.matchKeyword(Keywords_1.Keywords.endstream)) {
              this.bytes.moveTo(start);
              end = this.findEndOfStreamFallback(startPos);
            }
          } else {
            end = this.findEndOfStreamFallback(startPos);
          }
          var contents = this.bytes.slice(start, end);
          return PDFRawStream_1.default.of(dict, contents);
        };
        PDFObjectParser2.prototype.findEndOfStreamFallback = function(startPos) {
          var nestingLvl = 1;
          var end = this.bytes.offset();
          while (!this.bytes.done()) {
            end = this.bytes.offset();
            if (this.matchKeyword(Keywords_1.Keywords.stream)) {
              nestingLvl += 1;
            } else if (this.matchKeyword(Keywords_1.Keywords.EOF1endstream) || this.matchKeyword(Keywords_1.Keywords.EOF2endstream) || this.matchKeyword(Keywords_1.Keywords.EOF3endstream) || this.matchKeyword(Keywords_1.Keywords.endstream)) {
              nestingLvl -= 1;
            } else {
              this.bytes.next();
            }
            if (nestingLvl === 0)
              break;
          }
          if (nestingLvl !== 0)
            throw new errors_1.PDFStreamParsingError(startPos);
          return end;
        };
        PDFObjectParser2.forBytes = function(bytes, context, capNumbers) {
          return new PDFObjectParser2(ByteStream_1.default.of(bytes), context, capNumbers);
        };
        PDFObjectParser2.forByteStream = function(byteStream, context, capNumbers) {
          if (capNumbers === void 0) {
            capNumbers = false;
          }
          return new PDFObjectParser2(byteStream, context, capNumbers);
        };
        return PDFObjectParser2;
      }(BaseParser_1.default)
    );
    exports.default = PDFObjectParser;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/parser/PDFObjectStreamParser.js
var require_PDFObjectStreamParser = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/parser/PDFObjectStreamParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var ByteStream_1 = tslib_1.__importDefault(require_ByteStream());
    var PDFObjectParser_1 = tslib_1.__importDefault(require_PDFObjectParser());
    var utils_1 = require_utils2();
    var PDFObjectStreamParser = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFObjectStreamParser2, _super);
        function PDFObjectStreamParser2(rawStream, shouldWaitForTick) {
          var _this = _super.call(this, ByteStream_1.default.fromPDFRawStream(rawStream), rawStream.dict.context) || this;
          var dict = rawStream.dict;
          _this.alreadyParsed = false;
          _this.shouldWaitForTick = shouldWaitForTick || function() {
            return false;
          };
          _this.firstOffset = dict.lookup(PDFName_1.default.of("First"), PDFNumber_1.default).asNumber();
          _this.objectCount = dict.lookup(PDFName_1.default.of("N"), PDFNumber_1.default).asNumber();
          return _this;
        }
        PDFObjectStreamParser2.prototype.parseIntoContext = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var offsetsAndObjectNumbers, idx, len, _a, objectNumber, offset2, object2, ref;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (this.alreadyParsed) {
                    throw new errors_1.ReparseError("PDFObjectStreamParser", "parseIntoContext");
                  }
                  this.alreadyParsed = true;
                  offsetsAndObjectNumbers = this.parseOffsetsAndObjectNumbers();
                  idx = 0, len = offsetsAndObjectNumbers.length;
                  _b.label = 1;
                case 1:
                  if (!(idx < len))
                    return [3, 4];
                  _a = offsetsAndObjectNumbers[idx], objectNumber = _a.objectNumber, offset2 = _a.offset;
                  this.bytes.moveTo(this.firstOffset + offset2);
                  object2 = this.parseObject();
                  ref = PDFRef_1.default.of(objectNumber, 0);
                  this.context.assign(ref, object2);
                  if (!this.shouldWaitForTick())
                    return [3, 3];
                  return [4, utils_1.waitForTick()];
                case 2:
                  _b.sent();
                  _b.label = 3;
                case 3:
                  idx++;
                  return [3, 1];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFObjectStreamParser2.prototype.parseOffsetsAndObjectNumbers = function() {
          var offsetsAndObjectNumbers = [];
          for (var idx = 0, len = this.objectCount; idx < len; idx++) {
            this.skipWhitespaceAndComments();
            var objectNumber = this.parseRawInt();
            this.skipWhitespaceAndComments();
            var offset2 = this.parseRawInt();
            offsetsAndObjectNumbers.push({ objectNumber, offset: offset2 });
          }
          return offsetsAndObjectNumbers;
        };
        PDFObjectStreamParser2.forStream = function(rawStream, shouldWaitForTick) {
          return new PDFObjectStreamParser2(rawStream, shouldWaitForTick);
        };
        return PDFObjectStreamParser2;
      }(PDFObjectParser_1.default)
    );
    exports.default = PDFObjectStreamParser;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/parser/PDFXRefStreamParser.js
var require_PDFXRefStreamParser = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/parser/PDFXRefStreamParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var PDFArray_1 = tslib_1.__importDefault(require_PDFArray());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFNumber_1 = tslib_1.__importDefault(require_PDFNumber());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var ByteStream_1 = tslib_1.__importDefault(require_ByteStream());
    var PDFXRefStreamParser = (
      /** @class */
      function() {
        function PDFXRefStreamParser2(rawStream) {
          this.alreadyParsed = false;
          this.dict = rawStream.dict;
          this.bytes = ByteStream_1.default.fromPDFRawStream(rawStream);
          this.context = this.dict.context;
          var Size = this.dict.lookup(PDFName_1.default.of("Size"), PDFNumber_1.default);
          var Index = this.dict.lookup(PDFName_1.default.of("Index"));
          if (Index instanceof PDFArray_1.default) {
            this.subsections = [];
            for (var idx = 0, len = Index.size(); idx < len; idx += 2) {
              var firstObjectNumber = Index.lookup(idx + 0, PDFNumber_1.default).asNumber();
              var length_1 = Index.lookup(idx + 1, PDFNumber_1.default).asNumber();
              this.subsections.push({ firstObjectNumber, length: length_1 });
            }
          } else {
            this.subsections = [{ firstObjectNumber: 0, length: Size.asNumber() }];
          }
          var W = this.dict.lookup(PDFName_1.default.of("W"), PDFArray_1.default);
          this.byteWidths = [-1, -1, -1];
          for (var idx = 0, len = W.size(); idx < len; idx++) {
            this.byteWidths[idx] = W.lookup(idx, PDFNumber_1.default).asNumber();
          }
        }
        PDFXRefStreamParser2.prototype.parseIntoContext = function() {
          if (this.alreadyParsed) {
            throw new errors_1.ReparseError("PDFXRefStreamParser", "parseIntoContext");
          }
          this.alreadyParsed = true;
          this.context.trailerInfo = {
            Root: this.dict.get(PDFName_1.default.of("Root")),
            Encrypt: this.dict.get(PDFName_1.default.of("Encrypt")),
            Info: this.dict.get(PDFName_1.default.of("Info")),
            ID: this.dict.get(PDFName_1.default.of("ID"))
          };
          var entries = this.parseEntries();
          return entries;
        };
        PDFXRefStreamParser2.prototype.parseEntries = function() {
          var entries = [];
          var _a = this.byteWidths, typeFieldWidth = _a[0], offsetFieldWidth = _a[1], genFieldWidth = _a[2];
          for (var subsectionIdx = 0, subsectionLen = this.subsections.length; subsectionIdx < subsectionLen; subsectionIdx++) {
            var _b = this.subsections[subsectionIdx], firstObjectNumber = _b.firstObjectNumber, length_2 = _b.length;
            for (var objIdx = 0; objIdx < length_2; objIdx++) {
              var type = 0;
              for (var idx = 0, len = typeFieldWidth; idx < len; idx++) {
                type = type << 8 | this.bytes.next();
              }
              var offset2 = 0;
              for (var idx = 0, len = offsetFieldWidth; idx < len; idx++) {
                offset2 = offset2 << 8 | this.bytes.next();
              }
              var generationNumber = 0;
              for (var idx = 0, len = genFieldWidth; idx < len; idx++) {
                generationNumber = generationNumber << 8 | this.bytes.next();
              }
              if (typeFieldWidth === 0)
                type = 1;
              var objectNumber = firstObjectNumber + objIdx;
              var entry = {
                ref: PDFRef_1.default.of(objectNumber, generationNumber),
                offset: offset2,
                deleted: type === 0,
                inObjectStream: type === 2
              };
              entries.push(entry);
            }
          }
          return entries;
        };
        PDFXRefStreamParser2.forStream = function(rawStream) {
          return new PDFXRefStreamParser2(rawStream);
        };
        return PDFXRefStreamParser2;
      }()
    );
    exports.default = PDFXRefStreamParser;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/parser/PDFParser.js
var require_PDFParser = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/parser/PDFParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFCrossRefSection_1 = tslib_1.__importDefault(require_PDFCrossRefSection());
    var PDFHeader_1 = tslib_1.__importDefault(require_PDFHeader());
    var PDFTrailer_1 = tslib_1.__importDefault(require_PDFTrailer());
    var errors_1 = require_errors2();
    var PDFDict_1 = tslib_1.__importDefault(require_PDFDict());
    var PDFInvalidObject_1 = tslib_1.__importDefault(require_PDFInvalidObject());
    var PDFName_1 = tslib_1.__importDefault(require_PDFName());
    var PDFRawStream_1 = tslib_1.__importDefault(require_PDFRawStream());
    var PDFRef_1 = tslib_1.__importDefault(require_PDFRef());
    var ByteStream_1 = tslib_1.__importDefault(require_ByteStream());
    var PDFObjectParser_1 = tslib_1.__importDefault(require_PDFObjectParser());
    var PDFObjectStreamParser_1 = tslib_1.__importDefault(require_PDFObjectStreamParser());
    var PDFXRefStreamParser_1 = tslib_1.__importDefault(require_PDFXRefStreamParser());
    var PDFContext_1 = tslib_1.__importDefault(require_PDFContext());
    var CharCodes_1 = tslib_1.__importDefault(require_CharCodes());
    var Keywords_1 = require_Keywords();
    var Numeric_1 = require_Numeric();
    var utils_1 = require_utils2();
    var PDFParser = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFParser2, _super);
        function PDFParser2(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {
          if (objectsPerTick === void 0) {
            objectsPerTick = Infinity;
          }
          if (throwOnInvalidObject === void 0) {
            throwOnInvalidObject = false;
          }
          if (capNumbers === void 0) {
            capNumbers = false;
          }
          var _this = _super.call(this, ByteStream_1.default.of(pdfBytes), PDFContext_1.default.create(), capNumbers) || this;
          _this.alreadyParsed = false;
          _this.parsedObjects = 0;
          _this.shouldWaitForTick = function() {
            _this.parsedObjects += 1;
            return _this.parsedObjects % _this.objectsPerTick === 0;
          };
          _this.objectsPerTick = objectsPerTick;
          _this.throwOnInvalidObject = throwOnInvalidObject;
          return _this;
        }
        PDFParser2.prototype.parseDocument = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var prevOffset, offset2;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (this.alreadyParsed) {
                    throw new errors_1.ReparseError("PDFParser", "parseDocument");
                  }
                  this.alreadyParsed = true;
                  this.context.header = this.parseHeader();
                  _a.label = 1;
                case 1:
                  if (!!this.bytes.done())
                    return [3, 3];
                  return [4, this.parseDocumentSection()];
                case 2:
                  _a.sent();
                  offset2 = this.bytes.offset();
                  if (offset2 === prevOffset) {
                    throw new errors_1.StalledParserError(this.bytes.position());
                  }
                  prevOffset = offset2;
                  return [3, 1];
                case 3:
                  this.maybeRecoverRoot();
                  if (this.context.lookup(PDFRef_1.default.of(0))) {
                    console.warn("Removing parsed object: 0 0 R");
                    this.context.delete(PDFRef_1.default.of(0));
                  }
                  return [2, this.context];
              }
            });
          });
        };
        PDFParser2.prototype.maybeRecoverRoot = function() {
          var isValidCatalog = function(obj) {
            return obj instanceof PDFDict_1.default && obj.lookup(PDFName_1.default.of("Type")) === PDFName_1.default.of("Catalog");
          };
          var catalog = this.context.lookup(this.context.trailerInfo.Root);
          if (!isValidCatalog(catalog)) {
            var indirectObjects = this.context.enumerateIndirectObjects();
            for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {
              var _a = indirectObjects[idx], ref = _a[0], object2 = _a[1];
              if (isValidCatalog(object2)) {
                this.context.trailerInfo.Root = ref;
              }
            }
          }
        };
        PDFParser2.prototype.parseHeader = function() {
          while (!this.bytes.done()) {
            if (this.matchKeyword(Keywords_1.Keywords.header)) {
              var major = this.parseRawInt();
              this.bytes.assertNext(CharCodes_1.default.Period);
              var minor = this.parseRawInt();
              var header = PDFHeader_1.default.forVersion(major, minor);
              this.skipBinaryHeaderComment();
              return header;
            }
            this.bytes.next();
          }
          throw new errors_1.MissingPDFHeaderError(this.bytes.position());
        };
        PDFParser2.prototype.parseIndirectObjectHeader = function() {
          this.skipWhitespaceAndComments();
          var objectNumber = this.parseRawInt();
          this.skipWhitespaceAndComments();
          var generationNumber = this.parseRawInt();
          this.skipWhitespaceAndComments();
          if (!this.matchKeyword(Keywords_1.Keywords.obj)) {
            throw new errors_1.MissingKeywordError(this.bytes.position(), Keywords_1.Keywords.obj);
          }
          return PDFRef_1.default.of(objectNumber, generationNumber);
        };
        PDFParser2.prototype.matchIndirectObjectHeader = function() {
          var initialOffset = this.bytes.offset();
          try {
            this.parseIndirectObjectHeader();
            return true;
          } catch (e) {
            this.bytes.moveTo(initialOffset);
            return false;
          }
        };
        PDFParser2.prototype.parseIndirectObject = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var ref, object2;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  ref = this.parseIndirectObjectHeader();
                  this.skipWhitespaceAndComments();
                  object2 = this.parseObject();
                  this.skipWhitespaceAndComments();
                  this.matchKeyword(Keywords_1.Keywords.endobj);
                  if (!(object2 instanceof PDFRawStream_1.default && object2.dict.lookup(PDFName_1.default.of("Type")) === PDFName_1.default.of("ObjStm")))
                    return [3, 2];
                  return [4, PDFObjectStreamParser_1.default.forStream(object2, this.shouldWaitForTick).parseIntoContext()];
                case 1:
                  _a.sent();
                  return [3, 3];
                case 2:
                  if (object2 instanceof PDFRawStream_1.default && object2.dict.lookup(PDFName_1.default.of("Type")) === PDFName_1.default.of("XRef")) {
                    PDFXRefStreamParser_1.default.forStream(object2).parseIntoContext();
                  } else {
                    this.context.assign(ref, object2);
                  }
                  _a.label = 3;
                case 3:
                  return [2, ref];
              }
            });
          });
        };
        PDFParser2.prototype.tryToParseInvalidIndirectObject = function() {
          var startPos = this.bytes.position();
          var msg = "Trying to parse invalid object: " + JSON.stringify(startPos) + ")";
          if (this.throwOnInvalidObject)
            throw new Error(msg);
          console.warn(msg);
          var ref = this.parseIndirectObjectHeader();
          console.warn("Invalid object ref: " + ref);
          this.skipWhitespaceAndComments();
          var start = this.bytes.offset();
          var failed = true;
          while (!this.bytes.done()) {
            if (this.matchKeyword(Keywords_1.Keywords.endobj)) {
              failed = false;
            }
            if (!failed)
              break;
            this.bytes.next();
          }
          if (failed)
            throw new errors_1.PDFInvalidObjectParsingError(startPos);
          var end = this.bytes.offset() - Keywords_1.Keywords.endobj.length;
          var object2 = PDFInvalidObject_1.default.of(this.bytes.slice(start, end));
          this.context.assign(ref, object2);
          return ref;
        };
        PDFParser2.prototype.parseIndirectObjects = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var initialOffset, e_1;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  this.skipWhitespaceAndComments();
                  _a.label = 1;
                case 1:
                  if (!(!this.bytes.done() && Numeric_1.IsDigit[this.bytes.peek()]))
                    return [3, 8];
                  initialOffset = this.bytes.offset();
                  _a.label = 2;
                case 2:
                  _a.trys.push([2, 4, , 5]);
                  return [4, this.parseIndirectObject()];
                case 3:
                  _a.sent();
                  return [3, 5];
                case 4:
                  e_1 = _a.sent();
                  this.bytes.moveTo(initialOffset);
                  this.tryToParseInvalidIndirectObject();
                  return [3, 5];
                case 5:
                  this.skipWhitespaceAndComments();
                  this.skipJibberish();
                  if (!this.shouldWaitForTick())
                    return [3, 7];
                  return [4, utils_1.waitForTick()];
                case 6:
                  _a.sent();
                  _a.label = 7;
                case 7:
                  return [3, 1];
                case 8:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFParser2.prototype.maybeParseCrossRefSection = function() {
          this.skipWhitespaceAndComments();
          if (!this.matchKeyword(Keywords_1.Keywords.xref))
            return;
          this.skipWhitespaceAndComments();
          var objectNumber = -1;
          var xref = PDFCrossRefSection_1.default.createEmpty();
          while (!this.bytes.done() && Numeric_1.IsDigit[this.bytes.peek()]) {
            var firstInt = this.parseRawInt();
            this.skipWhitespaceAndComments();
            var secondInt = this.parseRawInt();
            this.skipWhitespaceAndComments();
            var byte = this.bytes.peek();
            if (byte === CharCodes_1.default.n || byte === CharCodes_1.default.f) {
              var ref = PDFRef_1.default.of(objectNumber, secondInt);
              if (this.bytes.next() === CharCodes_1.default.n) {
                xref.addEntry(ref, firstInt);
              } else {
                xref.addDeletedEntry(ref, firstInt);
              }
              objectNumber += 1;
            } else {
              objectNumber = firstInt;
            }
            this.skipWhitespaceAndComments();
          }
          return xref;
        };
        PDFParser2.prototype.maybeParseTrailerDict = function() {
          this.skipWhitespaceAndComments();
          if (!this.matchKeyword(Keywords_1.Keywords.trailer))
            return;
          this.skipWhitespaceAndComments();
          var dict = this.parseDict();
          var context = this.context;
          context.trailerInfo = {
            Root: dict.get(PDFName_1.default.of("Root")) || context.trailerInfo.Root,
            Encrypt: dict.get(PDFName_1.default.of("Encrypt")) || context.trailerInfo.Encrypt,
            Info: dict.get(PDFName_1.default.of("Info")) || context.trailerInfo.Info,
            ID: dict.get(PDFName_1.default.of("ID")) || context.trailerInfo.ID
          };
        };
        PDFParser2.prototype.maybeParseTrailer = function() {
          this.skipWhitespaceAndComments();
          if (!this.matchKeyword(Keywords_1.Keywords.startxref))
            return;
          this.skipWhitespaceAndComments();
          var offset2 = this.parseRawInt();
          this.skipWhitespace();
          this.matchKeyword(Keywords_1.Keywords.eof);
          this.skipWhitespaceAndComments();
          this.matchKeyword(Keywords_1.Keywords.eof);
          this.skipWhitespaceAndComments();
          return PDFTrailer_1.default.forLastCrossRefSectionOffset(offset2);
        };
        PDFParser2.prototype.parseDocumentSection = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.parseIndirectObjects()];
                case 1:
                  _a.sent();
                  this.maybeParseCrossRefSection();
                  this.maybeParseTrailerDict();
                  this.maybeParseTrailer();
                  this.skipJibberish();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFParser2.prototype.skipJibberish = function() {
          this.skipWhitespaceAndComments();
          while (!this.bytes.done()) {
            var initialOffset = this.bytes.offset();
            var byte = this.bytes.peek();
            var isAlphaNumeric = byte >= CharCodes_1.default.Space && byte <= CharCodes_1.default.Tilde;
            if (isAlphaNumeric) {
              if (this.matchKeyword(Keywords_1.Keywords.xref) || this.matchKeyword(Keywords_1.Keywords.trailer) || this.matchKeyword(Keywords_1.Keywords.startxref) || this.matchIndirectObjectHeader()) {
                this.bytes.moveTo(initialOffset);
                break;
              }
            }
            this.bytes.next();
          }
        };
        PDFParser2.prototype.skipBinaryHeaderComment = function() {
          this.skipWhitespaceAndComments();
          try {
            var initialOffset = this.bytes.offset();
            this.parseIndirectObjectHeader();
            this.bytes.moveTo(initialOffset);
          } catch (e) {
            this.bytes.next();
            this.skipWhitespaceAndComments();
          }
        };
        PDFParser2.forBytesWithOptions = function(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {
          return new PDFParser2(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);
        };
        return PDFParser2;
      }(PDFObjectParser_1.default)
    );
    exports.default = PDFParser;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/annotation/flags.js
var require_flags2 = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/annotation/flags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnnotationFlags = void 0;
    var flag = function(bitIndex) {
      return 1 << bitIndex;
    };
    var AnnotationFlags;
    (function(AnnotationFlags2) {
      AnnotationFlags2[AnnotationFlags2["Invisible"] = flag(1 - 1)] = "Invisible";
      AnnotationFlags2[AnnotationFlags2["Hidden"] = flag(2 - 1)] = "Hidden";
      AnnotationFlags2[AnnotationFlags2["Print"] = flag(3 - 1)] = "Print";
      AnnotationFlags2[AnnotationFlags2["NoZoom"] = flag(4 - 1)] = "NoZoom";
      AnnotationFlags2[AnnotationFlags2["NoRotate"] = flag(5 - 1)] = "NoRotate";
      AnnotationFlags2[AnnotationFlags2["NoView"] = flag(6 - 1)] = "NoView";
      AnnotationFlags2[AnnotationFlags2["ReadOnly"] = flag(7 - 1)] = "ReadOnly";
      AnnotationFlags2[AnnotationFlags2["Locked"] = flag(8 - 1)] = "Locked";
      AnnotationFlags2[AnnotationFlags2["ToggleNoView"] = flag(9 - 1)] = "ToggleNoView";
      AnnotationFlags2[AnnotationFlags2["LockedContents"] = flag(10 - 1)] = "LockedContents";
    })(AnnotationFlags = exports.AnnotationFlags || (exports.AnnotationFlags = {}));
  }
});

// ../../../node_modules/pdf-lib/cjs/core/annotation/index.js
var require_annotation = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/annotation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFAnnotation_1 = require_PDFAnnotation();
    Object.defineProperty(exports, "PDFAnnotation", { enumerable: true, get: function() {
      return PDFAnnotation_1.default;
    } });
    var PDFWidgetAnnotation_1 = require_PDFWidgetAnnotation();
    Object.defineProperty(exports, "PDFWidgetAnnotation", { enumerable: true, get: function() {
      return PDFWidgetAnnotation_1.default;
    } });
    var AppearanceCharacteristics_1 = require_AppearanceCharacteristics();
    Object.defineProperty(exports, "AppearanceCharacteristics", { enumerable: true, get: function() {
      return AppearanceCharacteristics_1.default;
    } });
    tslib_1.__exportStar(require_flags2(), exports);
  }
});

// ../../../node_modules/pdf-lib/cjs/core/index.js
var require_core = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_errors2(), exports);
    var CharCodes_1 = require_CharCodes();
    Object.defineProperty(exports, "CharCodes", { enumerable: true, get: function() {
      return CharCodes_1.default;
    } });
    var PDFContext_1 = require_PDFContext();
    Object.defineProperty(exports, "PDFContext", { enumerable: true, get: function() {
      return PDFContext_1.default;
    } });
    var PDFObjectCopier_1 = require_PDFObjectCopier();
    Object.defineProperty(exports, "PDFObjectCopier", { enumerable: true, get: function() {
      return PDFObjectCopier_1.default;
    } });
    var PDFWriter_1 = require_PDFWriter();
    Object.defineProperty(exports, "PDFWriter", { enumerable: true, get: function() {
      return PDFWriter_1.default;
    } });
    var PDFStreamWriter_1 = require_PDFStreamWriter();
    Object.defineProperty(exports, "PDFStreamWriter", { enumerable: true, get: function() {
      return PDFStreamWriter_1.default;
    } });
    var PDFHeader_1 = require_PDFHeader();
    Object.defineProperty(exports, "PDFHeader", { enumerable: true, get: function() {
      return PDFHeader_1.default;
    } });
    var PDFTrailer_1 = require_PDFTrailer();
    Object.defineProperty(exports, "PDFTrailer", { enumerable: true, get: function() {
      return PDFTrailer_1.default;
    } });
    var PDFTrailerDict_1 = require_PDFTrailerDict();
    Object.defineProperty(exports, "PDFTrailerDict", { enumerable: true, get: function() {
      return PDFTrailerDict_1.default;
    } });
    var PDFCrossRefSection_1 = require_PDFCrossRefSection();
    Object.defineProperty(exports, "PDFCrossRefSection", { enumerable: true, get: function() {
      return PDFCrossRefSection_1.default;
    } });
    var StandardFontEmbedder_1 = require_StandardFontEmbedder();
    Object.defineProperty(exports, "StandardFontEmbedder", { enumerable: true, get: function() {
      return StandardFontEmbedder_1.default;
    } });
    var CustomFontEmbedder_1 = require_CustomFontEmbedder();
    Object.defineProperty(exports, "CustomFontEmbedder", { enumerable: true, get: function() {
      return CustomFontEmbedder_1.default;
    } });
    var CustomFontSubsetEmbedder_1 = require_CustomFontSubsetEmbedder();
    Object.defineProperty(exports, "CustomFontSubsetEmbedder", { enumerable: true, get: function() {
      return CustomFontSubsetEmbedder_1.default;
    } });
    var FileEmbedder_1 = require_FileEmbedder();
    Object.defineProperty(exports, "FileEmbedder", { enumerable: true, get: function() {
      return FileEmbedder_1.default;
    } });
    Object.defineProperty(exports, "AFRelationship", { enumerable: true, get: function() {
      return FileEmbedder_1.AFRelationship;
    } });
    var JpegEmbedder_1 = require_JpegEmbedder();
    Object.defineProperty(exports, "JpegEmbedder", { enumerable: true, get: function() {
      return JpegEmbedder_1.default;
    } });
    var PngEmbedder_1 = require_PngEmbedder();
    Object.defineProperty(exports, "PngEmbedder", { enumerable: true, get: function() {
      return PngEmbedder_1.default;
    } });
    var PDFPageEmbedder_1 = require_PDFPageEmbedder();
    Object.defineProperty(exports, "PDFPageEmbedder", { enumerable: true, get: function() {
      return PDFPageEmbedder_1.default;
    } });
    var ViewerPreferences_1 = require_ViewerPreferences();
    Object.defineProperty(exports, "ViewerPreferences", { enumerable: true, get: function() {
      return ViewerPreferences_1.default;
    } });
    Object.defineProperty(exports, "NonFullScreenPageMode", { enumerable: true, get: function() {
      return ViewerPreferences_1.NonFullScreenPageMode;
    } });
    Object.defineProperty(exports, "ReadingDirection", { enumerable: true, get: function() {
      return ViewerPreferences_1.ReadingDirection;
    } });
    Object.defineProperty(exports, "PrintScaling", { enumerable: true, get: function() {
      return ViewerPreferences_1.PrintScaling;
    } });
    Object.defineProperty(exports, "Duplex", { enumerable: true, get: function() {
      return ViewerPreferences_1.Duplex;
    } });
    var PDFObject_1 = require_PDFObject();
    Object.defineProperty(exports, "PDFObject", { enumerable: true, get: function() {
      return PDFObject_1.default;
    } });
    var PDFBool_1 = require_PDFBool();
    Object.defineProperty(exports, "PDFBool", { enumerable: true, get: function() {
      return PDFBool_1.default;
    } });
    var PDFNumber_1 = require_PDFNumber();
    Object.defineProperty(exports, "PDFNumber", { enumerable: true, get: function() {
      return PDFNumber_1.default;
    } });
    var PDFString_1 = require_PDFString();
    Object.defineProperty(exports, "PDFString", { enumerable: true, get: function() {
      return PDFString_1.default;
    } });
    var PDFHexString_1 = require_PDFHexString();
    Object.defineProperty(exports, "PDFHexString", { enumerable: true, get: function() {
      return PDFHexString_1.default;
    } });
    var PDFName_1 = require_PDFName();
    Object.defineProperty(exports, "PDFName", { enumerable: true, get: function() {
      return PDFName_1.default;
    } });
    var PDFNull_1 = require_PDFNull();
    Object.defineProperty(exports, "PDFNull", { enumerable: true, get: function() {
      return PDFNull_1.default;
    } });
    var PDFArray_1 = require_PDFArray();
    Object.defineProperty(exports, "PDFArray", { enumerable: true, get: function() {
      return PDFArray_1.default;
    } });
    var PDFDict_1 = require_PDFDict();
    Object.defineProperty(exports, "PDFDict", { enumerable: true, get: function() {
      return PDFDict_1.default;
    } });
    var PDFRef_1 = require_PDFRef();
    Object.defineProperty(exports, "PDFRef", { enumerable: true, get: function() {
      return PDFRef_1.default;
    } });
    var PDFInvalidObject_1 = require_PDFInvalidObject();
    Object.defineProperty(exports, "PDFInvalidObject", { enumerable: true, get: function() {
      return PDFInvalidObject_1.default;
    } });
    var PDFStream_1 = require_PDFStream();
    Object.defineProperty(exports, "PDFStream", { enumerable: true, get: function() {
      return PDFStream_1.default;
    } });
    var PDFRawStream_1 = require_PDFRawStream();
    Object.defineProperty(exports, "PDFRawStream", { enumerable: true, get: function() {
      return PDFRawStream_1.default;
    } });
    var PDFCatalog_1 = require_PDFCatalog();
    Object.defineProperty(exports, "PDFCatalog", { enumerable: true, get: function() {
      return PDFCatalog_1.default;
    } });
    var PDFContentStream_1 = require_PDFContentStream();
    Object.defineProperty(exports, "PDFContentStream", { enumerable: true, get: function() {
      return PDFContentStream_1.default;
    } });
    var PDFCrossRefStream_1 = require_PDFCrossRefStream();
    Object.defineProperty(exports, "PDFCrossRefStream", { enumerable: true, get: function() {
      return PDFCrossRefStream_1.default;
    } });
    var PDFObjectStream_1 = require_PDFObjectStream();
    Object.defineProperty(exports, "PDFObjectStream", { enumerable: true, get: function() {
      return PDFObjectStream_1.default;
    } });
    var PDFPageTree_1 = require_PDFPageTree();
    Object.defineProperty(exports, "PDFPageTree", { enumerable: true, get: function() {
      return PDFPageTree_1.default;
    } });
    var PDFPageLeaf_1 = require_PDFPageLeaf();
    Object.defineProperty(exports, "PDFPageLeaf", { enumerable: true, get: function() {
      return PDFPageLeaf_1.default;
    } });
    var PDFFlateStream_1 = require_PDFFlateStream();
    Object.defineProperty(exports, "PDFFlateStream", { enumerable: true, get: function() {
      return PDFFlateStream_1.default;
    } });
    var PDFOperator_1 = require_PDFOperator();
    Object.defineProperty(exports, "PDFOperator", { enumerable: true, get: function() {
      return PDFOperator_1.default;
    } });
    var PDFOperatorNames_1 = require_PDFOperatorNames();
    Object.defineProperty(exports, "PDFOperatorNames", { enumerable: true, get: function() {
      return PDFOperatorNames_1.default;
    } });
    var PDFObjectParser_1 = require_PDFObjectParser();
    Object.defineProperty(exports, "PDFObjectParser", { enumerable: true, get: function() {
      return PDFObjectParser_1.default;
    } });
    var PDFObjectStreamParser_1 = require_PDFObjectStreamParser();
    Object.defineProperty(exports, "PDFObjectStreamParser", { enumerable: true, get: function() {
      return PDFObjectStreamParser_1.default;
    } });
    var PDFParser_1 = require_PDFParser();
    Object.defineProperty(exports, "PDFParser", { enumerable: true, get: function() {
      return PDFParser_1.default;
    } });
    var PDFXRefStreamParser_1 = require_PDFXRefStreamParser();
    Object.defineProperty(exports, "PDFXRefStreamParser", { enumerable: true, get: function() {
      return PDFXRefStreamParser_1.default;
    } });
    var decode_1 = require_decode();
    Object.defineProperty(exports, "decodePDFRawStream", { enumerable: true, get: function() {
      return decode_1.decodePDFRawStream;
    } });
    tslib_1.__exportStar(require_annotation(), exports);
    tslib_1.__exportStar(require_acroform(), exports);
  }
});

// ../../../node_modules/pdf-lib/cjs/api/objects.js
var require_objects2 = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/objects.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asNumber = exports.asPDFNumber = exports.asPDFName = void 0;
    var core_1 = require_core();
    exports.asPDFName = function(name) {
      return name instanceof core_1.PDFName ? name : core_1.PDFName.of(name);
    };
    exports.asPDFNumber = function(num) {
      return num instanceof core_1.PDFNumber ? num : core_1.PDFNumber.of(num);
    };
    exports.asNumber = function(num) {
      return num instanceof core_1.PDFNumber ? num.asNumber() : num;
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/api/rotations.js
var require_rotations = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/rotations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rotateRectangle = exports.adjustDimsForRotation = exports.reduceRotation = exports.toDegrees = exports.toRadians = exports.radiansToDegrees = exports.degreesToRadians = exports.degrees = exports.radians = exports.RotationTypes = void 0;
    var utils_1 = require_utils2();
    var RotationTypes2;
    (function(RotationTypes3) {
      RotationTypes3["Degrees"] = "degrees";
      RotationTypes3["Radians"] = "radians";
    })(RotationTypes2 = exports.RotationTypes || (exports.RotationTypes = {}));
    exports.radians = function(radianAngle) {
      utils_1.assertIs(radianAngle, "radianAngle", ["number"]);
      return { type: RotationTypes2.Radians, angle: radianAngle };
    };
    exports.degrees = function(degreeAngle) {
      utils_1.assertIs(degreeAngle, "degreeAngle", ["number"]);
      return { type: RotationTypes2.Degrees, angle: degreeAngle };
    };
    var Radians = RotationTypes2.Radians;
    var Degrees = RotationTypes2.Degrees;
    exports.degreesToRadians = function(degree) {
      return degree * Math.PI / 180;
    };
    exports.radiansToDegrees = function(radian) {
      return radian * 180 / Math.PI;
    };
    exports.toRadians = function(rotation) {
      return rotation.type === Radians ? rotation.angle : rotation.type === Degrees ? exports.degreesToRadians(rotation.angle) : utils_1.error("Invalid rotation: " + JSON.stringify(rotation));
    };
    exports.toDegrees = function(rotation) {
      return rotation.type === Radians ? exports.radiansToDegrees(rotation.angle) : rotation.type === Degrees ? rotation.angle : utils_1.error("Invalid rotation: " + JSON.stringify(rotation));
    };
    exports.reduceRotation = function(degreeAngle) {
      if (degreeAngle === void 0) {
        degreeAngle = 0;
      }
      var quadrants = degreeAngle / 90 % 4;
      if (quadrants === 0)
        return 0;
      if (quadrants === 1)
        return 90;
      if (quadrants === 2)
        return 180;
      if (quadrants === 3)
        return 270;
      return 0;
    };
    exports.adjustDimsForRotation = function(dims, degreeAngle) {
      if (degreeAngle === void 0) {
        degreeAngle = 0;
      }
      var rotation = exports.reduceRotation(degreeAngle);
      return rotation === 90 || rotation === 270 ? { width: dims.height, height: dims.width } : { width: dims.width, height: dims.height };
    };
    exports.rotateRectangle = function(rectangle, borderWidth, degreeAngle) {
      if (borderWidth === void 0) {
        borderWidth = 0;
      }
      if (degreeAngle === void 0) {
        degreeAngle = 0;
      }
      var x = rectangle.x, y = rectangle.y, w = rectangle.width, h = rectangle.height;
      var r = exports.reduceRotation(degreeAngle);
      var b = borderWidth / 2;
      if (r === 0)
        return { x: x - b, y: y - b, width: w, height: h };
      else if (r === 90)
        return { x: x - h + b, y: y - b, width: h, height: w };
      else if (r === 180)
        return { x: x - w + b, y: y - h + b, width: w, height: h };
      else if (r === 270)
        return { x: x - b, y: y - w + b, width: h, height: w };
      else
        return { x: x - b, y: y - b, width: w, height: h };
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/api/operators.js
var require_operators = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/operators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.endMarkedContent = exports.beginMarkedContent = exports.setStrokingCmykColor = exports.setFillingCmykColor = exports.setStrokingRgbColor = exports.setFillingRgbColor = exports.setStrokingGrayscaleColor = exports.setFillingGrayscaleColor = exports.drawObject = exports.rotateAndSkewTextDegreesAndTranslate = exports.rotateAndSkewTextRadiansAndTranslate = exports.setTextMatrix = exports.setTextRenderingMode = exports.TextRenderingMode = exports.setTextRise = exports.setLineHeight = exports.setCharacterSqueeze = exports.setWordSpacing = exports.setCharacterSpacing = exports.setFontAndSize = exports.endText = exports.beginText = exports.showText = exports.moveText = exports.nextLine = exports.endPath = exports.fillAndStroke = exports.fill = exports.stroke = exports.square = exports.rectangle = exports.lineTo = exports.moveTo = exports.closePath = exports.appendQuadraticCurve = exports.appendBezierCurve = exports.setLineWidth = exports.popGraphicsState = exports.pushGraphicsState = exports.setGraphicsState = exports.setLineJoin = exports.LineJoinStyle = exports.setLineCap = exports.LineCapStyle = exports.restoreDashPattern = exports.setDashPattern = exports.skewDegrees = exports.skewRadians = exports.rotateDegrees = exports.rotateRadians = exports.scale = exports.translate = exports.concatTransformationMatrix = exports.clipEvenOdd = exports.clip = void 0;
    var objects_1 = require_objects2();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    exports.clip = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.ClipNonZero);
    };
    exports.clipEvenOdd = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.ClipEvenOdd);
    };
    var cos = Math.cos;
    var sin = Math.sin;
    var tan = Math.tan;
    exports.concatTransformationMatrix = function(a, b, c, d, e, f) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.ConcatTransformationMatrix, [
        objects_1.asPDFNumber(a),
        objects_1.asPDFNumber(b),
        objects_1.asPDFNumber(c),
        objects_1.asPDFNumber(d),
        objects_1.asPDFNumber(e),
        objects_1.asPDFNumber(f)
      ]);
    };
    exports.translate = function(xPos, yPos) {
      return exports.concatTransformationMatrix(1, 0, 0, 1, xPos, yPos);
    };
    exports.scale = function(xPos, yPos) {
      return exports.concatTransformationMatrix(xPos, 0, 0, yPos, 0, 0);
    };
    exports.rotateRadians = function(angle) {
      return exports.concatTransformationMatrix(cos(objects_1.asNumber(angle)), sin(objects_1.asNumber(angle)), -sin(objects_1.asNumber(angle)), cos(objects_1.asNumber(angle)), 0, 0);
    };
    exports.rotateDegrees = function(angle) {
      return exports.rotateRadians(rotations_1.degreesToRadians(objects_1.asNumber(angle)));
    };
    exports.skewRadians = function(xSkewAngle, ySkewAngle) {
      return exports.concatTransformationMatrix(1, tan(objects_1.asNumber(xSkewAngle)), tan(objects_1.asNumber(ySkewAngle)), 1, 0, 0);
    };
    exports.skewDegrees = function(xSkewAngle, ySkewAngle) {
      return exports.skewRadians(rotations_1.degreesToRadians(objects_1.asNumber(xSkewAngle)), rotations_1.degreesToRadians(objects_1.asNumber(ySkewAngle)));
    };
    exports.setDashPattern = function(dashArray, dashPhase) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetLineDashPattern, [
        "[" + dashArray.map(objects_1.asPDFNumber).join(" ") + "]",
        objects_1.asPDFNumber(dashPhase)
      ]);
    };
    exports.restoreDashPattern = function() {
      return exports.setDashPattern([], 0);
    };
    var LineCapStyle;
    (function(LineCapStyle2) {
      LineCapStyle2[LineCapStyle2["Butt"] = 0] = "Butt";
      LineCapStyle2[LineCapStyle2["Round"] = 1] = "Round";
      LineCapStyle2[LineCapStyle2["Projecting"] = 2] = "Projecting";
    })(LineCapStyle = exports.LineCapStyle || (exports.LineCapStyle = {}));
    exports.setLineCap = function(style) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetLineCapStyle, [objects_1.asPDFNumber(style)]);
    };
    var LineJoinStyle;
    (function(LineJoinStyle2) {
      LineJoinStyle2[LineJoinStyle2["Miter"] = 0] = "Miter";
      LineJoinStyle2[LineJoinStyle2["Round"] = 1] = "Round";
      LineJoinStyle2[LineJoinStyle2["Bevel"] = 2] = "Bevel";
    })(LineJoinStyle = exports.LineJoinStyle || (exports.LineJoinStyle = {}));
    exports.setLineJoin = function(style) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetLineJoinStyle, [objects_1.asPDFNumber(style)]);
    };
    exports.setGraphicsState = function(state) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetGraphicsStateParams, [objects_1.asPDFName(state)]);
    };
    exports.pushGraphicsState = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.PushGraphicsState);
    };
    exports.popGraphicsState = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.PopGraphicsState);
    };
    exports.setLineWidth = function(width) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetLineWidth, [objects_1.asPDFNumber(width)]);
    };
    exports.appendBezierCurve = function(x1, y1, x2, y2, x3, y3) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.AppendBezierCurve, [
        objects_1.asPDFNumber(x1),
        objects_1.asPDFNumber(y1),
        objects_1.asPDFNumber(x2),
        objects_1.asPDFNumber(y2),
        objects_1.asPDFNumber(x3),
        objects_1.asPDFNumber(y3)
      ]);
    };
    exports.appendQuadraticCurve = function(x1, y1, x2, y2) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.CurveToReplicateInitialPoint, [
        objects_1.asPDFNumber(x1),
        objects_1.asPDFNumber(y1),
        objects_1.asPDFNumber(x2),
        objects_1.asPDFNumber(y2)
      ]);
    };
    exports.closePath = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.ClosePath);
    };
    exports.moveTo = function(xPos, yPos) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.MoveTo, [objects_1.asPDFNumber(xPos), objects_1.asPDFNumber(yPos)]);
    };
    exports.lineTo = function(xPos, yPos) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.LineTo, [objects_1.asPDFNumber(xPos), objects_1.asPDFNumber(yPos)]);
    };
    exports.rectangle = function(xPos, yPos, width, height) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.AppendRectangle, [
        objects_1.asPDFNumber(xPos),
        objects_1.asPDFNumber(yPos),
        objects_1.asPDFNumber(width),
        objects_1.asPDFNumber(height)
      ]);
    };
    exports.square = function(xPos, yPos, size) {
      return exports.rectangle(xPos, yPos, size, size);
    };
    exports.stroke = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.StrokePath);
    };
    exports.fill = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.FillNonZero);
    };
    exports.fillAndStroke = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.FillNonZeroAndStroke);
    };
    exports.endPath = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.EndPath);
    };
    exports.nextLine = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.NextLine);
    };
    exports.moveText = function(x, y) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.MoveText, [objects_1.asPDFNumber(x), objects_1.asPDFNumber(y)]);
    };
    exports.showText = function(text) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.ShowText, [text]);
    };
    exports.beginText = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.BeginText);
    };
    exports.endText = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.EndText);
    };
    exports.setFontAndSize = function(name, size) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetFontAndSize, [objects_1.asPDFName(name), objects_1.asPDFNumber(size)]);
    };
    exports.setCharacterSpacing = function(spacing) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetCharacterSpacing, [objects_1.asPDFNumber(spacing)]);
    };
    exports.setWordSpacing = function(spacing) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetWordSpacing, [objects_1.asPDFNumber(spacing)]);
    };
    exports.setCharacterSqueeze = function(squeeze) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetTextHorizontalScaling, [objects_1.asPDFNumber(squeeze)]);
    };
    exports.setLineHeight = function(lineHeight) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetTextLineHeight, [objects_1.asPDFNumber(lineHeight)]);
    };
    exports.setTextRise = function(rise) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetTextRise, [objects_1.asPDFNumber(rise)]);
    };
    var TextRenderingMode;
    (function(TextRenderingMode2) {
      TextRenderingMode2[TextRenderingMode2["Fill"] = 0] = "Fill";
      TextRenderingMode2[TextRenderingMode2["Outline"] = 1] = "Outline";
      TextRenderingMode2[TextRenderingMode2["FillAndOutline"] = 2] = "FillAndOutline";
      TextRenderingMode2[TextRenderingMode2["Invisible"] = 3] = "Invisible";
      TextRenderingMode2[TextRenderingMode2["FillAndClip"] = 4] = "FillAndClip";
      TextRenderingMode2[TextRenderingMode2["OutlineAndClip"] = 5] = "OutlineAndClip";
      TextRenderingMode2[TextRenderingMode2["FillAndOutlineAndClip"] = 6] = "FillAndOutlineAndClip";
      TextRenderingMode2[TextRenderingMode2["Clip"] = 7] = "Clip";
    })(TextRenderingMode = exports.TextRenderingMode || (exports.TextRenderingMode = {}));
    exports.setTextRenderingMode = function(mode) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetTextRenderingMode, [objects_1.asPDFNumber(mode)]);
    };
    exports.setTextMatrix = function(a, b, c, d, e, f) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.SetTextMatrix, [
        objects_1.asPDFNumber(a),
        objects_1.asPDFNumber(b),
        objects_1.asPDFNumber(c),
        objects_1.asPDFNumber(d),
        objects_1.asPDFNumber(e),
        objects_1.asPDFNumber(f)
      ]);
    };
    exports.rotateAndSkewTextRadiansAndTranslate = function(rotationAngle, xSkewAngle, ySkewAngle, x, y) {
      return exports.setTextMatrix(cos(objects_1.asNumber(rotationAngle)), sin(objects_1.asNumber(rotationAngle)) + tan(objects_1.asNumber(xSkewAngle)), -sin(objects_1.asNumber(rotationAngle)) + tan(objects_1.asNumber(ySkewAngle)), cos(objects_1.asNumber(rotationAngle)), x, y);
    };
    exports.rotateAndSkewTextDegreesAndTranslate = function(rotationAngle, xSkewAngle, ySkewAngle, x, y) {
      return exports.rotateAndSkewTextRadiansAndTranslate(rotations_1.degreesToRadians(objects_1.asNumber(rotationAngle)), rotations_1.degreesToRadians(objects_1.asNumber(xSkewAngle)), rotations_1.degreesToRadians(objects_1.asNumber(ySkewAngle)), x, y);
    };
    exports.drawObject = function(name) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.DrawObject, [objects_1.asPDFName(name)]);
    };
    exports.setFillingGrayscaleColor = function(gray) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.NonStrokingColorGray, [objects_1.asPDFNumber(gray)]);
    };
    exports.setStrokingGrayscaleColor = function(gray) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.StrokingColorGray, [objects_1.asPDFNumber(gray)]);
    };
    exports.setFillingRgbColor = function(red, green, blue) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.NonStrokingColorRgb, [
        objects_1.asPDFNumber(red),
        objects_1.asPDFNumber(green),
        objects_1.asPDFNumber(blue)
      ]);
    };
    exports.setStrokingRgbColor = function(red, green, blue) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.StrokingColorRgb, [
        objects_1.asPDFNumber(red),
        objects_1.asPDFNumber(green),
        objects_1.asPDFNumber(blue)
      ]);
    };
    exports.setFillingCmykColor = function(cyan, magenta, yellow, key) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.NonStrokingColorCmyk, [
        objects_1.asPDFNumber(cyan),
        objects_1.asPDFNumber(magenta),
        objects_1.asPDFNumber(yellow),
        objects_1.asPDFNumber(key)
      ]);
    };
    exports.setStrokingCmykColor = function(cyan, magenta, yellow, key) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.StrokingColorCmyk, [
        objects_1.asPDFNumber(cyan),
        objects_1.asPDFNumber(magenta),
        objects_1.asPDFNumber(yellow),
        objects_1.asPDFNumber(key)
      ]);
    };
    exports.beginMarkedContent = function(tag) {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.BeginMarkedContent, [objects_1.asPDFName(tag)]);
    };
    exports.endMarkedContent = function() {
      return core_1.PDFOperator.of(core_1.PDFOperatorNames.EndMarkedContent);
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/api/colors.js
var require_colors = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/colors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.colorToComponents = exports.componentsToColor = exports.setStrokingColor = exports.setFillingColor = exports.cmyk = exports.rgb = exports.grayscale = exports.ColorTypes = void 0;
    var operators_1 = require_operators();
    var utils_1 = require_utils2();
    var ColorTypes;
    (function(ColorTypes2) {
      ColorTypes2["Grayscale"] = "Grayscale";
      ColorTypes2["RGB"] = "RGB";
      ColorTypes2["CMYK"] = "CMYK";
    })(ColorTypes = exports.ColorTypes || (exports.ColorTypes = {}));
    exports.grayscale = function(gray) {
      utils_1.assertRange(gray, "gray", 0, 1);
      return { type: ColorTypes.Grayscale, gray };
    };
    exports.rgb = function(red, green, blue) {
      utils_1.assertRange(red, "red", 0, 1);
      utils_1.assertRange(green, "green", 0, 1);
      utils_1.assertRange(blue, "blue", 0, 1);
      return { type: ColorTypes.RGB, red, green, blue };
    };
    exports.cmyk = function(cyan, magenta, yellow, key) {
      utils_1.assertRange(cyan, "cyan", 0, 1);
      utils_1.assertRange(magenta, "magenta", 0, 1);
      utils_1.assertRange(yellow, "yellow", 0, 1);
      utils_1.assertRange(key, "key", 0, 1);
      return { type: ColorTypes.CMYK, cyan, magenta, yellow, key };
    };
    var Grayscale = ColorTypes.Grayscale;
    var RGB = ColorTypes.RGB;
    var CMYK = ColorTypes.CMYK;
    exports.setFillingColor = function(color) {
      return color.type === Grayscale ? operators_1.setFillingGrayscaleColor(color.gray) : color.type === RGB ? operators_1.setFillingRgbColor(color.red, color.green, color.blue) : color.type === CMYK ? operators_1.setFillingCmykColor(color.cyan, color.magenta, color.yellow, color.key) : utils_1.error("Invalid color: " + JSON.stringify(color));
    };
    exports.setStrokingColor = function(color) {
      return color.type === Grayscale ? operators_1.setStrokingGrayscaleColor(color.gray) : color.type === RGB ? operators_1.setStrokingRgbColor(color.red, color.green, color.blue) : color.type === CMYK ? operators_1.setStrokingCmykColor(color.cyan, color.magenta, color.yellow, color.key) : utils_1.error("Invalid color: " + JSON.stringify(color));
    };
    exports.componentsToColor = function(comps, scale2) {
      if (scale2 === void 0) {
        scale2 = 1;
      }
      return (comps === null || comps === void 0 ? void 0 : comps.length) === 1 ? exports.grayscale(comps[0] * scale2) : (comps === null || comps === void 0 ? void 0 : comps.length) === 3 ? exports.rgb(comps[0] * scale2, comps[1] * scale2, comps[2] * scale2) : (comps === null || comps === void 0 ? void 0 : comps.length) === 4 ? exports.cmyk(comps[0] * scale2, comps[1] * scale2, comps[2] * scale2, comps[3] * scale2) : void 0;
    };
    exports.colorToComponents = function(color) {
      return color.type === Grayscale ? [color.gray] : color.type === RGB ? [color.red, color.green, color.blue] : color.type === CMYK ? [color.cyan, color.magenta, color.yellow, color.key] : utils_1.error("Invalid color: " + JSON.stringify(color));
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/api/svgPath.js
var require_svgPath = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/svgPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.svgPathToOperators = void 0;
    var operators_1 = require_operators();
    var cx = 0;
    var cy = 0;
    var px = 0;
    var py = 0;
    var sx = 0;
    var sy = 0;
    var parameters = /* @__PURE__ */ new Map([
      ["A", 7],
      ["a", 7],
      ["C", 6],
      ["c", 6],
      ["H", 1],
      ["h", 1],
      ["L", 2],
      ["l", 2],
      ["M", 2],
      ["m", 2],
      ["Q", 4],
      ["q", 4],
      ["S", 4],
      ["s", 4],
      ["T", 2],
      ["t", 2],
      ["V", 1],
      ["v", 1],
      ["Z", 0],
      ["z", 0]
    ]);
    var parse2 = function(path2) {
      var cmd;
      var ret = [];
      var args = [];
      var curArg = "";
      var foundDecimal = false;
      var params = 0;
      for (var _i = 0, path_1 = path2; _i < path_1.length; _i++) {
        var c = path_1[_i];
        if (parameters.has(c)) {
          params = parameters.get(c);
          if (cmd) {
            if (curArg.length > 0) {
              args[args.length] = +curArg;
            }
            ret[ret.length] = { cmd, args };
            args = [];
            curArg = "";
            foundDecimal = false;
          }
          cmd = c;
        } else if ([" ", ","].includes(c) || c === "-" && curArg.length > 0 && curArg[curArg.length - 1] !== "e" || c === "." && foundDecimal) {
          if (curArg.length === 0) {
            continue;
          }
          if (args.length === params) {
            ret[ret.length] = { cmd, args };
            args = [+curArg];
            if (cmd === "M") {
              cmd = "L";
            }
            if (cmd === "m") {
              cmd = "l";
            }
          } else {
            args[args.length] = +curArg;
          }
          foundDecimal = c === ".";
          curArg = ["-", "."].includes(c) ? c : "";
        } else {
          curArg += c;
          if (c === ".") {
            foundDecimal = true;
          }
        }
      }
      if (curArg.length > 0) {
        if (args.length === params) {
          ret[ret.length] = { cmd, args };
          args = [+curArg];
          if (cmd === "M") {
            cmd = "L";
          }
          if (cmd === "m") {
            cmd = "l";
          }
        } else {
          args[args.length] = +curArg;
        }
      }
      ret[ret.length] = { cmd, args };
      return ret;
    };
    var apply = function(commands) {
      cx = cy = px = py = sx = sy = 0;
      var cmds = [];
      for (var i = 0; i < commands.length; i++) {
        var c = commands[i];
        if (c.cmd && typeof runners[c.cmd] === "function") {
          var cmd = runners[c.cmd](c.args);
          if (Array.isArray(cmd)) {
            cmds = cmds.concat(cmd);
          } else {
            cmds.push(cmd);
          }
        }
      }
      return cmds;
    };
    var runners = {
      M: function(a) {
        cx = a[0];
        cy = a[1];
        px = py = null;
        sx = cx;
        sy = cy;
        return operators_1.moveTo(cx, cy);
      },
      m: function(a) {
        cx += a[0];
        cy += a[1];
        px = py = null;
        sx = cx;
        sy = cy;
        return operators_1.moveTo(cx, cy);
      },
      C: function(a) {
        cx = a[4];
        cy = a[5];
        px = a[2];
        py = a[3];
        return operators_1.appendBezierCurve(a[0], a[1], a[2], a[3], a[4], a[5]);
      },
      c: function(a) {
        var cmd = operators_1.appendBezierCurve(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);
        px = cx + a[2];
        py = cy + a[3];
        cx += a[4];
        cy += a[5];
        return cmd;
      },
      S: function(a) {
        if (px === null || py === null) {
          px = cx;
          py = cy;
        }
        var cmd = operators_1.appendBezierCurve(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);
        px = a[0];
        py = a[1];
        cx = a[2];
        cy = a[3];
        return cmd;
      },
      s: function(a) {
        if (px === null || py === null) {
          px = cx;
          py = cy;
        }
        var cmd = operators_1.appendBezierCurve(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);
        px = cx + a[0];
        py = cy + a[1];
        cx += a[2];
        cy += a[3];
        return cmd;
      },
      Q: function(a) {
        px = a[0];
        py = a[1];
        cx = a[2];
        cy = a[3];
        return operators_1.appendQuadraticCurve(a[0], a[1], cx, cy);
      },
      q: function(a) {
        var cmd = operators_1.appendQuadraticCurve(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);
        px = cx + a[0];
        py = cy + a[1];
        cx += a[2];
        cy += a[3];
        return cmd;
      },
      T: function(a) {
        if (px === null || py === null) {
          px = cx;
          py = cy;
        } else {
          px = cx - (px - cx);
          py = cy - (py - cy);
        }
        var cmd = operators_1.appendQuadraticCurve(px, py, a[0], a[1]);
        px = cx - (px - cx);
        py = cy - (py - cy);
        cx = a[0];
        cy = a[1];
        return cmd;
      },
      t: function(a) {
        if (px === null || py === null) {
          px = cx;
          py = cy;
        } else {
          px = cx - (px - cx);
          py = cy - (py - cy);
        }
        var cmd = operators_1.appendQuadraticCurve(px, py, cx + a[0], cy + a[1]);
        cx += a[0];
        cy += a[1];
        return cmd;
      },
      A: function(a) {
        var cmds = solveArc(cx, cy, a);
        cx = a[5];
        cy = a[6];
        return cmds;
      },
      a: function(a) {
        a[5] += cx;
        a[6] += cy;
        var cmds = solveArc(cx, cy, a);
        cx = a[5];
        cy = a[6];
        return cmds;
      },
      L: function(a) {
        cx = a[0];
        cy = a[1];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      l: function(a) {
        cx += a[0];
        cy += a[1];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      H: function(a) {
        cx = a[0];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      h: function(a) {
        cx += a[0];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      V: function(a) {
        cy = a[0];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      v: function(a) {
        cy += a[0];
        px = py = null;
        return operators_1.lineTo(cx, cy);
      },
      Z: function() {
        var cmd = operators_1.closePath();
        cx = sx;
        cy = sy;
        return cmd;
      },
      z: function() {
        var cmd = operators_1.closePath();
        cx = sx;
        cy = sy;
        return cmd;
      }
    };
    var solveArc = function(x, y, coords) {
      var rx = coords[0], ry = coords[1], rot = coords[2], large = coords[3], sweep = coords[4], ex = coords[5], ey = coords[6];
      var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);
      var cmds = [];
      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
        var seg = segs_1[_i];
        var bez = segmentToBezier.apply(void 0, seg);
        cmds.push(operators_1.appendBezierCurve.apply(void 0, bez));
      }
      return cmds;
    };
    var arcToSegments = function(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
      var th = rotateX * (Math.PI / 180);
      var sinTh = Math.sin(th);
      var cosTh = Math.cos(th);
      rx = Math.abs(rx);
      ry = Math.abs(ry);
      px = cosTh * (ox - x) * 0.5 + sinTh * (oy - y) * 0.5;
      py = cosTh * (oy - y) * 0.5 - sinTh * (ox - x) * 0.5;
      var pl = px * px / (rx * rx) + py * py / (ry * ry);
      if (pl > 1) {
        pl = Math.sqrt(pl);
        rx *= pl;
        ry *= pl;
      }
      var a00 = cosTh / rx;
      var a01 = sinTh / rx;
      var a10 = -sinTh / ry;
      var a11 = cosTh / ry;
      var x0 = a00 * ox + a01 * oy;
      var y0 = a10 * ox + a11 * oy;
      var x1 = a00 * x + a01 * y;
      var y1 = a10 * x + a11 * y;
      var d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
      var sfactorSq = 1 / d - 0.25;
      if (sfactorSq < 0) {
        sfactorSq = 0;
      }
      var sfactor = Math.sqrt(sfactorSq);
      if (sweep === large) {
        sfactor = -sfactor;
      }
      var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
      var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
      var th0 = Math.atan2(y0 - yc, x0 - xc);
      var th1 = Math.atan2(y1 - yc, x1 - xc);
      var thArc = th1 - th0;
      if (thArc < 0 && sweep === 1) {
        thArc += 2 * Math.PI;
      } else if (thArc > 0 && sweep === 0) {
        thArc -= 2 * Math.PI;
      }
      var segments = Math.ceil(Math.abs(thArc / (Math.PI * 0.5 + 1e-3)));
      var result = [];
      for (var i = 0; i < segments; i++) {
        var th2 = th0 + i * thArc / segments;
        var th3 = th0 + (i + 1) * thArc / segments;
        result[i] = [xc, yc, th2, th3, rx, ry, sinTh, cosTh];
      }
      return result;
    };
    var segmentToBezier = function(cx1, cy1, th0, th1, rx, ry, sinTh, cosTh) {
      var a00 = cosTh * rx;
      var a01 = -sinTh * ry;
      var a10 = sinTh * rx;
      var a11 = cosTh * ry;
      var thHalf = 0.5 * (th1 - th0);
      var t2 = 8 / 3 * Math.sin(thHalf * 0.5) * Math.sin(thHalf * 0.5) / Math.sin(thHalf);
      var x1 = cx1 + Math.cos(th0) - t2 * Math.sin(th0);
      var y1 = cy1 + Math.sin(th0) + t2 * Math.cos(th0);
      var x3 = cx1 + Math.cos(th1);
      var y3 = cy1 + Math.sin(th1);
      var x2 = x3 + t2 * Math.sin(th1);
      var y2 = y3 - t2 * Math.cos(th1);
      var result = [
        a00 * x1 + a01 * y1,
        a10 * x1 + a11 * y1,
        a00 * x2 + a01 * y2,
        a10 * x2 + a11 * y2,
        a00 * x3 + a01 * y3,
        a10 * x3 + a11 * y3
      ];
      return result;
    };
    exports.svgPathToOperators = function(path2) {
      return apply(parse2(path2));
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/api/operations.js
var require_operations = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/operations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.drawOptionList = exports.drawTextField = exports.drawTextLines = exports.drawButton = exports.drawRadioButton = exports.drawCheckBox = exports.rotateInPlace = exports.drawCheckMark = exports.drawSvgPath = exports.drawEllipse = exports.drawEllipsePath = exports.drawRectangle = exports.drawLine = exports.drawPage = exports.drawImage = exports.drawLinesOfText = exports.drawText = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var colors_1 = require_colors();
    var operators_1 = require_operators();
    var rotations_1 = require_rotations();
    var svgPath_1 = require_svgPath();
    var objects_1 = require_objects2();
    exports.drawText = function(line, options) {
      return [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        operators_1.beginText(),
        colors_1.setFillingColor(options.color),
        operators_1.setFontAndSize(options.font, options.size),
        operators_1.rotateAndSkewTextRadiansAndTranslate(rotations_1.toRadians(options.rotate), rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew), options.x, options.y),
        operators_1.showText(line),
        operators_1.endText(),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    exports.drawLinesOfText = function(lines, options) {
      var operators = [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        operators_1.beginText(),
        colors_1.setFillingColor(options.color),
        operators_1.setFontAndSize(options.font, options.size),
        operators_1.setLineHeight(options.lineHeight),
        operators_1.rotateAndSkewTextRadiansAndTranslate(rotations_1.toRadians(options.rotate), rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew), options.x, options.y)
      ].filter(Boolean);
      for (var idx = 0, len = lines.length; idx < len; idx++) {
        operators.push(operators_1.showText(lines[idx]), operators_1.nextLine());
      }
      operators.push(operators_1.endText(), operators_1.popGraphicsState());
      return operators;
    };
    exports.drawImage = function(name, options) {
      return [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        operators_1.translate(options.x, options.y),
        operators_1.rotateRadians(rotations_1.toRadians(options.rotate)),
        operators_1.scale(options.width, options.height),
        operators_1.skewRadians(rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew)),
        operators_1.drawObject(name),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    exports.drawPage = function(name, options) {
      return [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        operators_1.translate(options.x, options.y),
        operators_1.rotateRadians(rotations_1.toRadians(options.rotate)),
        operators_1.scale(options.xScale, options.yScale),
        operators_1.skewRadians(rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew)),
        operators_1.drawObject(name),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    exports.drawLine = function(options) {
      var _a, _b;
      return [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        options.color && colors_1.setStrokingColor(options.color),
        operators_1.setLineWidth(options.thickness),
        operators_1.setDashPattern((_a = options.dashArray) !== null && _a !== void 0 ? _a : [], (_b = options.dashPhase) !== null && _b !== void 0 ? _b : 0),
        operators_1.moveTo(options.start.x, options.start.y),
        options.lineCap && operators_1.setLineCap(options.lineCap),
        operators_1.moveTo(options.start.x, options.start.y),
        operators_1.lineTo(options.end.x, options.end.y),
        operators_1.stroke(),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    exports.drawRectangle = function(options) {
      var _a, _b;
      return [
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        options.color && colors_1.setFillingColor(options.color),
        options.borderColor && colors_1.setStrokingColor(options.borderColor),
        operators_1.setLineWidth(options.borderWidth),
        options.borderLineCap && operators_1.setLineCap(options.borderLineCap),
        operators_1.setDashPattern((_a = options.borderDashArray) !== null && _a !== void 0 ? _a : [], (_b = options.borderDashPhase) !== null && _b !== void 0 ? _b : 0),
        operators_1.translate(options.x, options.y),
        operators_1.rotateRadians(rotations_1.toRadians(options.rotate)),
        operators_1.skewRadians(rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew)),
        operators_1.moveTo(0, 0),
        operators_1.lineTo(0, options.height),
        operators_1.lineTo(options.width, options.height),
        operators_1.lineTo(options.width, 0),
        operators_1.closePath(),
        // prettier-ignore
        options.color && options.borderWidth ? operators_1.fillAndStroke() : options.color ? operators_1.fill() : options.borderColor ? operators_1.stroke() : operators_1.closePath(),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
    exports.drawEllipsePath = function(config) {
      var x = objects_1.asNumber(config.x);
      var y = objects_1.asNumber(config.y);
      var xScale = objects_1.asNumber(config.xScale);
      var yScale = objects_1.asNumber(config.yScale);
      x -= xScale;
      y -= yScale;
      var ox = xScale * KAPPA;
      var oy = yScale * KAPPA;
      var xe = x + xScale * 2;
      var ye = y + yScale * 2;
      var xm = x + xScale;
      var ym = y + yScale;
      return [
        operators_1.pushGraphicsState(),
        operators_1.moveTo(x, ym),
        operators_1.appendBezierCurve(x, ym - oy, xm - ox, y, xm, y),
        operators_1.appendBezierCurve(xm + ox, y, xe, ym - oy, xe, ym),
        operators_1.appendBezierCurve(xe, ym + oy, xm + ox, ye, xm, ye),
        operators_1.appendBezierCurve(xm - ox, ye, x, ym + oy, x, ym),
        operators_1.popGraphicsState()
      ];
    };
    var drawEllipseCurves = function(config) {
      var centerX = objects_1.asNumber(config.x);
      var centerY = objects_1.asNumber(config.y);
      var xScale = objects_1.asNumber(config.xScale);
      var yScale = objects_1.asNumber(config.yScale);
      var x = -xScale;
      var y = -yScale;
      var ox = xScale * KAPPA;
      var oy = yScale * KAPPA;
      var xe = x + xScale * 2;
      var ye = y + yScale * 2;
      var xm = x + xScale;
      var ym = y + yScale;
      return [
        operators_1.translate(centerX, centerY),
        operators_1.rotateRadians(rotations_1.toRadians(config.rotate)),
        operators_1.moveTo(x, ym),
        operators_1.appendBezierCurve(x, ym - oy, xm - ox, y, xm, y),
        operators_1.appendBezierCurve(xm + ox, y, xe, ym - oy, xe, ym),
        operators_1.appendBezierCurve(xe, ym + oy, xm + ox, ye, xm, ye),
        operators_1.appendBezierCurve(xm - ox, ye, x, ym + oy, x, ym)
      ];
    };
    exports.drawEllipse = function(options) {
      var _a, _b, _c;
      return tslib_1.__spreadArrays([
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        options.color && colors_1.setFillingColor(options.color),
        options.borderColor && colors_1.setStrokingColor(options.borderColor),
        operators_1.setLineWidth(options.borderWidth),
        options.borderLineCap && operators_1.setLineCap(options.borderLineCap),
        operators_1.setDashPattern((_a = options.borderDashArray) !== null && _a !== void 0 ? _a : [], (_b = options.borderDashPhase) !== null && _b !== void 0 ? _b : 0)
      ], options.rotate === void 0 ? exports.drawEllipsePath({
        x: options.x,
        y: options.y,
        xScale: options.xScale,
        yScale: options.yScale
      }) : drawEllipseCurves({
        x: options.x,
        y: options.y,
        xScale: options.xScale,
        yScale: options.yScale,
        rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : rotations_1.degrees(0)
      }), [
        // prettier-ignore
        options.color && options.borderWidth ? operators_1.fillAndStroke() : options.color ? operators_1.fill() : options.borderColor ? operators_1.stroke() : operators_1.closePath(),
        operators_1.popGraphicsState()
      ]).filter(Boolean);
    };
    exports.drawSvgPath = function(path2, options) {
      var _a, _b, _c;
      return tslib_1.__spreadArrays([
        operators_1.pushGraphicsState(),
        options.graphicsState && operators_1.setGraphicsState(options.graphicsState),
        operators_1.translate(options.x, options.y),
        operators_1.rotateRadians(rotations_1.toRadians((_a = options.rotate) !== null && _a !== void 0 ? _a : rotations_1.degrees(0))),
        // SVG path Y axis is opposite pdf-lib's
        options.scale ? operators_1.scale(options.scale, -options.scale) : operators_1.scale(1, -1),
        options.color && colors_1.setFillingColor(options.color),
        options.borderColor && colors_1.setStrokingColor(options.borderColor),
        options.borderWidth && operators_1.setLineWidth(options.borderWidth),
        options.borderLineCap && operators_1.setLineCap(options.borderLineCap),
        operators_1.setDashPattern((_b = options.borderDashArray) !== null && _b !== void 0 ? _b : [], (_c = options.borderDashPhase) !== null && _c !== void 0 ? _c : 0)
      ], svgPath_1.svgPathToOperators(path2), [
        // prettier-ignore
        options.color && options.borderWidth ? operators_1.fillAndStroke() : options.color ? operators_1.fill() : options.borderColor ? operators_1.stroke() : operators_1.closePath(),
        operators_1.popGraphicsState()
      ]).filter(Boolean);
    };
    exports.drawCheckMark = function(options) {
      var size = objects_1.asNumber(options.size);
      var p2x = -1 + 0.75;
      var p2y = -1 + 0.51;
      var p3y = 1 - 0.525;
      var p3x = 1 - 0.31;
      var p1x = -1 + 0.325;
      var p1y = -((p1x - p2x) * (p3x - p2x)) / (p3y - p2y) + p2y;
      return [
        operators_1.pushGraphicsState(),
        options.color && colors_1.setStrokingColor(options.color),
        operators_1.setLineWidth(options.thickness),
        operators_1.translate(options.x, options.y),
        operators_1.moveTo(p1x * size, p1y * size),
        operators_1.lineTo(p2x * size, p2y * size),
        operators_1.lineTo(p3x * size, p3y * size),
        operators_1.stroke(),
        operators_1.popGraphicsState()
      ].filter(Boolean);
    };
    exports.rotateInPlace = function(options) {
      return options.rotation === 0 ? [
        operators_1.translate(0, 0),
        operators_1.rotateDegrees(0)
      ] : options.rotation === 90 ? [
        operators_1.translate(options.width, 0),
        operators_1.rotateDegrees(90)
      ] : options.rotation === 180 ? [
        operators_1.translate(options.width, options.height),
        operators_1.rotateDegrees(180)
      ] : options.rotation === 270 ? [
        operators_1.translate(0, options.height),
        operators_1.rotateDegrees(270)
      ] : [];
    };
    exports.drawCheckBox = function(options) {
      var outline = exports.drawRectangle({
        x: options.x,
        y: options.y,
        width: options.width,
        height: options.height,
        borderWidth: options.borderWidth,
        color: options.color,
        borderColor: options.borderColor,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      if (!options.filled)
        return outline;
      var width = objects_1.asNumber(options.width);
      var height = objects_1.asNumber(options.height);
      var checkMarkSize = Math.min(width, height) / 2;
      var checkMark = exports.drawCheckMark({
        x: width / 2,
        y: height / 2,
        size: checkMarkSize,
        thickness: options.thickness,
        color: options.markColor
      });
      return tslib_1.__spreadArrays([operators_1.pushGraphicsState()], outline, checkMark, [operators_1.popGraphicsState()]);
    };
    exports.drawRadioButton = function(options) {
      var width = objects_1.asNumber(options.width);
      var height = objects_1.asNumber(options.height);
      var outlineScale = Math.min(width, height) / 2;
      var outline = exports.drawEllipse({
        x: options.x,
        y: options.y,
        xScale: outlineScale,
        yScale: outlineScale,
        color: options.color,
        borderColor: options.borderColor,
        borderWidth: options.borderWidth
      });
      if (!options.filled)
        return outline;
      var dot = exports.drawEllipse({
        x: options.x,
        y: options.y,
        xScale: outlineScale * 0.45,
        yScale: outlineScale * 0.45,
        color: options.dotColor,
        borderColor: void 0,
        borderWidth: 0
      });
      return tslib_1.__spreadArrays([operators_1.pushGraphicsState()], outline, dot, [operators_1.popGraphicsState()]);
    };
    exports.drawButton = function(options) {
      var x = objects_1.asNumber(options.x);
      var y = objects_1.asNumber(options.y);
      var width = objects_1.asNumber(options.width);
      var height = objects_1.asNumber(options.height);
      var background = exports.drawRectangle({
        x,
        y,
        width,
        height,
        borderWidth: options.borderWidth,
        color: options.color,
        borderColor: options.borderColor,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      var lines = exports.drawTextLines(options.textLines, {
        color: options.textColor,
        font: options.font,
        size: options.fontSize,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      return tslib_1.__spreadArrays([operators_1.pushGraphicsState()], background, lines, [operators_1.popGraphicsState()]);
    };
    exports.drawTextLines = function(lines, options) {
      var operators = [
        operators_1.beginText(),
        colors_1.setFillingColor(options.color),
        operators_1.setFontAndSize(options.font, options.size)
      ];
      for (var idx = 0, len = lines.length; idx < len; idx++) {
        var _a = lines[idx], encoded = _a.encoded, x = _a.x, y = _a.y;
        operators.push(operators_1.rotateAndSkewTextRadiansAndTranslate(rotations_1.toRadians(options.rotate), rotations_1.toRadians(options.xSkew), rotations_1.toRadians(options.ySkew), x, y), operators_1.showText(encoded));
      }
      operators.push(operators_1.endText());
      return operators;
    };
    exports.drawTextField = function(options) {
      var x = objects_1.asNumber(options.x);
      var y = objects_1.asNumber(options.y);
      var width = objects_1.asNumber(options.width);
      var height = objects_1.asNumber(options.height);
      var borderWidth = objects_1.asNumber(options.borderWidth);
      var padding = objects_1.asNumber(options.padding);
      var clipX = x + borderWidth / 2 + padding;
      var clipY = y + borderWidth / 2 + padding;
      var clipWidth = width - (borderWidth / 2 + padding) * 2;
      var clipHeight = height - (borderWidth / 2 + padding) * 2;
      var clippingArea = [
        operators_1.moveTo(clipX, clipY),
        operators_1.lineTo(clipX, clipY + clipHeight),
        operators_1.lineTo(clipX + clipWidth, clipY + clipHeight),
        operators_1.lineTo(clipX + clipWidth, clipY),
        operators_1.closePath(),
        operators_1.clip(),
        operators_1.endPath()
      ];
      var background = exports.drawRectangle({
        x,
        y,
        width,
        height,
        borderWidth: options.borderWidth,
        color: options.color,
        borderColor: options.borderColor,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      var lines = exports.drawTextLines(options.textLines, {
        color: options.textColor,
        font: options.font,
        size: options.fontSize,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      var markedContent = tslib_1.__spreadArrays([
        operators_1.beginMarkedContent("Tx"),
        operators_1.pushGraphicsState()
      ], lines, [
        operators_1.popGraphicsState(),
        operators_1.endMarkedContent()
      ]);
      return tslib_1.__spreadArrays([
        operators_1.pushGraphicsState()
      ], background, clippingArea, markedContent, [
        operators_1.popGraphicsState()
      ]);
    };
    exports.drawOptionList = function(options) {
      var x = objects_1.asNumber(options.x);
      var y = objects_1.asNumber(options.y);
      var width = objects_1.asNumber(options.width);
      var height = objects_1.asNumber(options.height);
      var lineHeight = objects_1.asNumber(options.lineHeight);
      var borderWidth = objects_1.asNumber(options.borderWidth);
      var padding = objects_1.asNumber(options.padding);
      var clipX = x + borderWidth / 2 + padding;
      var clipY = y + borderWidth / 2 + padding;
      var clipWidth = width - (borderWidth / 2 + padding) * 2;
      var clipHeight = height - (borderWidth / 2 + padding) * 2;
      var clippingArea = [
        operators_1.moveTo(clipX, clipY),
        operators_1.lineTo(clipX, clipY + clipHeight),
        operators_1.lineTo(clipX + clipWidth, clipY + clipHeight),
        operators_1.lineTo(clipX + clipWidth, clipY),
        operators_1.closePath(),
        operators_1.clip(),
        operators_1.endPath()
      ];
      var background = exports.drawRectangle({
        x,
        y,
        width,
        height,
        borderWidth: options.borderWidth,
        color: options.color,
        borderColor: options.borderColor,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      var highlights = [];
      for (var idx = 0, len = options.selectedLines.length; idx < len; idx++) {
        var line = options.textLines[options.selectedLines[idx]];
        highlights.push.apply(highlights, exports.drawRectangle({
          x: line.x - padding,
          y: line.y - (lineHeight - line.height) / 2,
          width: width - borderWidth,
          height: line.height + (lineHeight - line.height) / 2,
          borderWidth: 0,
          color: options.selectedColor,
          borderColor: void 0,
          rotate: rotations_1.degrees(0),
          xSkew: rotations_1.degrees(0),
          ySkew: rotations_1.degrees(0)
        }));
      }
      var lines = exports.drawTextLines(options.textLines, {
        color: options.textColor,
        font: options.font,
        size: options.fontSize,
        rotate: rotations_1.degrees(0),
        xSkew: rotations_1.degrees(0),
        ySkew: rotations_1.degrees(0)
      });
      var markedContent = tslib_1.__spreadArrays([
        operators_1.beginMarkedContent("Tx"),
        operators_1.pushGraphicsState()
      ], lines, [
        operators_1.popGraphicsState(),
        operators_1.endMarkedContent()
      ]);
      return tslib_1.__spreadArrays([
        operators_1.pushGraphicsState()
      ], background, highlights, clippingArea, markedContent, [
        operators_1.popGraphicsState()
      ]);
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/api/errors.js
var require_errors3 = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidMaxLengthError = exports.ExceededMaxLengthError = exports.CombedTextLayoutError = exports.RichTextFieldReadError = exports.FieldExistsAsNonTerminalError = exports.InvalidFieldNamePartError = exports.FieldAlreadyExistsError = exports.MissingOnValueCheckError = exports.UnexpectedFieldTypeError = exports.NoSuchFieldError = exports.RemovePageFromEmptyDocumentError = exports.ForeignPageError = exports.FontkitNotRegisteredError = exports.EncryptedPDFError = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var EncryptedPDFError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(EncryptedPDFError2, _super);
        function EncryptedPDFError2() {
          var _this = this;
          var msg = "Input document to `PDFDocument.load` is encrypted. You can use `PDFDocument.load(..., { ignoreEncryption: true })` if you wish to load the document anyways.";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return EncryptedPDFError2;
      }(Error)
    );
    exports.EncryptedPDFError = EncryptedPDFError;
    var FontkitNotRegisteredError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(FontkitNotRegisteredError2, _super);
        function FontkitNotRegisteredError2() {
          var _this = this;
          var msg = "Input to `PDFDocument.embedFont` was a custom font, but no `fontkit` instance was found. You must register a `fontkit` instance with `PDFDocument.registerFontkit(...)` before embedding custom fonts.";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return FontkitNotRegisteredError2;
      }(Error)
    );
    exports.FontkitNotRegisteredError = FontkitNotRegisteredError;
    var ForeignPageError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(ForeignPageError2, _super);
        function ForeignPageError2() {
          var _this = this;
          var msg = "A `page` passed to `PDFDocument.addPage` or `PDFDocument.insertPage` was from a different (foreign) PDF document. If you want to copy pages from one PDFDocument to another, you must use `PDFDocument.copyPages(...)` to copy the pages before adding or inserting them.";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return ForeignPageError2;
      }(Error)
    );
    exports.ForeignPageError = ForeignPageError;
    var RemovePageFromEmptyDocumentError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(RemovePageFromEmptyDocumentError2, _super);
        function RemovePageFromEmptyDocumentError2() {
          var _this = this;
          var msg = "PDFDocument has no pages so `PDFDocument.removePage` cannot be called";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return RemovePageFromEmptyDocumentError2;
      }(Error)
    );
    exports.RemovePageFromEmptyDocumentError = RemovePageFromEmptyDocumentError;
    var NoSuchFieldError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(NoSuchFieldError2, _super);
        function NoSuchFieldError2(name) {
          var _this = this;
          var msg = 'PDFDocument has no form field with the name "' + name + '"';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return NoSuchFieldError2;
      }(Error)
    );
    exports.NoSuchFieldError = NoSuchFieldError;
    var UnexpectedFieldTypeError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(UnexpectedFieldTypeError2, _super);
        function UnexpectedFieldTypeError2(name, expected, actual) {
          var _a, _b;
          var _this = this;
          var expectedType = expected === null || expected === void 0 ? void 0 : expected.name;
          var actualType = (_b = (_a = actual === null || actual === void 0 ? void 0 : actual.constructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : actual;
          var msg = 'Expected field "' + name + '" to be of type ' + expectedType + ", " + ("but it is actually of type " + actualType);
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return UnexpectedFieldTypeError2;
      }(Error)
    );
    exports.UnexpectedFieldTypeError = UnexpectedFieldTypeError;
    var MissingOnValueCheckError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(MissingOnValueCheckError2, _super);
        function MissingOnValueCheckError2(onValue) {
          var _this = this;
          var msg = 'Failed to select check box due to missing onValue: "' + onValue + '"';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return MissingOnValueCheckError2;
      }(Error)
    );
    exports.MissingOnValueCheckError = MissingOnValueCheckError;
    var FieldAlreadyExistsError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(FieldAlreadyExistsError2, _super);
        function FieldAlreadyExistsError2(name) {
          var _this = this;
          var msg = 'A field already exists with the specified name: "' + name + '"';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return FieldAlreadyExistsError2;
      }(Error)
    );
    exports.FieldAlreadyExistsError = FieldAlreadyExistsError;
    var InvalidFieldNamePartError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(InvalidFieldNamePartError2, _super);
        function InvalidFieldNamePartError2(namePart) {
          var _this = this;
          var msg = 'Field name contains invalid component: "' + namePart + '"';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return InvalidFieldNamePartError2;
      }(Error)
    );
    exports.InvalidFieldNamePartError = InvalidFieldNamePartError;
    var FieldExistsAsNonTerminalError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(FieldExistsAsNonTerminalError2, _super);
        function FieldExistsAsNonTerminalError2(name) {
          var _this = this;
          var msg = 'A non-terminal field already exists with the specified name: "' + name + '"';
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return FieldExistsAsNonTerminalError2;
      }(Error)
    );
    exports.FieldExistsAsNonTerminalError = FieldExistsAsNonTerminalError;
    var RichTextFieldReadError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(RichTextFieldReadError2, _super);
        function RichTextFieldReadError2(fieldName) {
          var _this = this;
          var msg = "Reading rich text fields is not supported: Attempted to read rich text field: " + fieldName;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return RichTextFieldReadError2;
      }(Error)
    );
    exports.RichTextFieldReadError = RichTextFieldReadError;
    var CombedTextLayoutError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(CombedTextLayoutError2, _super);
        function CombedTextLayoutError2(lineLength, cellCount) {
          var _this = this;
          var msg = "Failed to layout combed text as lineLength=" + lineLength + " is greater than cellCount=" + cellCount;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return CombedTextLayoutError2;
      }(Error)
    );
    exports.CombedTextLayoutError = CombedTextLayoutError;
    var ExceededMaxLengthError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(ExceededMaxLengthError2, _super);
        function ExceededMaxLengthError2(textLength, maxLength, name) {
          var _this = this;
          var msg = "Attempted to set text with length=" + textLength + " for TextField with maxLength=" + maxLength + " and name=" + name;
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return ExceededMaxLengthError2;
      }(Error)
    );
    exports.ExceededMaxLengthError = ExceededMaxLengthError;
    var InvalidMaxLengthError = (
      /** @class */
      function(_super) {
        tslib_1.__extends(InvalidMaxLengthError2, _super);
        function InvalidMaxLengthError2(textLength, maxLength, name) {
          var _this = this;
          var msg = "Attempted to set maxLength=" + maxLength + ", which is less than " + textLength + ", the length of this field's current value (name=" + name + ")";
          _this = _super.call(this, msg) || this;
          return _this;
        }
        return InvalidMaxLengthError2;
      }(Error)
    );
    exports.InvalidMaxLengthError = InvalidMaxLengthError;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/text/alignment.js
var require_alignment = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/text/alignment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextAlignment = void 0;
    var TextAlignment;
    (function(TextAlignment2) {
      TextAlignment2[TextAlignment2["Left"] = 0] = "Left";
      TextAlignment2[TextAlignment2["Center"] = 1] = "Center";
      TextAlignment2[TextAlignment2["Right"] = 2] = "Right";
    })(TextAlignment = exports.TextAlignment || (exports.TextAlignment = {}));
  }
});

// ../../../node_modules/pdf-lib/cjs/api/text/layout.js
var require_layout = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/text/layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.layoutSinglelineText = exports.layoutCombedText = exports.layoutMultilineText = void 0;
    var errors_1 = require_errors3();
    var alignment_1 = require_alignment();
    var utils_1 = require_utils2();
    var MIN_FONT_SIZE = 4;
    var MAX_FONT_SIZE = 500;
    var computeFontSize = function(lines, font, bounds, multiline) {
      if (multiline === void 0) {
        multiline = false;
      }
      var fontSize = MIN_FONT_SIZE;
      while (fontSize < MAX_FONT_SIZE) {
        var linesUsed = 0;
        for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {
          linesUsed += 1;
          var line = lines[lineIdx];
          var words = line.split(" ");
          var spaceInLineRemaining = bounds.width;
          for (var idx = 0, len = words.length; idx < len; idx++) {
            var isLastWord = idx === len - 1;
            var word = isLastWord ? words[idx] : words[idx] + " ";
            var widthOfWord = font.widthOfTextAtSize(word, fontSize);
            spaceInLineRemaining -= widthOfWord;
            if (spaceInLineRemaining <= 0) {
              linesUsed += 1;
              spaceInLineRemaining = bounds.width - widthOfWord;
            }
          }
        }
        if (!multiline && linesUsed > lines.length)
          return fontSize - 1;
        var height = font.heightAtSize(fontSize);
        var lineHeight = height + height * 0.2;
        var totalHeight = lineHeight * linesUsed;
        if (totalHeight > Math.abs(bounds.height))
          return fontSize - 1;
        fontSize += 1;
      }
      return fontSize;
    };
    var computeCombedFontSize = function(line, font, bounds, cellCount) {
      var cellWidth = bounds.width / cellCount;
      var cellHeight = bounds.height;
      var fontSize = MIN_FONT_SIZE;
      var chars2 = utils_1.charSplit(line);
      while (fontSize < MAX_FONT_SIZE) {
        for (var idx = 0, len = chars2.length; idx < len; idx++) {
          var c = chars2[idx];
          var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;
          if (tooLong)
            return fontSize - 1;
        }
        var height = font.heightAtSize(fontSize, { descender: false });
        if (height > cellHeight)
          return fontSize - 1;
        fontSize += 1;
      }
      return fontSize;
    };
    var lastIndexOfWhitespace = function(line) {
      for (var idx = line.length; idx > 0; idx--) {
        if (/\s/.test(line[idx]))
          return idx;
      }
      return void 0;
    };
    var splitOutLines = function(input, maxWidth, font, fontSize) {
      var _a;
      var lastWhitespaceIdx = input.length;
      while (lastWhitespaceIdx > 0) {
        var line = input.substring(0, lastWhitespaceIdx);
        var encoded = font.encodeText(line);
        var width = font.widthOfTextAtSize(line, fontSize);
        if (width < maxWidth) {
          var remainder = input.substring(lastWhitespaceIdx) || void 0;
          return { line, encoded, width, remainder };
        }
        lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;
      }
      return {
        line: input,
        encoded: font.encodeText(input),
        width: font.widthOfTextAtSize(input, fontSize),
        remainder: void 0
      };
    };
    exports.layoutMultilineText = function(text, _a) {
      var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;
      var lines = utils_1.lineSplit(utils_1.cleanText(text));
      if (fontSize === void 0 || fontSize === 0) {
        fontSize = computeFontSize(lines, font, bounds, true);
      }
      var height = font.heightAtSize(fontSize);
      var lineHeight = height + height * 0.2;
      var textLines = [];
      var minX = bounds.x;
      var minY = bounds.y;
      var maxX = bounds.x + bounds.width;
      var maxY = bounds.y + bounds.height;
      var y = bounds.y + bounds.height;
      for (var idx = 0, len = lines.length; idx < len; idx++) {
        var prevRemainder = lines[idx];
        while (prevRemainder !== void 0) {
          var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize), line = _b.line, encoded = _b.encoded, width = _b.width, remainder = _b.remainder;
          var x = alignment === alignment_1.TextAlignment.Left ? bounds.x : alignment === alignment_1.TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === alignment_1.TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;
          y -= lineHeight;
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x + width > maxX)
            maxX = x + width;
          if (y + height > maxY)
            maxY = y + height;
          textLines.push({ text: line, encoded, width, height, x, y });
          prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();
        }
      }
      return {
        fontSize,
        lineHeight,
        lines: textLines,
        bounds: {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        }
      };
    };
    exports.layoutCombedText = function(text, _a) {
      var fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds, cellCount = _a.cellCount;
      var line = utils_1.mergeLines(utils_1.cleanText(text));
      if (line.length > cellCount) {
        throw new errors_1.CombedTextLayoutError(line.length, cellCount);
      }
      if (fontSize === void 0 || fontSize === 0) {
        fontSize = computeCombedFontSize(line, font, bounds, cellCount);
      }
      var cellWidth = bounds.width / cellCount;
      var height = font.heightAtSize(fontSize, { descender: false });
      var y = bounds.y + (bounds.height / 2 - height / 2);
      var cells = [];
      var minX = bounds.x;
      var minY = bounds.y;
      var maxX = bounds.x + bounds.width;
      var maxY = bounds.y + bounds.height;
      var cellOffset = 0;
      var charOffset = 0;
      while (cellOffset < cellCount) {
        var _b = utils_1.charAtIndex(line, charOffset), char = _b[0], charLength = _b[1];
        var encoded = font.encodeText(char);
        var width = font.widthOfTextAtSize(char, fontSize);
        var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);
        var x = cellCenter - width / 2;
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x + width > maxX)
          maxX = x + width;
        if (y + height > maxY)
          maxY = y + height;
        cells.push({ text: line, encoded, width, height, x, y });
        cellOffset += 1;
        charOffset += charLength;
      }
      return {
        fontSize,
        cells,
        bounds: {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        }
      };
    };
    exports.layoutSinglelineText = function(text, _a) {
      var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;
      var line = utils_1.mergeLines(utils_1.cleanText(text));
      if (fontSize === void 0 || fontSize === 0) {
        fontSize = computeFontSize([line], font, bounds);
      }
      var encoded = font.encodeText(line);
      var width = font.widthOfTextAtSize(line, fontSize);
      var height = font.heightAtSize(fontSize, { descender: false });
      var x = alignment === alignment_1.TextAlignment.Left ? bounds.x : alignment === alignment_1.TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === alignment_1.TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;
      var y = bounds.y + (bounds.height / 2 - height / 2);
      return {
        fontSize,
        line: { text: line, encoded, width, height, x, y },
        bounds: { x, y, width, height }
      };
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/api/form/appearances.js
var require_appearances = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/form/appearances.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultOptionListAppearanceProvider = exports.defaultDropdownAppearanceProvider = exports.defaultTextFieldAppearanceProvider = exports.defaultButtonAppearanceProvider = exports.defaultRadioGroupAppearanceProvider = exports.defaultCheckBoxAppearanceProvider = exports.normalizeAppearance = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var operations_1 = require_operations();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var layout_1 = require_layout();
    var alignment_1 = require_alignment();
    var operators_1 = require_operators();
    var utils_1 = require_utils2();
    exports.normalizeAppearance = function(appearance) {
      if ("normal" in appearance)
        return appearance;
      return { normal: appearance };
    };
    var tfRegex = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]+(\d*\.\d+|\d+)[\0\t\n\f\r\ ]+Tf/;
    var getDefaultFontSize = function(field) {
      var _a, _b;
      var da = (_a = field.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
      var daMatch = (_b = utils_1.findLastMatch(da, tfRegex).match) !== null && _b !== void 0 ? _b : [];
      var defaultFontSize = Number(daMatch[2]);
      return isFinite(defaultFontSize) ? defaultFontSize : void 0;
    };
    var colorRegex = /(\d*\.\d+|\d+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+(g|rg|k)/;
    var getDefaultColor = function(field) {
      var _a;
      var da = (_a = field.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
      var daMatch = utils_1.findLastMatch(da, colorRegex).match;
      var _b = daMatch !== null && daMatch !== void 0 ? daMatch : [], c1 = _b[1], c2 = _b[2], c3 = _b[3], c4 = _b[4], colorSpace = _b[5];
      if (colorSpace === "g" && c1) {
        return colors_1.grayscale(Number(c1));
      }
      if (colorSpace === "rg" && c1 && c2 && c3) {
        return colors_1.rgb(Number(c1), Number(c2), Number(c3));
      }
      if (colorSpace === "k" && c1 && c2 && c3 && c4) {
        return colors_1.cmyk(Number(c1), Number(c2), Number(c3), Number(c4));
      }
      return void 0;
    };
    var updateDefaultAppearance = function(field, color, font, fontSize) {
      var _a;
      if (fontSize === void 0) {
        fontSize = 0;
      }
      var da = [
        colors_1.setFillingColor(color).toString(),
        operators_1.setFontAndSize((_a = font === null || font === void 0 ? void 0 : font.name) !== null && _a !== void 0 ? _a : "dummy__noop", fontSize).toString()
      ].join("\n");
      field.setDefaultAppearance(da);
    };
    exports.defaultCheckBoxAppearanceProvider = function(checkBox, widget) {
      var _a, _b, _c;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(checkBox.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _d = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = (_b = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor())) !== null && _b !== void 0 ? _b : black;
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var downBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
      var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
      if (widgetColor) {
        updateDefaultAppearance(widget, textColor);
      } else {
        updateDefaultAppearance(checkBox.acroField, textColor);
      }
      var options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        thickness: 1.5,
        borderWidth,
        borderColor,
        markColor: textColor
      };
      return {
        normal: {
          on: tslib_1.__spreadArrays(rotate, operations_1.drawCheckBox(tslib_1.__assign(tslib_1.__assign({}, options), { color: normalBackgroundColor, filled: true }))),
          off: tslib_1.__spreadArrays(rotate, operations_1.drawCheckBox(tslib_1.__assign(tslib_1.__assign({}, options), { color: normalBackgroundColor, filled: false })))
        },
        down: {
          on: tslib_1.__spreadArrays(rotate, operations_1.drawCheckBox(tslib_1.__assign(tslib_1.__assign({}, options), { color: downBackgroundColor, filled: true }))),
          off: tslib_1.__spreadArrays(rotate, operations_1.drawCheckBox(tslib_1.__assign(tslib_1.__assign({}, options), { color: downBackgroundColor, filled: false })))
        }
      };
    };
    exports.defaultRadioGroupAppearanceProvider = function(radioGroup, widget) {
      var _a, _b, _c;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(radioGroup.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _d = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = (_b = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor())) !== null && _b !== void 0 ? _b : black;
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var downBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
      var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
      if (widgetColor) {
        updateDefaultAppearance(widget, textColor);
      } else {
        updateDefaultAppearance(radioGroup.acroField, textColor);
      }
      var options = {
        x: width / 2,
        y: height / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth,
        borderColor,
        dotColor: textColor
      };
      return {
        normal: {
          on: tslib_1.__spreadArrays(rotate, operations_1.drawRadioButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: normalBackgroundColor, filled: true }))),
          off: tslib_1.__spreadArrays(rotate, operations_1.drawRadioButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: normalBackgroundColor, filled: false })))
        },
        down: {
          on: tslib_1.__spreadArrays(rotate, operations_1.drawRadioButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: downBackgroundColor, filled: true }))),
          off: tslib_1.__spreadArrays(rotate, operations_1.drawRadioButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: downBackgroundColor, filled: false })))
        }
      };
    };
    exports.defaultButtonAppearanceProvider = function(button, widget, font) {
      var _a, _b, _c, _d, _e;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(button.acroField);
      var widgetFontSize = getDefaultFontSize(widget);
      var fieldFontSize = getDefaultFontSize(button.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var captions = ap === null || ap === void 0 ? void 0 : ap.getCaptions();
      var normalText = (_a = captions === null || captions === void 0 ? void 0 : captions.normal) !== null && _a !== void 0 ? _a : "";
      var downText = (_c = (_b = captions === null || captions === void 0 ? void 0 : captions.down) !== null && _b !== void 0 ? _b : normalText) !== null && _c !== void 0 ? _c : "";
      var borderWidth = (_d = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _d !== void 0 ? _d : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _f = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _f.width, height = _f.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var downBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
      var bounds = {
        x: borderWidth,
        y: borderWidth,
        width: width - borderWidth * 2,
        height: height - borderWidth * 2
      };
      var normalLayout = layout_1.layoutSinglelineText(normalText, {
        alignment: alignment_1.TextAlignment.Center,
        fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
        font,
        bounds
      });
      var downLayout = layout_1.layoutSinglelineText(downText, {
        alignment: alignment_1.TextAlignment.Center,
        fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
        font,
        bounds
      });
      var fontSize = Math.min(normalLayout.fontSize, downLayout.fontSize);
      var textColor = (_e = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _e !== void 0 ? _e : black;
      if (widgetColor || widgetFontSize !== void 0) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
      } else {
        updateDefaultAppearance(button.acroField, textColor, font, fontSize);
      }
      var options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth,
        borderColor,
        textColor,
        font: font.name,
        fontSize
      };
      return {
        normal: tslib_1.__spreadArrays(rotate, operations_1.drawButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: normalBackgroundColor, textLines: [normalLayout.line] }))),
        down: tslib_1.__spreadArrays(rotate, operations_1.drawButton(tslib_1.__assign(tslib_1.__assign({}, options), { color: downBackgroundColor, textLines: [downLayout.line] })))
      };
    };
    exports.defaultTextFieldAppearanceProvider = function(textField, widget, font) {
      var _a, _b, _c, _d;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(textField.acroField);
      var widgetFontSize = getDefaultFontSize(widget);
      var fieldFontSize = getDefaultFontSize(textField.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var text = (_a = textField.getText()) !== null && _a !== void 0 ? _a : "";
      var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _e = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _e.width, height = _e.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var textLines;
      var fontSize;
      var padding = textField.isCombed() ? 0 : 1;
      var bounds = {
        x: borderWidth + padding,
        y: borderWidth + padding,
        width: width - (borderWidth + padding) * 2,
        height: height - (borderWidth + padding) * 2
      };
      if (textField.isMultiline()) {
        var layout = layout_1.layoutMultilineText(text, {
          alignment: textField.getAlignment(),
          fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
          font,
          bounds
        });
        textLines = layout.lines;
        fontSize = layout.fontSize;
      } else if (textField.isCombed()) {
        var layout = layout_1.layoutCombedText(text, {
          fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
          font,
          bounds,
          cellCount: (_c = textField.getMaxLength()) !== null && _c !== void 0 ? _c : 0
        });
        textLines = layout.cells;
        fontSize = layout.fontSize;
      } else {
        var layout = layout_1.layoutSinglelineText(text, {
          alignment: textField.getAlignment(),
          fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
          font,
          bounds
        });
        textLines = [layout.line];
        fontSize = layout.fontSize;
      }
      var textColor = (_d = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _d !== void 0 ? _d : black;
      if (widgetColor || widgetFontSize !== void 0) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
      } else {
        updateDefaultAppearance(textField.acroField, textColor, font, fontSize);
      }
      var options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
        borderColor,
        textColor,
        font: font.name,
        fontSize,
        color: normalBackgroundColor,
        textLines,
        padding
      };
      return tslib_1.__spreadArrays(rotate, operations_1.drawTextField(options));
    };
    exports.defaultDropdownAppearanceProvider = function(dropdown, widget, font) {
      var _a, _b, _c;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(dropdown.acroField);
      var widgetFontSize = getDefaultFontSize(widget);
      var fieldFontSize = getDefaultFontSize(dropdown.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var text = (_a = dropdown.getSelected()[0]) !== null && _a !== void 0 ? _a : "";
      var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _d = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var padding = 1;
      var bounds = {
        x: borderWidth + padding,
        y: borderWidth + padding,
        width: width - (borderWidth + padding) * 2,
        height: height - (borderWidth + padding) * 2
      };
      var _e = layout_1.layoutSinglelineText(text, {
        alignment: alignment_1.TextAlignment.Left,
        fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
        font,
        bounds
      }), line = _e.line, fontSize = _e.fontSize;
      var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
      if (widgetColor || widgetFontSize !== void 0) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
      } else {
        updateDefaultAppearance(dropdown.acroField, textColor, font, fontSize);
      }
      var options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
        borderColor,
        textColor,
        font: font.name,
        fontSize,
        color: normalBackgroundColor,
        textLines: [line],
        padding
      };
      return tslib_1.__spreadArrays(rotate, operations_1.drawTextField(options));
    };
    exports.defaultOptionListAppearanceProvider = function(optionList, widget, font) {
      var _a, _b;
      var widgetColor = getDefaultColor(widget);
      var fieldColor = getDefaultColor(optionList.acroField);
      var widgetFontSize = getDefaultFontSize(widget);
      var fieldFontSize = getDefaultFontSize(optionList.acroField);
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var borderWidth = (_a = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a !== void 0 ? _a : 0;
      var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var _c = rotations_1.adjustDimsForRotation(rectangle, rotation), width = _c.width, height = _c.height;
      var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
      var black = colors_1.rgb(0, 0, 0);
      var borderColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
      var normalBackgroundColor = colors_1.componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
      var options = optionList.getOptions();
      var selected = optionList.getSelected();
      if (optionList.isSorted())
        options.sort();
      var text = "";
      for (var idx = 0, len = options.length; idx < len; idx++) {
        text += options[idx];
        if (idx < len - 1)
          text += "\n";
      }
      var padding = 1;
      var bounds = {
        x: borderWidth + padding,
        y: borderWidth + padding,
        width: width - (borderWidth + padding) * 2,
        height: height - (borderWidth + padding) * 2
      };
      var _d = layout_1.layoutMultilineText(text, {
        alignment: alignment_1.TextAlignment.Left,
        fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
        font,
        bounds
      }), lines = _d.lines, fontSize = _d.fontSize, lineHeight = _d.lineHeight;
      var selectedLines = [];
      for (var idx = 0, len = lines.length; idx < len; idx++) {
        var line = lines[idx];
        if (selected.includes(line.text))
          selectedLines.push(idx);
      }
      var blue = colors_1.rgb(153 / 255, 193 / 255, 218 / 255);
      var textColor = (_b = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _b !== void 0 ? _b : black;
      if (widgetColor || widgetFontSize !== void 0) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
      } else {
        updateDefaultAppearance(optionList.acroField, textColor, font, fontSize);
      }
      return tslib_1.__spreadArrays(rotate, operations_1.drawOptionList({
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
        borderColor,
        textColor,
        font: font.name,
        fontSize,
        color: normalBackgroundColor,
        textLines: lines,
        lineHeight,
        selectedColor: blue,
        selectedLines,
        padding
      }));
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/api/PDFEmbeddedPage.js
var require_PDFEmbeddedPage = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/PDFEmbeddedPage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFEmbeddedPage = (
      /** @class */
      function() {
        function PDFEmbeddedPage2(ref, doc, embedder) {
          this.alreadyEmbedded = false;
          utils_1.assertIs(ref, "ref", [[core_1.PDFRef, "PDFRef"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          utils_1.assertIs(embedder, "embedder", [[core_1.PDFPageEmbedder, "PDFPageEmbedder"]]);
          this.ref = ref;
          this.doc = doc;
          this.width = embedder.width;
          this.height = embedder.height;
          this.embedder = embedder;
        }
        PDFEmbeddedPage2.prototype.scale = function(factor) {
          utils_1.assertIs(factor, "factor", ["number"]);
          return { width: this.width * factor, height: this.height * factor };
        };
        PDFEmbeddedPage2.prototype.size = function() {
          return this.scale(1);
        };
        PDFEmbeddedPage2.prototype.embed = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!!this.alreadyEmbedded)
                    return [3, 2];
                  return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
                case 1:
                  _a.sent();
                  this.alreadyEmbedded = true;
                  _a.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFEmbeddedPage2.of = function(ref, doc, embedder) {
          return new PDFEmbeddedPage2(ref, doc, embedder);
        };
        return PDFEmbeddedPage2;
      }()
    );
    exports.default = PDFEmbeddedPage;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/PDFFont.js
var require_PDFFont = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/PDFFont.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFFont = (
      /** @class */
      function() {
        function PDFFont2(ref, doc, embedder) {
          this.modified = true;
          utils_1.assertIs(ref, "ref", [[core_1.PDFRef, "PDFRef"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          utils_1.assertIs(embedder, "embedder", [
            [core_1.CustomFontEmbedder, "CustomFontEmbedder"],
            [core_1.StandardFontEmbedder, "StandardFontEmbedder"]
          ]);
          this.ref = ref;
          this.doc = doc;
          this.name = embedder.fontName;
          this.embedder = embedder;
        }
        PDFFont2.prototype.encodeText = function(text) {
          utils_1.assertIs(text, "text", ["string"]);
          this.modified = true;
          return this.embedder.encodeText(text);
        };
        PDFFont2.prototype.widthOfTextAtSize = function(text, size) {
          utils_1.assertIs(text, "text", ["string"]);
          utils_1.assertIs(size, "size", ["number"]);
          return this.embedder.widthOfTextAtSize(text, size);
        };
        PDFFont2.prototype.heightAtSize = function(size, options) {
          var _a;
          utils_1.assertIs(size, "size", ["number"]);
          utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.descender, "options.descender", ["boolean"]);
          return this.embedder.heightOfFontAtSize(size, {
            descender: (_a = options === null || options === void 0 ? void 0 : options.descender) !== null && _a !== void 0 ? _a : true
          });
        };
        PDFFont2.prototype.sizeAtHeight = function(height) {
          utils_1.assertIs(height, "height", ["number"]);
          return this.embedder.sizeOfFontAtHeight(height);
        };
        PDFFont2.prototype.getCharacterSet = function() {
          if (this.embedder instanceof core_1.StandardFontEmbedder) {
            return this.embedder.encoding.supportedCodePoints;
          } else {
            return this.embedder.font.characterSet;
          }
        };
        PDFFont2.prototype.embed = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!this.modified)
                    return [3, 2];
                  return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
                case 1:
                  _a.sent();
                  this.modified = false;
                  _a.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFFont2.of = function(ref, doc, embedder) {
          return new PDFFont2(ref, doc, embedder);
        };
        return PDFFont2;
      }()
    );
    exports.default = PDFFont;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/PDFImage.js
var require_PDFImage = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/PDFImage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFImage = (
      /** @class */
      function() {
        function PDFImage2(ref, doc, embedder) {
          utils_1.assertIs(ref, "ref", [[core_1.PDFRef, "PDFRef"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          utils_1.assertIs(embedder, "embedder", [
            [core_1.JpegEmbedder, "JpegEmbedder"],
            [core_1.PngEmbedder, "PngEmbedder"]
          ]);
          this.ref = ref;
          this.doc = doc;
          this.width = embedder.width;
          this.height = embedder.height;
          this.embedder = embedder;
        }
        PDFImage2.prototype.scale = function(factor) {
          utils_1.assertIs(factor, "factor", ["number"]);
          return { width: this.width * factor, height: this.height * factor };
        };
        PDFImage2.prototype.scaleToFit = function(width, height) {
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var imgWidthScale = width / this.width;
          var imgHeightScale = height / this.height;
          var scale2 = Math.min(imgWidthScale, imgHeightScale);
          return this.scale(scale2);
        };
        PDFImage2.prototype.size = function() {
          return this.scale(1);
        };
        PDFImage2.prototype.embed = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, doc, ref;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!this.embedder)
                    return [
                      2
                      /*return*/
                    ];
                  if (!this.embedTask) {
                    _a = this, doc = _a.doc, ref = _a.ref;
                    this.embedTask = this.embedder.embedIntoContext(doc.context, ref);
                  }
                  return [4, this.embedTask];
                case 1:
                  _b.sent();
                  this.embedder = void 0;
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFImage2.of = function(ref, doc, embedder) {
          return new PDFImage2(ref, doc, embedder);
        };
        return PDFImage2;
      }()
    );
    exports.default = PDFImage;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/image/alignment.js
var require_alignment2 = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/image/alignment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageAlignment = void 0;
    var ImageAlignment;
    (function(ImageAlignment2) {
      ImageAlignment2[ImageAlignment2["Left"] = 0] = "Left";
      ImageAlignment2[ImageAlignment2["Center"] = 1] = "Center";
      ImageAlignment2[ImageAlignment2["Right"] = 2] = "Right";
    })(ImageAlignment = exports.ImageAlignment || (exports.ImageAlignment = {}));
  }
});

// ../../../node_modules/pdf-lib/cjs/api/image/index.js
var require_image = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/image/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_alignment2(), exports);
  }
});

// ../../../node_modules/pdf-lib/cjs/api/form/PDFField.js
var require_PDFField = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/form/PDFField.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertFieldAppearanceOptions = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var image_1 = require_image();
    var operations_1 = require_operations();
    exports.assertFieldAppearanceOptions = function(options) {
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.x, "options.x", ["number"]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.y, "options.y", ["number"]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.width, "options.width", ["number"]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.height, "options.height", ["number"]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.textColor, "options.textColor", [
        [Object, "Color"]
      ]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.backgroundColor, "options.backgroundColor", [
        [Object, "Color"]
      ]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderColor, "options.borderColor", [
        [Object, "Color"]
      ]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderWidth, "options.borderWidth", ["number"]);
      utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.rotate, "options.rotate", [[Object, "Rotation"]]);
    };
    var PDFField = (
      /** @class */
      function() {
        function PDFField2(acroField, ref, doc) {
          utils_1.assertIs(acroField, "acroField", [[core_1.PDFAcroTerminal, "PDFAcroTerminal"]]);
          utils_1.assertIs(ref, "ref", [[core_1.PDFRef, "PDFRef"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          this.acroField = acroField;
          this.ref = ref;
          this.doc = doc;
        }
        PDFField2.prototype.getName = function() {
          var _a;
          return (_a = this.acroField.getFullyQualifiedName()) !== null && _a !== void 0 ? _a : "";
        };
        PDFField2.prototype.isReadOnly = function() {
          return this.acroField.hasFlag(core_1.AcroFieldFlags.ReadOnly);
        };
        PDFField2.prototype.enableReadOnly = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.ReadOnly, true);
        };
        PDFField2.prototype.disableReadOnly = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.ReadOnly, false);
        };
        PDFField2.prototype.isRequired = function() {
          return this.acroField.hasFlag(core_1.AcroFieldFlags.Required);
        };
        PDFField2.prototype.enableRequired = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.Required, true);
        };
        PDFField2.prototype.disableRequired = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.Required, false);
        };
        PDFField2.prototype.isExported = function() {
          return !this.acroField.hasFlag(core_1.AcroFieldFlags.NoExport);
        };
        PDFField2.prototype.enableExporting = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.NoExport, false);
        };
        PDFField2.prototype.disableExporting = function() {
          this.acroField.setFlagTo(core_1.AcroFieldFlags.NoExport, true);
        };
        PDFField2.prototype.needsAppearancesUpdate = function() {
          throw new core_1.MethodNotImplementedError(this.constructor.name, "needsAppearancesUpdate");
        };
        PDFField2.prototype.defaultUpdateAppearances = function(_font) {
          throw new core_1.MethodNotImplementedError(this.constructor.name, "defaultUpdateAppearances");
        };
        PDFField2.prototype.markAsDirty = function() {
          this.doc.getForm().markFieldAsDirty(this.ref);
        };
        PDFField2.prototype.markAsClean = function() {
          this.doc.getForm().markFieldAsClean(this.ref);
        };
        PDFField2.prototype.isDirty = function() {
          return this.doc.getForm().fieldIsDirty(this.ref);
        };
        PDFField2.prototype.createWidget = function(options) {
          var _a;
          var textColor = options.textColor;
          var backgroundColor = options.backgroundColor;
          var borderColor = options.borderColor;
          var borderWidth = options.borderWidth;
          var degreesAngle = rotations_1.toDegrees(options.rotate);
          var caption = options.caption;
          var x = options.x;
          var y = options.y;
          var width = options.width + borderWidth;
          var height = options.height + borderWidth;
          var hidden = Boolean(options.hidden);
          var pageRef = options.page;
          utils_1.assertMultiple(degreesAngle, "degreesAngle", 90);
          var widget = core_1.PDFWidgetAnnotation.create(this.doc.context, this.ref);
          var rect = rotations_1.rotateRectangle({ x, y, width, height }, borderWidth, degreesAngle);
          widget.setRectangle(rect);
          if (pageRef)
            widget.setP(pageRef);
          var ac = widget.getOrCreateAppearanceCharacteristics();
          if (backgroundColor) {
            ac.setBackgroundColor(colors_1.colorToComponents(backgroundColor));
          }
          ac.setRotation(degreesAngle);
          if (caption)
            ac.setCaptions({ normal: caption });
          if (borderColor)
            ac.setBorderColor(colors_1.colorToComponents(borderColor));
          var bs = widget.getOrCreateBorderStyle();
          if (borderWidth !== void 0)
            bs.setWidth(borderWidth);
          widget.setFlagTo(core_1.AnnotationFlags.Print, true);
          widget.setFlagTo(core_1.AnnotationFlags.Hidden, hidden);
          widget.setFlagTo(core_1.AnnotationFlags.Invisible, false);
          if (textColor) {
            var da = (_a = this.acroField.getDefaultAppearance()) !== null && _a !== void 0 ? _a : "";
            var newDa = da + "\n" + colors_1.setFillingColor(textColor).toString();
            this.acroField.setDefaultAppearance(newDa);
          }
          return widget;
        };
        PDFField2.prototype.updateWidgetAppearanceWithFont = function(widget, font, _a) {
          var normal = _a.normal, rollover = _a.rollover, down = _a.down;
          this.updateWidgetAppearances(widget, {
            normal: this.createAppearanceStream(widget, normal, font),
            rollover: rollover && this.createAppearanceStream(widget, rollover, font),
            down: down && this.createAppearanceStream(widget, down, font)
          });
        };
        PDFField2.prototype.updateOnOffWidgetAppearance = function(widget, onValue, _a) {
          var normal = _a.normal, rollover = _a.rollover, down = _a.down;
          this.updateWidgetAppearances(widget, {
            normal: this.createAppearanceDict(widget, normal, onValue),
            rollover: rollover && this.createAppearanceDict(widget, rollover, onValue),
            down: down && this.createAppearanceDict(widget, down, onValue)
          });
        };
        PDFField2.prototype.updateWidgetAppearances = function(widget, _a) {
          var normal = _a.normal, rollover = _a.rollover, down = _a.down;
          widget.setNormalAppearance(normal);
          if (rollover) {
            widget.setRolloverAppearance(rollover);
          } else {
            widget.removeRolloverAppearance();
          }
          if (down) {
            widget.setDownAppearance(down);
          } else {
            widget.removeDownAppearance();
          }
        };
        PDFField2.prototype.createAppearanceStream = function(widget, appearance, font) {
          var _a;
          var context = this.acroField.dict.context;
          var _b = widget.getRectangle(), width = _b.width, height = _b.height;
          var Resources = font && { Font: (_a = {}, _a[font.name] = font.ref, _a) };
          var stream = context.formXObject(appearance, {
            Resources,
            BBox: context.obj([0, 0, width, height]),
            Matrix: context.obj([1, 0, 0, 1, 0, 0])
          });
          var streamRef = context.register(stream);
          return streamRef;
        };
        PDFField2.prototype.createImageAppearanceStream = function(widget, image, alignment) {
          var _a;
          var _b;
          var context = this.acroField.dict.context;
          var rectangle = widget.getRectangle();
          var ap = widget.getAppearanceCharacteristics();
          var bs = widget.getBorderStyle();
          var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;
          var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
          var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation }));
          var adj = rotations_1.adjustDimsForRotation(rectangle, rotation);
          var imageDims = image.scaleToFit(adj.width - borderWidth * 2, adj.height - borderWidth * 2);
          var options = {
            x: borderWidth,
            y: borderWidth,
            width: imageDims.width,
            height: imageDims.height,
            //
            rotate: rotations_1.degrees(0),
            xSkew: rotations_1.degrees(0),
            ySkew: rotations_1.degrees(0)
          };
          if (alignment === image_1.ImageAlignment.Center) {
            options.x += (adj.width - borderWidth * 2) / 2 - imageDims.width / 2;
            options.y += (adj.height - borderWidth * 2) / 2 - imageDims.height / 2;
          } else if (alignment === image_1.ImageAlignment.Right) {
            options.x = adj.width - borderWidth - imageDims.width;
            options.y = adj.height - borderWidth - imageDims.height;
          }
          var imageName = this.doc.context.addRandomSuffix("Image", 10);
          var appearance = tslib_1.__spreadArrays(rotate, operations_1.drawImage(imageName, options));
          var Resources = { XObject: (_a = {}, _a[imageName] = image.ref, _a) };
          var stream = context.formXObject(appearance, {
            Resources,
            BBox: context.obj([0, 0, rectangle.width, rectangle.height]),
            Matrix: context.obj([1, 0, 0, 1, 0, 0])
          });
          return context.register(stream);
        };
        PDFField2.prototype.createAppearanceDict = function(widget, appearance, onValue) {
          var context = this.acroField.dict.context;
          var onStreamRef = this.createAppearanceStream(widget, appearance.on);
          var offStreamRef = this.createAppearanceStream(widget, appearance.off);
          var appearanceDict = context.obj({});
          appearanceDict.set(onValue, onStreamRef);
          appearanceDict.set(core_1.PDFName.of("Off"), offStreamRef);
          return appearanceDict;
        };
        return PDFField2;
      }()
    );
    exports.default = PDFField;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/form/PDFCheckBox.js
var require_PDFCheckBox = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/form/PDFCheckBox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var appearances_1 = require_appearances();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFCheckBox = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFCheckBox2, _super);
        function PDFCheckBox2(acroCheckBox, ref, doc) {
          var _this = _super.call(this, acroCheckBox, ref, doc) || this;
          utils_1.assertIs(acroCheckBox, "acroCheckBox", [
            [core_1.PDFAcroCheckBox, "PDFAcroCheckBox"]
          ]);
          _this.acroField = acroCheckBox;
          return _this;
        }
        PDFCheckBox2.prototype.check = function() {
          var _a;
          var onValue = (_a = this.acroField.getOnValue()) !== null && _a !== void 0 ? _a : core_1.PDFName.of("Yes");
          this.markAsDirty();
          this.acroField.setValue(onValue);
        };
        PDFCheckBox2.prototype.uncheck = function() {
          this.markAsDirty();
          this.acroField.setValue(core_1.PDFName.of("Off"));
        };
        PDFCheckBox2.prototype.isChecked = function() {
          var onValue = this.acroField.getOnValue();
          return !!onValue && onValue === this.acroField.getValue();
        };
        PDFCheckBox2.prototype.addToPage = function(page, options) {
          var _a, _b, _c, _d, _e, _f;
          utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          if (!options)
            options = {};
          if (!("textColor" in options))
            options.textColor = colors_1.rgb(0, 0, 0);
          if (!("backgroundColor" in options))
            options.backgroundColor = colors_1.rgb(1, 1, 1);
          if (!("borderColor" in options))
            options.borderColor = colors_1.rgb(0, 0, 0);
          if (!("borderWidth" in options))
            options.borderWidth = 1;
          var widget = this.createWidget({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : 50,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
            textColor: options.textColor,
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
            rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            hidden: options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          this.acroField.addWidget(widgetRef);
          widget.setAppearanceState(core_1.PDFName.of("Off"));
          this.updateWidgetAppearance(widget, core_1.PDFName.of("Yes"));
          page.node.addAnnot(widgetRef);
        };
        PDFCheckBox2.prototype.needsAppearancesUpdate = function() {
          var _a;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var state = widget.getAppearanceState();
            var normal = (_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
            if (!(normal instanceof core_1.PDFDict))
              return true;
            if (state && !normal.has(state))
              return true;
          }
          return false;
        };
        PDFCheckBox2.prototype.defaultUpdateAppearances = function() {
          this.updateAppearances();
        };
        PDFCheckBox2.prototype.updateAppearances = function(provider) {
          var _a;
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var onValue = (_a = widget.getOnValue()) !== null && _a !== void 0 ? _a : core_1.PDFName.of("Yes");
            if (!onValue)
              continue;
            this.updateWidgetAppearance(widget, onValue, provider);
          }
          this.markAsClean();
        };
        PDFCheckBox2.prototype.updateWidgetAppearance = function(widget, onValue, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultCheckBoxAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget));
          this.updateOnOffWidgetAppearance(widget, onValue, appearances);
        };
        PDFCheckBox2.of = function(acroCheckBox, ref, doc) {
          return new PDFCheckBox2(acroCheckBox, ref, doc);
        };
        return PDFCheckBox2;
      }(PDFField_1.default)
    );
    exports.default = PDFCheckBox;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/form/PDFDropdown.js
var require_PDFDropdown = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/form/PDFDropdown.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var appearances_1 = require_appearances();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFDropdown = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFDropdown2, _super);
        function PDFDropdown2(acroComboBox, ref, doc) {
          var _this = _super.call(this, acroComboBox, ref, doc) || this;
          utils_1.assertIs(acroComboBox, "acroComboBox", [
            [core_1.PDFAcroComboBox, "PDFAcroComboBox"]
          ]);
          _this.acroField = acroComboBox;
          return _this;
        }
        PDFDropdown2.prototype.getOptions = function() {
          var rawOptions = this.acroField.getOptions();
          var options = new Array(rawOptions.length);
          for (var idx = 0, len = options.length; idx < len; idx++) {
            var _a = rawOptions[idx], display = _a.display, value = _a.value;
            options[idx] = (display !== null && display !== void 0 ? display : value).decodeText();
          }
          return options;
        };
        PDFDropdown2.prototype.getSelected = function() {
          var values = this.acroField.getValues();
          var selected = new Array(values.length);
          for (var idx = 0, len = values.length; idx < len; idx++) {
            selected[idx] = values[idx].decodeText();
          }
          return selected;
        };
        PDFDropdown2.prototype.setOptions = function(options) {
          utils_1.assertIs(options, "options", [Array]);
          var optionObjects = new Array(options.length);
          for (var idx = 0, len = options.length; idx < len; idx++) {
            optionObjects[idx] = { value: core_1.PDFHexString.fromText(options[idx]) };
          }
          this.acroField.setOptions(optionObjects);
        };
        PDFDropdown2.prototype.addOptions = function(options) {
          utils_1.assertIs(options, "options", ["string", Array]);
          var optionsArr = Array.isArray(options) ? options : [options];
          var existingOptions = this.acroField.getOptions();
          var newOptions = new Array(optionsArr.length);
          for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
            newOptions[idx] = { value: core_1.PDFHexString.fromText(optionsArr[idx]) };
          }
          this.acroField.setOptions(existingOptions.concat(newOptions));
        };
        PDFDropdown2.prototype.select = function(options, merge2) {
          if (merge2 === void 0) {
            merge2 = false;
          }
          utils_1.assertIs(options, "options", ["string", Array]);
          utils_1.assertIs(merge2, "merge", ["boolean"]);
          var optionsArr = Array.isArray(options) ? options : [options];
          var validOptions = this.getOptions();
          var hasCustomOption = optionsArr.find(function(option) {
            return !validOptions.includes(option);
          });
          if (hasCustomOption)
            this.enableEditing();
          this.markAsDirty();
          if (optionsArr.length > 1 || optionsArr.length === 1 && merge2) {
            this.enableMultiselect();
          }
          var values = new Array(optionsArr.length);
          for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
            values[idx] = core_1.PDFHexString.fromText(optionsArr[idx]);
          }
          if (merge2) {
            var existingValues = this.acroField.getValues();
            this.acroField.setValues(existingValues.concat(values));
          } else {
            this.acroField.setValues(values);
          }
        };
        PDFDropdown2.prototype.clear = function() {
          this.markAsDirty();
          this.acroField.setValues([]);
        };
        PDFDropdown2.prototype.setFontSize = function(fontSize) {
          utils_1.assertPositive(fontSize, "fontSize");
          this.acroField.setFontSize(fontSize);
          this.markAsDirty();
        };
        PDFDropdown2.prototype.isEditable = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.Edit);
        };
        PDFDropdown2.prototype.enableEditing = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Edit, true);
        };
        PDFDropdown2.prototype.disableEditing = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Edit, false);
        };
        PDFDropdown2.prototype.isSorted = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.Sort);
        };
        PDFDropdown2.prototype.enableSorting = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Sort, true);
        };
        PDFDropdown2.prototype.disableSorting = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Sort, false);
        };
        PDFDropdown2.prototype.isMultiselect = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.MultiSelect);
        };
        PDFDropdown2.prototype.enableMultiselect = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.MultiSelect, true);
        };
        PDFDropdown2.prototype.disableMultiselect = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.MultiSelect, false);
        };
        PDFDropdown2.prototype.isSpellChecked = function() {
          return !this.acroField.hasFlag(core_1.AcroChoiceFlags.DoNotSpellCheck);
        };
        PDFDropdown2.prototype.enableSpellChecking = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.DoNotSpellCheck, false);
        };
        PDFDropdown2.prototype.disableSpellChecking = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.DoNotSpellCheck, true);
        };
        PDFDropdown2.prototype.isSelectOnClick = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.CommitOnSelChange);
        };
        PDFDropdown2.prototype.enableSelectOnClick = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.CommitOnSelChange, true);
        };
        PDFDropdown2.prototype.disableSelectOnClick = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.CommitOnSelChange, false);
        };
        PDFDropdown2.prototype.addToPage = function(page, options) {
          var _a, _b, _c, _d, _e, _f, _g;
          utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          if (!options)
            options = {};
          if (!("textColor" in options))
            options.textColor = colors_1.rgb(0, 0, 0);
          if (!("backgroundColor" in options))
            options.backgroundColor = colors_1.rgb(1, 1, 1);
          if (!("borderColor" in options))
            options.borderColor = colors_1.rgb(0, 0, 0);
          if (!("borderWidth" in options))
            options.borderWidth = 1;
          var widget = this.createWidget({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
            textColor: options.textColor,
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
            rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            hidden: options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          this.acroField.addWidget(widgetRef);
          var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
          this.updateWidgetAppearance(widget, font);
          page.node.addAnnot(widgetRef);
        };
        PDFDropdown2.prototype.needsAppearancesUpdate = function() {
          var _a;
          if (this.isDirty())
            return true;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof core_1.PDFStream;
            if (!hasAppearances)
              return true;
          }
          return false;
        };
        PDFDropdown2.prototype.defaultUpdateAppearances = function(font) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          this.updateAppearances(font);
        };
        PDFDropdown2.prototype.updateAppearances = function(font, provider) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            this.updateWidgetAppearance(widget, font, provider);
          }
          this.markAsClean();
        };
        PDFDropdown2.prototype.updateWidgetAppearance = function(widget, font, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultDropdownAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget, font));
          this.updateWidgetAppearanceWithFont(widget, font, appearances);
        };
        PDFDropdown2.of = function(acroComboBox, ref, doc) {
          return new PDFDropdown2(acroComboBox, ref, doc);
        };
        return PDFDropdown2;
      }(PDFField_1.default)
    );
    exports.default = PDFDropdown;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/form/PDFOptionList.js
var require_PDFOptionList = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/form/PDFOptionList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var appearances_1 = require_appearances();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFOptionList = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFOptionList2, _super);
        function PDFOptionList2(acroListBox, ref, doc) {
          var _this = _super.call(this, acroListBox, ref, doc) || this;
          utils_1.assertIs(acroListBox, "acroListBox", [[core_1.PDFAcroListBox, "PDFAcroListBox"]]);
          _this.acroField = acroListBox;
          return _this;
        }
        PDFOptionList2.prototype.getOptions = function() {
          var rawOptions = this.acroField.getOptions();
          var options = new Array(rawOptions.length);
          for (var idx = 0, len = options.length; idx < len; idx++) {
            var _a = rawOptions[idx], display = _a.display, value = _a.value;
            options[idx] = (display !== null && display !== void 0 ? display : value).decodeText();
          }
          return options;
        };
        PDFOptionList2.prototype.getSelected = function() {
          var values = this.acroField.getValues();
          var selected = new Array(values.length);
          for (var idx = 0, len = values.length; idx < len; idx++) {
            selected[idx] = values[idx].decodeText();
          }
          return selected;
        };
        PDFOptionList2.prototype.setOptions = function(options) {
          utils_1.assertIs(options, "options", [Array]);
          this.markAsDirty();
          var optionObjects = new Array(options.length);
          for (var idx = 0, len = options.length; idx < len; idx++) {
            optionObjects[idx] = { value: core_1.PDFHexString.fromText(options[idx]) };
          }
          this.acroField.setOptions(optionObjects);
        };
        PDFOptionList2.prototype.addOptions = function(options) {
          utils_1.assertIs(options, "options", ["string", Array]);
          this.markAsDirty();
          var optionsArr = Array.isArray(options) ? options : [options];
          var existingOptions = this.acroField.getOptions();
          var newOptions = new Array(optionsArr.length);
          for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
            newOptions[idx] = { value: core_1.PDFHexString.fromText(optionsArr[idx]) };
          }
          this.acroField.setOptions(existingOptions.concat(newOptions));
        };
        PDFOptionList2.prototype.select = function(options, merge2) {
          if (merge2 === void 0) {
            merge2 = false;
          }
          utils_1.assertIs(options, "options", ["string", Array]);
          utils_1.assertIs(merge2, "merge", ["boolean"]);
          var optionsArr = Array.isArray(options) ? options : [options];
          var validOptions = this.getOptions();
          utils_1.assertIsSubset(optionsArr, "option", validOptions);
          this.markAsDirty();
          if (optionsArr.length > 1 || optionsArr.length === 1 && merge2) {
            this.enableMultiselect();
          }
          var values = new Array(optionsArr.length);
          for (var idx = 0, len = optionsArr.length; idx < len; idx++) {
            values[idx] = core_1.PDFHexString.fromText(optionsArr[idx]);
          }
          if (merge2) {
            var existingValues = this.acroField.getValues();
            this.acroField.setValues(existingValues.concat(values));
          } else {
            this.acroField.setValues(values);
          }
        };
        PDFOptionList2.prototype.clear = function() {
          this.markAsDirty();
          this.acroField.setValues([]);
        };
        PDFOptionList2.prototype.setFontSize = function(fontSize) {
          utils_1.assertPositive(fontSize, "fontSize");
          this.acroField.setFontSize(fontSize);
          this.markAsDirty();
        };
        PDFOptionList2.prototype.isSorted = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.Sort);
        };
        PDFOptionList2.prototype.enableSorting = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Sort, true);
        };
        PDFOptionList2.prototype.disableSorting = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.Sort, false);
        };
        PDFOptionList2.prototype.isMultiselect = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.MultiSelect);
        };
        PDFOptionList2.prototype.enableMultiselect = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.MultiSelect, true);
        };
        PDFOptionList2.prototype.disableMultiselect = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.MultiSelect, false);
        };
        PDFOptionList2.prototype.isSelectOnClick = function() {
          return this.acroField.hasFlag(core_1.AcroChoiceFlags.CommitOnSelChange);
        };
        PDFOptionList2.prototype.enableSelectOnClick = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.CommitOnSelChange, true);
        };
        PDFOptionList2.prototype.disableSelectOnClick = function() {
          this.acroField.setFlagTo(core_1.AcroChoiceFlags.CommitOnSelChange, false);
        };
        PDFOptionList2.prototype.addToPage = function(page, options) {
          var _a, _b, _c, _d, _e, _f, _g;
          utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          if (!options)
            options = {};
          if (!("textColor" in options))
            options.textColor = colors_1.rgb(0, 0, 0);
          if (!("backgroundColor" in options))
            options.backgroundColor = colors_1.rgb(1, 1, 1);
          if (!("borderColor" in options))
            options.borderColor = colors_1.rgb(0, 0, 0);
          if (!("borderWidth" in options))
            options.borderWidth = 1;
          var widget = this.createWidget({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : 100,
            textColor: options.textColor,
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
            rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            hidden: options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          this.acroField.addWidget(widgetRef);
          var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
          this.updateWidgetAppearance(widget, font);
          page.node.addAnnot(widgetRef);
        };
        PDFOptionList2.prototype.needsAppearancesUpdate = function() {
          var _a;
          if (this.isDirty())
            return true;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof core_1.PDFStream;
            if (!hasAppearances)
              return true;
          }
          return false;
        };
        PDFOptionList2.prototype.defaultUpdateAppearances = function(font) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          this.updateAppearances(font);
        };
        PDFOptionList2.prototype.updateAppearances = function(font, provider) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            this.updateWidgetAppearance(widget, font, provider);
          }
          this.markAsClean();
        };
        PDFOptionList2.prototype.updateWidgetAppearance = function(widget, font, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultOptionListAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget, font));
          this.updateWidgetAppearanceWithFont(widget, font, appearances);
        };
        PDFOptionList2.of = function(acroListBox, ref, doc) {
          return new PDFOptionList2(acroListBox, ref, doc);
        };
        return PDFOptionList2;
      }(PDFField_1.default)
    );
    exports.default = PDFOptionList;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/form/PDFRadioGroup.js
var require_PDFRadioGroup = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/form/PDFRadioGroup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var appearances_1 = require_appearances();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFRadioGroup = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFRadioGroup2, _super);
        function PDFRadioGroup2(acroRadioButton, ref, doc) {
          var _this = _super.call(this, acroRadioButton, ref, doc) || this;
          utils_1.assertIs(acroRadioButton, "acroRadioButton", [
            [core_1.PDFAcroRadioButton, "PDFAcroRadioButton"]
          ]);
          _this.acroField = acroRadioButton;
          return _this;
        }
        PDFRadioGroup2.prototype.getOptions = function() {
          var exportValues = this.acroField.getExportValues();
          if (exportValues) {
            var exportOptions = new Array(exportValues.length);
            for (var idx = 0, len = exportValues.length; idx < len; idx++) {
              exportOptions[idx] = exportValues[idx].decodeText();
            }
            return exportOptions;
          }
          var onValues = this.acroField.getOnValues();
          var onOptions = new Array(onValues.length);
          for (var idx = 0, len = onOptions.length; idx < len; idx++) {
            onOptions[idx] = onValues[idx].decodeText();
          }
          return onOptions;
        };
        PDFRadioGroup2.prototype.getSelected = function() {
          var value = this.acroField.getValue();
          if (value === core_1.PDFName.of("Off"))
            return void 0;
          var exportValues = this.acroField.getExportValues();
          if (exportValues) {
            var onValues = this.acroField.getOnValues();
            for (var idx = 0, len = onValues.length; idx < len; idx++) {
              if (onValues[idx] === value)
                return exportValues[idx].decodeText();
            }
          }
          return value.decodeText();
        };
        PDFRadioGroup2.prototype.select = function(option) {
          utils_1.assertIs(option, "option", ["string"]);
          var validOptions = this.getOptions();
          utils_1.assertIsOneOf(option, "option", validOptions);
          this.markAsDirty();
          var onValues = this.acroField.getOnValues();
          var exportValues = this.acroField.getExportValues();
          if (exportValues) {
            for (var idx = 0, len = exportValues.length; idx < len; idx++) {
              if (exportValues[idx].decodeText() === option) {
                this.acroField.setValue(onValues[idx]);
              }
            }
          } else {
            for (var idx = 0, len = onValues.length; idx < len; idx++) {
              var value = onValues[idx];
              if (value.decodeText() === option)
                this.acroField.setValue(value);
            }
          }
        };
        PDFRadioGroup2.prototype.clear = function() {
          this.markAsDirty();
          this.acroField.setValue(core_1.PDFName.of("Off"));
        };
        PDFRadioGroup2.prototype.isOffToggleable = function() {
          return !this.acroField.hasFlag(core_1.AcroButtonFlags.NoToggleToOff);
        };
        PDFRadioGroup2.prototype.enableOffToggling = function() {
          this.acroField.setFlagTo(core_1.AcroButtonFlags.NoToggleToOff, false);
        };
        PDFRadioGroup2.prototype.disableOffToggling = function() {
          this.acroField.setFlagTo(core_1.AcroButtonFlags.NoToggleToOff, true);
        };
        PDFRadioGroup2.prototype.isMutuallyExclusive = function() {
          return !this.acroField.hasFlag(core_1.AcroButtonFlags.RadiosInUnison);
        };
        PDFRadioGroup2.prototype.enableMutualExclusion = function() {
          this.acroField.setFlagTo(core_1.AcroButtonFlags.RadiosInUnison, false);
        };
        PDFRadioGroup2.prototype.disableMutualExclusion = function() {
          this.acroField.setFlagTo(core_1.AcroButtonFlags.RadiosInUnison, true);
        };
        PDFRadioGroup2.prototype.addOptionToPage = function(option, page, options) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j;
          utils_1.assertIs(option, "option", ["string"]);
          utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          var widget = this.createWidget({
            x: (_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0,
            y: (_b = options === null || options === void 0 ? void 0 : options.y) !== null && _b !== void 0 ? _b : 0,
            width: (_c = options === null || options === void 0 ? void 0 : options.width) !== null && _c !== void 0 ? _c : 50,
            height: (_d = options === null || options === void 0 ? void 0 : options.height) !== null && _d !== void 0 ? _d : 50,
            textColor: (_e = options === null || options === void 0 ? void 0 : options.textColor) !== null && _e !== void 0 ? _e : colors_1.rgb(0, 0, 0),
            backgroundColor: (_f = options === null || options === void 0 ? void 0 : options.backgroundColor) !== null && _f !== void 0 ? _f : colors_1.rgb(1, 1, 1),
            borderColor: (_g = options === null || options === void 0 ? void 0 : options.borderColor) !== null && _g !== void 0 ? _g : colors_1.rgb(0, 0, 0),
            borderWidth: (_h = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _h !== void 0 ? _h : 1,
            rotate: (_j = options === null || options === void 0 ? void 0 : options.rotate) !== null && _j !== void 0 ? _j : rotations_1.degrees(0),
            hidden: options === null || options === void 0 ? void 0 : options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          var apStateValue = this.acroField.addWidgetWithOpt(widgetRef, core_1.PDFHexString.fromText(option), !this.isMutuallyExclusive());
          widget.setAppearanceState(core_1.PDFName.of("Off"));
          this.updateWidgetAppearance(widget, apStateValue);
          page.node.addAnnot(widgetRef);
        };
        PDFRadioGroup2.prototype.needsAppearancesUpdate = function() {
          var _a;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var state = widget.getAppearanceState();
            var normal = (_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal;
            if (!(normal instanceof core_1.PDFDict))
              return true;
            if (state && !normal.has(state))
              return true;
          }
          return false;
        };
        PDFRadioGroup2.prototype.defaultUpdateAppearances = function() {
          this.updateAppearances();
        };
        PDFRadioGroup2.prototype.updateAppearances = function(provider) {
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var onValue = widget.getOnValue();
            if (!onValue)
              continue;
            this.updateWidgetAppearance(widget, onValue, provider);
          }
        };
        PDFRadioGroup2.prototype.updateWidgetAppearance = function(widget, onValue, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultRadioGroupAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget));
          this.updateOnOffWidgetAppearance(widget, onValue, appearances);
        };
        PDFRadioGroup2.of = function(acroRadioButton, ref, doc) {
          return new PDFRadioGroup2(acroRadioButton, ref, doc);
        };
        return PDFRadioGroup2;
      }(PDFField_1.default)
    );
    exports.default = PDFRadioGroup;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/form/PDFSignature.js
var require_PDFSignature = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/form/PDFSignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFField_1 = tslib_1.__importDefault(require_PDFField());
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFSignature = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFSignature2, _super);
        function PDFSignature2(acroSignature, ref, doc) {
          var _this = _super.call(this, acroSignature, ref, doc) || this;
          utils_1.assertIs(acroSignature, "acroSignature", [
            [core_1.PDFAcroSignature, "PDFAcroSignature"]
          ]);
          _this.acroField = acroSignature;
          return _this;
        }
        PDFSignature2.prototype.needsAppearancesUpdate = function() {
          return false;
        };
        PDFSignature2.of = function(acroSignature, ref, doc) {
          return new PDFSignature2(acroSignature, ref, doc);
        };
        return PDFSignature2;
      }(PDFField_1.default)
    );
    exports.default = PDFSignature;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/form/PDFTextField.js
var require_PDFTextField = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/form/PDFTextField.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var appearances_1 = require_appearances();
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var errors_1 = require_errors3();
    var alignment_1 = require_alignment2();
    var alignment_2 = require_alignment();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFTextField = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFTextField2, _super);
        function PDFTextField2(acroText, ref, doc) {
          var _this = _super.call(this, acroText, ref, doc) || this;
          utils_1.assertIs(acroText, "acroText", [[core_1.PDFAcroText, "PDFAcroText"]]);
          _this.acroField = acroText;
          return _this;
        }
        PDFTextField2.prototype.getText = function() {
          var value = this.acroField.getValue();
          if (!value && this.isRichFormatted()) {
            throw new errors_1.RichTextFieldReadError(this.getName());
          }
          return value === null || value === void 0 ? void 0 : value.decodeText();
        };
        PDFTextField2.prototype.setText = function(text) {
          utils_1.assertOrUndefined(text, "text", ["string"]);
          var maxLength = this.getMaxLength();
          if (maxLength !== void 0 && text && text.length > maxLength) {
            throw new errors_1.ExceededMaxLengthError(text.length, maxLength, this.getName());
          }
          this.markAsDirty();
          this.disableRichFormatting();
          if (text) {
            this.acroField.setValue(core_1.PDFHexString.fromText(text));
          } else {
            this.acroField.removeValue();
          }
        };
        PDFTextField2.prototype.getAlignment = function() {
          var quadding = this.acroField.getQuadding();
          return quadding === 0 ? alignment_2.TextAlignment.Left : quadding === 1 ? alignment_2.TextAlignment.Center : quadding === 2 ? alignment_2.TextAlignment.Right : alignment_2.TextAlignment.Left;
        };
        PDFTextField2.prototype.setAlignment = function(alignment) {
          utils_1.assertIsOneOf(alignment, "alignment", alignment_2.TextAlignment);
          this.markAsDirty();
          this.acroField.setQuadding(alignment);
        };
        PDFTextField2.prototype.getMaxLength = function() {
          return this.acroField.getMaxLength();
        };
        PDFTextField2.prototype.setMaxLength = function(maxLength) {
          utils_1.assertRangeOrUndefined(maxLength, "maxLength", 0, Number.MAX_SAFE_INTEGER);
          this.markAsDirty();
          if (maxLength === void 0) {
            this.acroField.removeMaxLength();
          } else {
            var text = this.getText();
            if (text && text.length > maxLength) {
              throw new errors_1.InvalidMaxLengthError(text.length, maxLength, this.getName());
            }
            this.acroField.setMaxLength(maxLength);
          }
        };
        PDFTextField2.prototype.removeMaxLength = function() {
          this.markAsDirty();
          this.acroField.removeMaxLength();
        };
        PDFTextField2.prototype.setImage = function(image) {
          var fieldAlignment = this.getAlignment();
          var alignment = fieldAlignment === alignment_2.TextAlignment.Center ? alignment_1.ImageAlignment.Center : fieldAlignment === alignment_2.TextAlignment.Right ? alignment_1.ImageAlignment.Right : alignment_1.ImageAlignment.Left;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var streamRef = this.createImageAppearanceStream(widget, image, alignment);
            this.updateWidgetAppearances(widget, { normal: streamRef });
          }
          this.markAsClean();
        };
        PDFTextField2.prototype.setFontSize = function(fontSize) {
          utils_1.assertPositive(fontSize, "fontSize");
          this.acroField.setFontSize(fontSize);
          this.markAsDirty();
        };
        PDFTextField2.prototype.isMultiline = function() {
          return this.acroField.hasFlag(core_1.AcroTextFlags.Multiline);
        };
        PDFTextField2.prototype.enableMultiline = function() {
          this.markAsDirty();
          this.acroField.setFlagTo(core_1.AcroTextFlags.Multiline, true);
        };
        PDFTextField2.prototype.disableMultiline = function() {
          this.markAsDirty();
          this.acroField.setFlagTo(core_1.AcroTextFlags.Multiline, false);
        };
        PDFTextField2.prototype.isPassword = function() {
          return this.acroField.hasFlag(core_1.AcroTextFlags.Password);
        };
        PDFTextField2.prototype.enablePassword = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.Password, true);
        };
        PDFTextField2.prototype.disablePassword = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.Password, false);
        };
        PDFTextField2.prototype.isFileSelector = function() {
          return this.acroField.hasFlag(core_1.AcroTextFlags.FileSelect);
        };
        PDFTextField2.prototype.enableFileSelection = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.FileSelect, true);
        };
        PDFTextField2.prototype.disableFileSelection = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.FileSelect, false);
        };
        PDFTextField2.prototype.isSpellChecked = function() {
          return !this.acroField.hasFlag(core_1.AcroTextFlags.DoNotSpellCheck);
        };
        PDFTextField2.prototype.enableSpellChecking = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotSpellCheck, false);
        };
        PDFTextField2.prototype.disableSpellChecking = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotSpellCheck, true);
        };
        PDFTextField2.prototype.isScrollable = function() {
          return !this.acroField.hasFlag(core_1.AcroTextFlags.DoNotScroll);
        };
        PDFTextField2.prototype.enableScrolling = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotScroll, false);
        };
        PDFTextField2.prototype.disableScrolling = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotScroll, true);
        };
        PDFTextField2.prototype.isCombed = function() {
          return this.acroField.hasFlag(core_1.AcroTextFlags.Comb) && !this.isMultiline() && !this.isPassword() && !this.isFileSelector() && this.getMaxLength() !== void 0;
        };
        PDFTextField2.prototype.enableCombing = function() {
          if (this.getMaxLength() === void 0) {
            var msg = "PDFTextFields must have a max length in order to be combed";
            console.warn(msg);
          }
          this.markAsDirty();
          this.disableMultiline();
          this.disablePassword();
          this.disableFileSelection();
          this.acroField.setFlagTo(core_1.AcroTextFlags.Comb, true);
        };
        PDFTextField2.prototype.disableCombing = function() {
          this.markAsDirty();
          this.acroField.setFlagTo(core_1.AcroTextFlags.Comb, false);
        };
        PDFTextField2.prototype.isRichFormatted = function() {
          return this.acroField.hasFlag(core_1.AcroTextFlags.RichText);
        };
        PDFTextField2.prototype.enableRichFormatting = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.RichText, true);
        };
        PDFTextField2.prototype.disableRichFormatting = function() {
          this.acroField.setFlagTo(core_1.AcroTextFlags.RichText, false);
        };
        PDFTextField2.prototype.addToPage = function(page, options) {
          var _a, _b, _c, _d, _e, _f, _g;
          utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          if (!options)
            options = {};
          if (!("textColor" in options))
            options.textColor = colors_1.rgb(0, 0, 0);
          if (!("backgroundColor" in options))
            options.backgroundColor = colors_1.rgb(1, 1, 1);
          if (!("borderColor" in options))
            options.borderColor = colors_1.rgb(0, 0, 0);
          if (!("borderWidth" in options))
            options.borderWidth = 1;
          var widget = this.createWidget({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,
            textColor: options.textColor,
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,
            rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            hidden: options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          this.acroField.addWidget(widgetRef);
          var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
          this.updateWidgetAppearance(widget, font);
          page.node.addAnnot(widgetRef);
        };
        PDFTextField2.prototype.needsAppearancesUpdate = function() {
          var _a;
          if (this.isDirty())
            return true;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof core_1.PDFStream;
            if (!hasAppearances)
              return true;
          }
          return false;
        };
        PDFTextField2.prototype.defaultUpdateAppearances = function(font) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          this.updateAppearances(font);
        };
        PDFTextField2.prototype.updateAppearances = function(font, provider) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            this.updateWidgetAppearance(widget, font, provider);
          }
          this.markAsClean();
        };
        PDFTextField2.prototype.updateWidgetAppearance = function(widget, font, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultTextFieldAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget, font));
          this.updateWidgetAppearanceWithFont(widget, font, appearances);
        };
        PDFTextField2.of = function(acroText, ref, doc) {
          return new PDFTextField2(acroText, ref, doc);
        };
        return PDFTextField2;
      }(PDFField_1.default)
    );
    exports.default = PDFTextField;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/StandardFonts.js
var require_StandardFonts = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/StandardFonts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StandardFonts = void 0;
    var StandardFonts2;
    (function(StandardFonts3) {
      StandardFonts3["Courier"] = "Courier";
      StandardFonts3["CourierBold"] = "Courier-Bold";
      StandardFonts3["CourierOblique"] = "Courier-Oblique";
      StandardFonts3["CourierBoldOblique"] = "Courier-BoldOblique";
      StandardFonts3["Helvetica"] = "Helvetica";
      StandardFonts3["HelveticaBold"] = "Helvetica-Bold";
      StandardFonts3["HelveticaOblique"] = "Helvetica-Oblique";
      StandardFonts3["HelveticaBoldOblique"] = "Helvetica-BoldOblique";
      StandardFonts3["TimesRoman"] = "Times-Roman";
      StandardFonts3["TimesRomanBold"] = "Times-Bold";
      StandardFonts3["TimesRomanItalic"] = "Times-Italic";
      StandardFonts3["TimesRomanBoldItalic"] = "Times-BoldItalic";
      StandardFonts3["Symbol"] = "Symbol";
      StandardFonts3["ZapfDingbats"] = "ZapfDingbats";
    })(StandardFonts2 = exports.StandardFonts || (exports.StandardFonts = {}));
  }
});

// ../../../node_modules/pdf-lib/cjs/api/form/PDFForm.js
var require_PDFForm = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/form/PDFForm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var PDFButton_1 = tslib_1.__importDefault(require_PDFButton());
    var PDFCheckBox_1 = tslib_1.__importDefault(require_PDFCheckBox());
    var PDFDropdown_1 = tslib_1.__importDefault(require_PDFDropdown());
    var PDFOptionList_1 = tslib_1.__importDefault(require_PDFOptionList());
    var PDFRadioGroup_1 = tslib_1.__importDefault(require_PDFRadioGroup());
    var PDFSignature_1 = tslib_1.__importDefault(require_PDFSignature());
    var PDFTextField_1 = tslib_1.__importDefault(require_PDFTextField());
    var errors_1 = require_errors3();
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var StandardFonts_1 = require_StandardFonts();
    var operations_1 = require_operations();
    var operators_1 = require_operators();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFForm = (
      /** @class */
      function() {
        function PDFForm2(acroForm, doc) {
          var _this = this;
          this.embedDefaultFont = function() {
            return _this.doc.embedStandardFont(StandardFonts_1.StandardFonts.Helvetica);
          };
          utils_1.assertIs(acroForm, "acroForm", [[core_1.PDFAcroForm, "PDFAcroForm"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          this.acroForm = acroForm;
          this.doc = doc;
          this.dirtyFields = /* @__PURE__ */ new Set();
          this.defaultFontCache = utils_1.Cache.populatedBy(this.embedDefaultFont);
        }
        PDFForm2.prototype.hasXFA = function() {
          return this.acroForm.dict.has(core_1.PDFName.of("XFA"));
        };
        PDFForm2.prototype.deleteXFA = function() {
          this.acroForm.dict.delete(core_1.PDFName.of("XFA"));
        };
        PDFForm2.prototype.getFields = function() {
          var allFields = this.acroForm.getAllFields();
          var fields = [];
          for (var idx = 0, len = allFields.length; idx < len; idx++) {
            var _a = allFields[idx], acroField = _a[0], ref = _a[1];
            var field = convertToPDFField(acroField, ref, this.doc);
            if (field)
              fields.push(field);
          }
          return fields;
        };
        PDFForm2.prototype.getFieldMaybe = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var fields = this.getFields();
          for (var idx = 0, len = fields.length; idx < len; idx++) {
            var field = fields[idx];
            if (field.getName() === name)
              return field;
          }
          return void 0;
        };
        PDFForm2.prototype.getField = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getFieldMaybe(name);
          if (field)
            return field;
          throw new errors_1.NoSuchFieldError(name);
        };
        PDFForm2.prototype.getButton = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFButton_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFButton_1.default, field);
        };
        PDFForm2.prototype.getCheckBox = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFCheckBox_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFCheckBox_1.default, field);
        };
        PDFForm2.prototype.getDropdown = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFDropdown_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFDropdown_1.default, field);
        };
        PDFForm2.prototype.getOptionList = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFOptionList_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFOptionList_1.default, field);
        };
        PDFForm2.prototype.getRadioGroup = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFRadioGroup_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFRadioGroup_1.default, field);
        };
        PDFForm2.prototype.getSignature = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFSignature_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFSignature_1.default, field);
        };
        PDFForm2.prototype.getTextField = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var field = this.getField(name);
          if (field instanceof PDFTextField_1.default)
            return field;
          throw new errors_1.UnexpectedFieldTypeError(name, PDFTextField_1.default, field);
        };
        PDFForm2.prototype.createButton = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var button = core_1.PDFAcroPushButton.create(this.doc.context);
          button.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [button, button.ref], nameParts.terminal);
          return PDFButton_1.default.of(button, button.ref, this.doc);
        };
        PDFForm2.prototype.createCheckBox = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var checkBox = core_1.PDFAcroCheckBox.create(this.doc.context);
          checkBox.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [checkBox, checkBox.ref], nameParts.terminal);
          return PDFCheckBox_1.default.of(checkBox, checkBox.ref, this.doc);
        };
        PDFForm2.prototype.createDropdown = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var comboBox = core_1.PDFAcroComboBox.create(this.doc.context);
          comboBox.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [comboBox, comboBox.ref], nameParts.terminal);
          return PDFDropdown_1.default.of(comboBox, comboBox.ref, this.doc);
        };
        PDFForm2.prototype.createOptionList = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var listBox = core_1.PDFAcroListBox.create(this.doc.context);
          listBox.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [listBox, listBox.ref], nameParts.terminal);
          return PDFOptionList_1.default.of(listBox, listBox.ref, this.doc);
        };
        PDFForm2.prototype.createRadioGroup = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var radioButton = core_1.PDFAcroRadioButton.create(this.doc.context);
          radioButton.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [radioButton, radioButton.ref], nameParts.terminal);
          return PDFRadioGroup_1.default.of(radioButton, radioButton.ref, this.doc);
        };
        PDFForm2.prototype.createTextField = function(name) {
          utils_1.assertIs(name, "name", ["string"]);
          var nameParts = splitFieldName(name);
          var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
          var text = core_1.PDFAcroText.create(this.doc.context);
          text.setPartialName(nameParts.terminal);
          addFieldToParent(parent, [text, text.ref], nameParts.terminal);
          return PDFTextField_1.default.of(text, text.ref, this.doc);
        };
        PDFForm2.prototype.flatten = function(options) {
          if (options === void 0) {
            options = { updateFieldAppearances: true };
          }
          if (options.updateFieldAppearances) {
            this.updateFieldAppearances();
          }
          var fields = this.getFields();
          for (var i = 0, lenFields = fields.length; i < lenFields; i++) {
            var field = fields[i];
            var widgets = field.acroField.getWidgets();
            for (var j = 0, lenWidgets = widgets.length; j < lenWidgets; j++) {
              var widget = widgets[j];
              var page = this.findWidgetPage(widget);
              var widgetRef = this.findWidgetAppearanceRef(field, widget);
              var xObjectKey = page.node.newXObject("FlatWidget", widgetRef);
              var rectangle = widget.getRectangle();
              var operators = tslib_1.__spreadArrays([
                operators_1.pushGraphicsState(),
                operators_1.translate(rectangle.x, rectangle.y)
              ], operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), { rotation: 0 })), [
                operators_1.drawObject(xObjectKey),
                operators_1.popGraphicsState()
              ]).filter(Boolean);
              page.pushOperators.apply(page, operators);
            }
            this.removeField(field);
          }
        };
        PDFForm2.prototype.removeField = function(field) {
          var widgets = field.acroField.getWidgets();
          var pages = /* @__PURE__ */ new Set();
          for (var i = 0, len = widgets.length; i < len; i++) {
            var widget = widgets[i];
            var widgetRef = this.findWidgetAppearanceRef(field, widget);
            var page = this.findWidgetPage(widget);
            pages.add(page);
            page.node.removeAnnot(widgetRef);
          }
          pages.forEach(function(page2) {
            return page2.node.removeAnnot(field.ref);
          });
          this.acroForm.removeField(field.acroField);
          var fieldKids = field.acroField.normalizedEntries().Kids;
          var kidsCount = fieldKids.size();
          for (var childIndex = 0; childIndex < kidsCount; childIndex++) {
            var child = fieldKids.get(childIndex);
            if (child instanceof core_1.PDFRef) {
              this.doc.context.delete(child);
            }
          }
          this.doc.context.delete(field.ref);
        };
        PDFForm2.prototype.updateFieldAppearances = function(font) {
          utils_1.assertOrUndefined(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          font = font !== null && font !== void 0 ? font : this.getDefaultFont();
          var fields = this.getFields();
          for (var idx = 0, len = fields.length; idx < len; idx++) {
            var field = fields[idx];
            if (field.needsAppearancesUpdate()) {
              field.defaultUpdateAppearances(font);
            }
          }
        };
        PDFForm2.prototype.markFieldAsDirty = function(fieldRef) {
          utils_1.assertOrUndefined(fieldRef, "fieldRef", [[core_1.PDFRef, "PDFRef"]]);
          this.dirtyFields.add(fieldRef);
        };
        PDFForm2.prototype.markFieldAsClean = function(fieldRef) {
          utils_1.assertOrUndefined(fieldRef, "fieldRef", [[core_1.PDFRef, "PDFRef"]]);
          this.dirtyFields.delete(fieldRef);
        };
        PDFForm2.prototype.fieldIsDirty = function(fieldRef) {
          utils_1.assertOrUndefined(fieldRef, "fieldRef", [[core_1.PDFRef, "PDFRef"]]);
          return this.dirtyFields.has(fieldRef);
        };
        PDFForm2.prototype.getDefaultFont = function() {
          return this.defaultFontCache.access();
        };
        PDFForm2.prototype.findWidgetPage = function(widget) {
          var pageRef = widget.P();
          var page = this.doc.getPages().find(function(x) {
            return x.ref === pageRef;
          });
          if (page === void 0) {
            var widgetRef = this.doc.context.getObjectRef(widget.dict);
            if (widgetRef === void 0) {
              throw new Error("Could not find PDFRef for PDFObject");
            }
            page = this.doc.findPageForAnnotationRef(widgetRef);
            if (page === void 0) {
              throw new Error("Could not find page for PDFRef " + widgetRef);
            }
          }
          return page;
        };
        PDFForm2.prototype.findWidgetAppearanceRef = function(field, widget) {
          var _a;
          var refOrDict = widget.getNormalAppearance();
          if (refOrDict instanceof core_1.PDFDict && (field instanceof PDFCheckBox_1.default || field instanceof PDFRadioGroup_1.default)) {
            var value = field.acroField.getValue();
            var ref = (_a = refOrDict.get(value)) !== null && _a !== void 0 ? _a : refOrDict.get(core_1.PDFName.of("Off"));
            if (ref instanceof core_1.PDFRef) {
              refOrDict = ref;
            }
          }
          if (!(refOrDict instanceof core_1.PDFRef)) {
            var name_1 = field.getName();
            throw new Error("Failed to extract appearance ref for: " + name_1);
          }
          return refOrDict;
        };
        PDFForm2.prototype.findOrCreateNonTerminals = function(partialNames) {
          var nonTerminal = [
            this.acroForm
          ];
          for (var idx = 0, len = partialNames.length; idx < len; idx++) {
            var namePart = partialNames[idx];
            if (!namePart)
              throw new errors_1.InvalidFieldNamePartError(namePart);
            var parent_1 = nonTerminal[0], parentRef = nonTerminal[1];
            var res = this.findNonTerminal(namePart, parent_1);
            if (res) {
              nonTerminal = res;
            } else {
              var node = core_1.PDFAcroNonTerminal.create(this.doc.context);
              node.setPartialName(namePart);
              node.setParent(parentRef);
              var nodeRef = this.doc.context.register(node.dict);
              parent_1.addField(nodeRef);
              nonTerminal = [node, nodeRef];
            }
          }
          return nonTerminal;
        };
        PDFForm2.prototype.findNonTerminal = function(partialName, parent) {
          var fields = parent instanceof core_1.PDFAcroForm ? this.acroForm.getFields() : core_1.createPDFAcroFields(parent.Kids());
          for (var idx = 0, len = fields.length; idx < len; idx++) {
            var _a = fields[idx], field = _a[0], ref = _a[1];
            if (field.getPartialName() === partialName) {
              if (field instanceof core_1.PDFAcroNonTerminal)
                return [field, ref];
              throw new errors_1.FieldAlreadyExistsError(partialName);
            }
          }
          return void 0;
        };
        PDFForm2.of = function(acroForm, doc) {
          return new PDFForm2(acroForm, doc);
        };
        return PDFForm2;
      }()
    );
    exports.default = PDFForm;
    var convertToPDFField = function(field, ref, doc) {
      if (field instanceof core_1.PDFAcroPushButton)
        return PDFButton_1.default.of(field, ref, doc);
      if (field instanceof core_1.PDFAcroCheckBox)
        return PDFCheckBox_1.default.of(field, ref, doc);
      if (field instanceof core_1.PDFAcroComboBox)
        return PDFDropdown_1.default.of(field, ref, doc);
      if (field instanceof core_1.PDFAcroListBox)
        return PDFOptionList_1.default.of(field, ref, doc);
      if (field instanceof core_1.PDFAcroText)
        return PDFTextField_1.default.of(field, ref, doc);
      if (field instanceof core_1.PDFAcroRadioButton) {
        return PDFRadioGroup_1.default.of(field, ref, doc);
      }
      if (field instanceof core_1.PDFAcroSignature) {
        return PDFSignature_1.default.of(field, ref, doc);
      }
      return void 0;
    };
    var splitFieldName = function(fullyQualifiedName) {
      if (fullyQualifiedName.length === 0) {
        throw new Error("PDF field names must not be empty strings");
      }
      var parts = fullyQualifiedName.split(".");
      for (var idx = 0, len = parts.length; idx < len; idx++) {
        if (parts[idx] === "") {
          throw new Error('Periods in PDF field names must be separated by at least one character: "' + fullyQualifiedName + '"');
        }
      }
      if (parts.length === 1)
        return { nonTerminal: [], terminal: parts[0] };
      return {
        nonTerminal: parts.slice(0, parts.length - 1),
        terminal: parts[parts.length - 1]
      };
    };
    var addFieldToParent = function(_a, _b, partialName) {
      var parent = _a[0], parentRef = _a[1];
      var field = _b[0], fieldRef = _b[1];
      var entries = parent.normalizedEntries();
      var fields = core_1.createPDFAcroFields("Kids" in entries ? entries.Kids : entries.Fields);
      for (var idx = 0, len = fields.length; idx < len; idx++) {
        if (fields[idx][0].getPartialName() === partialName) {
          throw new errors_1.FieldAlreadyExistsError(partialName);
        }
      }
      parent.addField(fieldRef);
      field.setParent(parentRef);
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/api/sizes.js
var require_sizes = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/sizes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageSizes = void 0;
    exports.PageSizes = {
      "4A0": [4767.87, 6740.79],
      "2A0": [3370.39, 4767.87],
      A0: [2383.94, 3370.39],
      A1: [1683.78, 2383.94],
      A2: [1190.55, 1683.78],
      A3: [841.89, 1190.55],
      A4: [595.28, 841.89],
      A5: [419.53, 595.28],
      A6: [297.64, 419.53],
      A7: [209.76, 297.64],
      A8: [147.4, 209.76],
      A9: [104.88, 147.4],
      A10: [73.7, 104.88],
      B0: [2834.65, 4008.19],
      B1: [2004.09, 2834.65],
      B2: [1417.32, 2004.09],
      B3: [1000.63, 1417.32],
      B4: [708.66, 1000.63],
      B5: [498.9, 708.66],
      B6: [354.33, 498.9],
      B7: [249.45, 354.33],
      B8: [175.75, 249.45],
      B9: [124.72, 175.75],
      B10: [87.87, 124.72],
      C0: [2599.37, 3676.54],
      C1: [1836.85, 2599.37],
      C2: [1298.27, 1836.85],
      C3: [918.43, 1298.27],
      C4: [649.13, 918.43],
      C5: [459.21, 649.13],
      C6: [323.15, 459.21],
      C7: [229.61, 323.15],
      C8: [161.57, 229.61],
      C9: [113.39, 161.57],
      C10: [79.37, 113.39],
      RA0: [2437.8, 3458.27],
      RA1: [1729.13, 2437.8],
      RA2: [1218.9, 1729.13],
      RA3: [864.57, 1218.9],
      RA4: [609.45, 864.57],
      SRA0: [2551.18, 3628.35],
      SRA1: [1814.17, 2551.18],
      SRA2: [1275.59, 1814.17],
      SRA3: [907.09, 1275.59],
      SRA4: [637.8, 907.09],
      Executive: [521.86, 756],
      Folio: [612, 936],
      Legal: [612, 1008],
      Letter: [612, 792],
      Tabloid: [792, 1224]
    };
  }
});

// ../../../node_modules/pdf-lib/cjs/api/PDFDocumentOptions.js
var require_PDFDocumentOptions = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/PDFDocumentOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseSpeeds = void 0;
    var ParseSpeeds;
    (function(ParseSpeeds2) {
      ParseSpeeds2[ParseSpeeds2["Fastest"] = Infinity] = "Fastest";
      ParseSpeeds2[ParseSpeeds2["Fast"] = 1500] = "Fast";
      ParseSpeeds2[ParseSpeeds2["Medium"] = 500] = "Medium";
      ParseSpeeds2[ParseSpeeds2["Slow"] = 100] = "Slow";
    })(ParseSpeeds = exports.ParseSpeeds || (exports.ParseSpeeds = {}));
  }
});

// ../../../node_modules/pdf-lib/cjs/api/PDFEmbeddedFile.js
var require_PDFEmbeddedFile = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/PDFEmbeddedFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var core_1 = require_core();
    var PDFEmbeddedFile = (
      /** @class */
      function() {
        function PDFEmbeddedFile2(ref, doc, embedder) {
          this.alreadyEmbedded = false;
          this.ref = ref;
          this.doc = doc;
          this.embedder = embedder;
        }
        PDFEmbeddedFile2.prototype.embed = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var ref, Names, EmbeddedFiles, EFNames, AF;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!!this.alreadyEmbedded)
                    return [3, 2];
                  return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
                case 1:
                  ref = _a.sent();
                  if (!this.doc.catalog.has(core_1.PDFName.of("Names"))) {
                    this.doc.catalog.set(core_1.PDFName.of("Names"), this.doc.context.obj({}));
                  }
                  Names = this.doc.catalog.lookup(core_1.PDFName.of("Names"), core_1.PDFDict);
                  if (!Names.has(core_1.PDFName.of("EmbeddedFiles"))) {
                    Names.set(core_1.PDFName.of("EmbeddedFiles"), this.doc.context.obj({}));
                  }
                  EmbeddedFiles = Names.lookup(core_1.PDFName.of("EmbeddedFiles"), core_1.PDFDict);
                  if (!EmbeddedFiles.has(core_1.PDFName.of("Names"))) {
                    EmbeddedFiles.set(core_1.PDFName.of("Names"), this.doc.context.obj([]));
                  }
                  EFNames = EmbeddedFiles.lookup(core_1.PDFName.of("Names"), core_1.PDFArray);
                  EFNames.push(core_1.PDFHexString.fromText(this.embedder.fileName));
                  EFNames.push(ref);
                  if (!this.doc.catalog.has(core_1.PDFName.of("AF"))) {
                    this.doc.catalog.set(core_1.PDFName.of("AF"), this.doc.context.obj([]));
                  }
                  AF = this.doc.catalog.lookup(core_1.PDFName.of("AF"), core_1.PDFArray);
                  AF.push(ref);
                  this.alreadyEmbedded = true;
                  _a.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFEmbeddedFile2.of = function(ref, doc, embedder) {
          return new PDFEmbeddedFile2(ref, doc, embedder);
        };
        return PDFEmbeddedFile2;
      }()
    );
    exports.default = PDFEmbeddedFile;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/PDFJavaScript.js
var require_PDFJavaScript = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/PDFJavaScript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var core_1 = require_core();
    var PDFJavaScript = (
      /** @class */
      function() {
        function PDFJavaScript2(ref, doc, embedder) {
          this.alreadyEmbedded = false;
          this.ref = ref;
          this.doc = doc;
          this.embedder = embedder;
        }
        PDFJavaScript2.prototype.embed = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, catalog, context, ref, Names, Javascript, JSNames;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!!this.alreadyEmbedded)
                    return [3, 2];
                  _a = this.doc, catalog = _a.catalog, context = _a.context;
                  return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
                case 1:
                  ref = _b.sent();
                  if (!catalog.has(core_1.PDFName.of("Names"))) {
                    catalog.set(core_1.PDFName.of("Names"), context.obj({}));
                  }
                  Names = catalog.lookup(core_1.PDFName.of("Names"), core_1.PDFDict);
                  if (!Names.has(core_1.PDFName.of("JavaScript"))) {
                    Names.set(core_1.PDFName.of("JavaScript"), context.obj({}));
                  }
                  Javascript = Names.lookup(core_1.PDFName.of("JavaScript"), core_1.PDFDict);
                  if (!Javascript.has(core_1.PDFName.of("Names"))) {
                    Javascript.set(core_1.PDFName.of("Names"), context.obj([]));
                  }
                  JSNames = Javascript.lookup(core_1.PDFName.of("Names"), core_1.PDFArray);
                  JSNames.push(core_1.PDFHexString.fromText(this.embedder.scriptName));
                  JSNames.push(ref);
                  this.alreadyEmbedded = true;
                  _b.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFJavaScript2.of = function(ref, doc, embedder) {
          return new PDFJavaScript2(ref, doc, embedder);
        };
        return PDFJavaScript2;
      }()
    );
    exports.default = PDFJavaScript;
  }
});

// ../../../node_modules/pdf-lib/cjs/core/embedders/JavaScriptEmbedder.js
var require_JavaScriptEmbedder = __commonJS({
  "../../../node_modules/pdf-lib/cjs/core/embedders/JavaScriptEmbedder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFHexString_1 = tslib_1.__importDefault(require_PDFHexString());
    var JavaScriptEmbedder = (
      /** @class */
      function() {
        function JavaScriptEmbedder2(script, scriptName) {
          this.script = script;
          this.scriptName = scriptName;
        }
        JavaScriptEmbedder2.for = function(script, scriptName) {
          return new JavaScriptEmbedder2(script, scriptName);
        };
        JavaScriptEmbedder2.prototype.embedIntoContext = function(context, ref) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var jsActionDict;
            return tslib_1.__generator(this, function(_a) {
              jsActionDict = context.obj({
                Type: "Action",
                S: "JavaScript",
                JS: PDFHexString_1.default.fromText(this.script)
              });
              if (ref) {
                context.assign(ref, jsActionDict);
                return [2, ref];
              } else {
                return [2, context.register(jsActionDict)];
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        return JavaScriptEmbedder2;
      }()
    );
    exports.default = JavaScriptEmbedder;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/PDFDocument.js
var require_PDFDocument = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/PDFDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors3();
    var PDFEmbeddedPage_1 = tslib_1.__importDefault(require_PDFEmbeddedPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var PDFImage_1 = tslib_1.__importDefault(require_PDFImage());
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFForm_1 = tslib_1.__importDefault(require_PDFForm());
    var sizes_1 = require_sizes();
    var core_1 = require_core();
    var PDFDocumentOptions_1 = require_PDFDocumentOptions();
    var utils_1 = require_utils2();
    var FileEmbedder_1 = tslib_1.__importStar(require_FileEmbedder());
    var PDFEmbeddedFile_1 = tslib_1.__importDefault(require_PDFEmbeddedFile());
    var PDFJavaScript_1 = tslib_1.__importDefault(require_PDFJavaScript());
    var JavaScriptEmbedder_1 = tslib_1.__importDefault(require_JavaScriptEmbedder());
    var PDFDocument2 = (
      /** @class */
      function() {
        function PDFDocument3(context, ignoreEncryption, updateMetadata) {
          var _this = this;
          this.defaultWordBreaks = [" "];
          this.computePages = function() {
            var pages = [];
            _this.catalog.Pages().traverse(function(node, ref) {
              if (node instanceof core_1.PDFPageLeaf) {
                var page = _this.pageMap.get(node);
                if (!page) {
                  page = PDFPage_1.default.of(node, ref, _this);
                  _this.pageMap.set(node, page);
                }
                pages.push(page);
              }
            });
            return pages;
          };
          this.getOrCreateForm = function() {
            var acroForm = _this.catalog.getOrCreateAcroForm();
            return PDFForm_1.default.of(acroForm, _this);
          };
          utils_1.assertIs(context, "context", [[core_1.PDFContext, "PDFContext"]]);
          utils_1.assertIs(ignoreEncryption, "ignoreEncryption", ["boolean"]);
          this.context = context;
          this.catalog = context.lookup(context.trailerInfo.Root);
          this.isEncrypted = !!context.lookup(context.trailerInfo.Encrypt);
          this.pageCache = utils_1.Cache.populatedBy(this.computePages);
          this.pageMap = /* @__PURE__ */ new Map();
          this.formCache = utils_1.Cache.populatedBy(this.getOrCreateForm);
          this.fonts = [];
          this.images = [];
          this.embeddedPages = [];
          this.embeddedFiles = [];
          this.javaScripts = [];
          if (!ignoreEncryption && this.isEncrypted)
            throw new errors_1.EncryptedPDFError();
          if (updateMetadata)
            this.updateInfoDict();
        }
        PDFDocument3.load = function(pdf, options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, ignoreEncryption, _b, parseSpeed, _c, throwOnInvalidObject, _d, updateMetadata, _e, capNumbers, bytes, context;
            return tslib_1.__generator(this, function(_f) {
              switch (_f.label) {
                case 0:
                  _a = options.ignoreEncryption, ignoreEncryption = _a === void 0 ? false : _a, _b = options.parseSpeed, parseSpeed = _b === void 0 ? PDFDocumentOptions_1.ParseSpeeds.Slow : _b, _c = options.throwOnInvalidObject, throwOnInvalidObject = _c === void 0 ? false : _c, _d = options.updateMetadata, updateMetadata = _d === void 0 ? true : _d, _e = options.capNumbers, capNumbers = _e === void 0 ? false : _e;
                  utils_1.assertIs(pdf, "pdf", ["string", Uint8Array, ArrayBuffer]);
                  utils_1.assertIs(ignoreEncryption, "ignoreEncryption", ["boolean"]);
                  utils_1.assertIs(parseSpeed, "parseSpeed", ["number"]);
                  utils_1.assertIs(throwOnInvalidObject, "throwOnInvalidObject", ["boolean"]);
                  bytes = utils_1.toUint8Array(pdf);
                  return [4, core_1.PDFParser.forBytesWithOptions(bytes, parseSpeed, throwOnInvalidObject, capNumbers).parseDocument()];
                case 1:
                  context = _f.sent();
                  return [2, new PDFDocument3(context, ignoreEncryption, updateMetadata)];
              }
            });
          });
        };
        PDFDocument3.create = function(options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, updateMetadata, context, pageTree, pageTreeRef, catalog;
            return tslib_1.__generator(this, function(_b) {
              _a = options.updateMetadata, updateMetadata = _a === void 0 ? true : _a;
              context = core_1.PDFContext.create();
              pageTree = core_1.PDFPageTree.withContext(context);
              pageTreeRef = context.register(pageTree);
              catalog = core_1.PDFCatalog.withContextAndPages(context, pageTreeRef);
              context.trailerInfo.Root = context.register(catalog);
              return [2, new PDFDocument3(context, false, updateMetadata)];
            });
          });
        };
        PDFDocument3.prototype.registerFontkit = function(fontkit) {
          this.fontkit = fontkit;
        };
        PDFDocument3.prototype.getForm = function() {
          var form = this.formCache.access();
          if (form.hasXFA()) {
            console.warn("Removing XFA form data as pdf-lib does not support reading or writing XFA");
            form.deleteXFA();
          }
          return form;
        };
        PDFDocument3.prototype.getTitle = function() {
          var title = this.getInfoDict().lookup(core_1.PDFName.Title);
          if (!title)
            return void 0;
          assertIsLiteralOrHexString(title);
          return title.decodeText();
        };
        PDFDocument3.prototype.getAuthor = function() {
          var author = this.getInfoDict().lookup(core_1.PDFName.Author);
          if (!author)
            return void 0;
          assertIsLiteralOrHexString(author);
          return author.decodeText();
        };
        PDFDocument3.prototype.getSubject = function() {
          var subject = this.getInfoDict().lookup(core_1.PDFName.Subject);
          if (!subject)
            return void 0;
          assertIsLiteralOrHexString(subject);
          return subject.decodeText();
        };
        PDFDocument3.prototype.getKeywords = function() {
          var keywords = this.getInfoDict().lookup(core_1.PDFName.Keywords);
          if (!keywords)
            return void 0;
          assertIsLiteralOrHexString(keywords);
          return keywords.decodeText();
        };
        PDFDocument3.prototype.getCreator = function() {
          var creator = this.getInfoDict().lookup(core_1.PDFName.Creator);
          if (!creator)
            return void 0;
          assertIsLiteralOrHexString(creator);
          return creator.decodeText();
        };
        PDFDocument3.prototype.getProducer = function() {
          var producer = this.getInfoDict().lookup(core_1.PDFName.Producer);
          if (!producer)
            return void 0;
          assertIsLiteralOrHexString(producer);
          return producer.decodeText();
        };
        PDFDocument3.prototype.getCreationDate = function() {
          var creationDate = this.getInfoDict().lookup(core_1.PDFName.CreationDate);
          if (!creationDate)
            return void 0;
          assertIsLiteralOrHexString(creationDate);
          return creationDate.decodeDate();
        };
        PDFDocument3.prototype.getModificationDate = function() {
          var modificationDate = this.getInfoDict().lookup(core_1.PDFName.ModDate);
          if (!modificationDate)
            return void 0;
          assertIsLiteralOrHexString(modificationDate);
          return modificationDate.decodeDate();
        };
        PDFDocument3.prototype.setTitle = function(title, options) {
          utils_1.assertIs(title, "title", ["string"]);
          var key = core_1.PDFName.of("Title");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(title));
          if (options === null || options === void 0 ? void 0 : options.showInWindowTitleBar) {
            var prefs = this.catalog.getOrCreateViewerPreferences();
            prefs.setDisplayDocTitle(true);
          }
        };
        PDFDocument3.prototype.setAuthor = function(author) {
          utils_1.assertIs(author, "author", ["string"]);
          var key = core_1.PDFName.of("Author");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(author));
        };
        PDFDocument3.prototype.setSubject = function(subject) {
          utils_1.assertIs(subject, "author", ["string"]);
          var key = core_1.PDFName.of("Subject");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(subject));
        };
        PDFDocument3.prototype.setKeywords = function(keywords) {
          utils_1.assertIs(keywords, "keywords", [Array]);
          var key = core_1.PDFName.of("Keywords");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(keywords.join(" ")));
        };
        PDFDocument3.prototype.setCreator = function(creator) {
          utils_1.assertIs(creator, "creator", ["string"]);
          var key = core_1.PDFName.of("Creator");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(creator));
        };
        PDFDocument3.prototype.setProducer = function(producer) {
          utils_1.assertIs(producer, "creator", ["string"]);
          var key = core_1.PDFName.of("Producer");
          this.getInfoDict().set(key, core_1.PDFHexString.fromText(producer));
        };
        PDFDocument3.prototype.setLanguage = function(language) {
          utils_1.assertIs(language, "language", ["string"]);
          var key = core_1.PDFName.of("Lang");
          this.catalog.set(key, core_1.PDFString.of(language));
        };
        PDFDocument3.prototype.setCreationDate = function(creationDate) {
          utils_1.assertIs(creationDate, "creationDate", [[Date, "Date"]]);
          var key = core_1.PDFName.of("CreationDate");
          this.getInfoDict().set(key, core_1.PDFString.fromDate(creationDate));
        };
        PDFDocument3.prototype.setModificationDate = function(modificationDate) {
          utils_1.assertIs(modificationDate, "modificationDate", [[Date, "Date"]]);
          var key = core_1.PDFName.of("ModDate");
          this.getInfoDict().set(key, core_1.PDFString.fromDate(modificationDate));
        };
        PDFDocument3.prototype.getPageCount = function() {
          if (this.pageCount === void 0)
            this.pageCount = this.getPages().length;
          return this.pageCount;
        };
        PDFDocument3.prototype.getPages = function() {
          return this.pageCache.access();
        };
        PDFDocument3.prototype.getPage = function(index2) {
          var pages = this.getPages();
          utils_1.assertRange(index2, "index", 0, pages.length - 1);
          return pages[index2];
        };
        PDFDocument3.prototype.getPageIndices = function() {
          return utils_1.range(0, this.getPageCount());
        };
        PDFDocument3.prototype.removePage = function(index2) {
          var pageCount = this.getPageCount();
          if (this.pageCount === 0)
            throw new errors_1.RemovePageFromEmptyDocumentError();
          utils_1.assertRange(index2, "index", 0, pageCount - 1);
          this.catalog.removeLeafNode(index2);
          this.pageCount = pageCount - 1;
        };
        PDFDocument3.prototype.addPage = function(page) {
          utils_1.assertIs(page, "page", ["undefined", [PDFPage_1.default, "PDFPage"], Array]);
          return this.insertPage(this.getPageCount(), page);
        };
        PDFDocument3.prototype.insertPage = function(index2, page) {
          var pageCount = this.getPageCount();
          utils_1.assertRange(index2, "index", 0, pageCount);
          utils_1.assertIs(page, "page", ["undefined", [PDFPage_1.default, "PDFPage"], Array]);
          if (!page || Array.isArray(page)) {
            var dims = Array.isArray(page) ? page : sizes_1.PageSizes.A4;
            page = PDFPage_1.default.create(this);
            page.setSize.apply(page, dims);
          } else if (page.doc !== this) {
            throw new errors_1.ForeignPageError();
          }
          var parentRef = this.catalog.insertLeafNode(page.ref, index2);
          page.node.setParent(parentRef);
          this.pageMap.set(page.node, page);
          this.pageCache.invalidate();
          this.pageCount = pageCount + 1;
          return page;
        };
        PDFDocument3.prototype.copyPages = function(srcDoc, indices) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var copier, srcPages, copiedPages, idx, len, srcPage, copiedPage, ref;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  utils_1.assertIs(srcDoc, "srcDoc", [[PDFDocument3, "PDFDocument"]]);
                  utils_1.assertIs(indices, "indices", [Array]);
                  return [4, srcDoc.flush()];
                case 1:
                  _a.sent();
                  copier = core_1.PDFObjectCopier.for(srcDoc.context, this.context);
                  srcPages = srcDoc.getPages();
                  copiedPages = new Array(indices.length);
                  for (idx = 0, len = indices.length; idx < len; idx++) {
                    srcPage = srcPages[indices[idx]];
                    copiedPage = copier.copy(srcPage.node);
                    ref = this.context.register(copiedPage);
                    copiedPages[idx] = PDFPage_1.default.of(copiedPage, ref, this);
                  }
                  return [2, copiedPages];
              }
            });
          });
        };
        PDFDocument3.prototype.copy = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var pdfCopy, contentPages, idx, len;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, PDFDocument3.create()];
                case 1:
                  pdfCopy = _a.sent();
                  return [4, pdfCopy.copyPages(this, this.getPageIndices())];
                case 2:
                  contentPages = _a.sent();
                  for (idx = 0, len = contentPages.length; idx < len; idx++) {
                    pdfCopy.addPage(contentPages[idx]);
                  }
                  if (this.getAuthor() !== void 0) {
                    pdfCopy.setAuthor(this.getAuthor());
                  }
                  if (this.getCreationDate() !== void 0) {
                    pdfCopy.setCreationDate(this.getCreationDate());
                  }
                  if (this.getCreator() !== void 0) {
                    pdfCopy.setCreator(this.getCreator());
                  }
                  if (this.getModificationDate() !== void 0) {
                    pdfCopy.setModificationDate(this.getModificationDate());
                  }
                  if (this.getProducer() !== void 0) {
                    pdfCopy.setProducer(this.getProducer());
                  }
                  if (this.getSubject() !== void 0) {
                    pdfCopy.setSubject(this.getSubject());
                  }
                  if (this.getTitle() !== void 0) {
                    pdfCopy.setTitle(this.getTitle());
                  }
                  pdfCopy.defaultWordBreaks = this.defaultWordBreaks;
                  return [2, pdfCopy];
              }
            });
          });
        };
        PDFDocument3.prototype.addJavaScript = function(name, script) {
          utils_1.assertIs(name, "name", ["string"]);
          utils_1.assertIs(script, "script", ["string"]);
          var embedder = JavaScriptEmbedder_1.default.for(script, name);
          var ref = this.context.nextRef();
          var javaScript = PDFJavaScript_1.default.of(ref, this, embedder);
          this.javaScripts.push(javaScript);
        };
        PDFDocument3.prototype.attach = function(attachment, name, options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var bytes, embedder, ref, embeddedFile;
            return tslib_1.__generator(this, function(_a) {
              utils_1.assertIs(attachment, "attachment", ["string", Uint8Array, ArrayBuffer]);
              utils_1.assertIs(name, "name", ["string"]);
              utils_1.assertOrUndefined(options.mimeType, "mimeType", ["string"]);
              utils_1.assertOrUndefined(options.description, "description", ["string"]);
              utils_1.assertOrUndefined(options.creationDate, "options.creationDate", [Date]);
              utils_1.assertOrUndefined(options.modificationDate, "options.modificationDate", [
                Date
              ]);
              utils_1.assertIsOneOfOrUndefined(options.afRelationship, "options.afRelationship", FileEmbedder_1.AFRelationship);
              bytes = utils_1.toUint8Array(attachment);
              embedder = FileEmbedder_1.default.for(bytes, name, options);
              ref = this.context.nextRef();
              embeddedFile = PDFEmbeddedFile_1.default.of(ref, this, embedder);
              this.embeddedFiles.push(embeddedFile);
              return [
                2
                /*return*/
              ];
            });
          });
        };
        PDFDocument3.prototype.embedFont = function(font, options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, subset, customName, features, embedder, bytes, fontkit, _b, ref, pdfFont;
            return tslib_1.__generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  _a = options.subset, subset = _a === void 0 ? false : _a, customName = options.customName, features = options.features;
                  utils_1.assertIs(font, "font", ["string", Uint8Array, ArrayBuffer]);
                  utils_1.assertIs(subset, "subset", ["boolean"]);
                  if (!utils_1.isStandardFont(font))
                    return [3, 1];
                  embedder = core_1.StandardFontEmbedder.for(font, customName);
                  return [3, 7];
                case 1:
                  if (!utils_1.canBeConvertedToUint8Array(font))
                    return [3, 6];
                  bytes = utils_1.toUint8Array(font);
                  fontkit = this.assertFontkit();
                  if (!subset)
                    return [3, 3];
                  return [4, core_1.CustomFontSubsetEmbedder.for(fontkit, bytes, customName, features)];
                case 2:
                  _b = _c.sent();
                  return [3, 5];
                case 3:
                  return [4, core_1.CustomFontEmbedder.for(fontkit, bytes, customName, features)];
                case 4:
                  _b = _c.sent();
                  _c.label = 5;
                case 5:
                  embedder = _b;
                  return [3, 7];
                case 6:
                  throw new TypeError("`font` must be one of `StandardFonts | string | Uint8Array | ArrayBuffer`");
                case 7:
                  ref = this.context.nextRef();
                  pdfFont = PDFFont_1.default.of(ref, this, embedder);
                  this.fonts.push(pdfFont);
                  return [2, pdfFont];
              }
            });
          });
        };
        PDFDocument3.prototype.embedStandardFont = function(font, customName) {
          utils_1.assertIs(font, "font", ["string"]);
          if (!utils_1.isStandardFont(font)) {
            throw new TypeError("`font` must be one of type `StandardFonts`");
          }
          var embedder = core_1.StandardFontEmbedder.for(font, customName);
          var ref = this.context.nextRef();
          var pdfFont = PDFFont_1.default.of(ref, this, embedder);
          this.fonts.push(pdfFont);
          return pdfFont;
        };
        PDFDocument3.prototype.embedJpg = function(jpg) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var bytes, embedder, ref, pdfImage;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  utils_1.assertIs(jpg, "jpg", ["string", Uint8Array, ArrayBuffer]);
                  bytes = utils_1.toUint8Array(jpg);
                  return [4, core_1.JpegEmbedder.for(bytes)];
                case 1:
                  embedder = _a.sent();
                  ref = this.context.nextRef();
                  pdfImage = PDFImage_1.default.of(ref, this, embedder);
                  this.images.push(pdfImage);
                  return [2, pdfImage];
              }
            });
          });
        };
        PDFDocument3.prototype.embedPng = function(png) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var bytes, embedder, ref, pdfImage;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  utils_1.assertIs(png, "png", ["string", Uint8Array, ArrayBuffer]);
                  bytes = utils_1.toUint8Array(png);
                  return [4, core_1.PngEmbedder.for(bytes)];
                case 1:
                  embedder = _a.sent();
                  ref = this.context.nextRef();
                  pdfImage = PDFImage_1.default.of(ref, this, embedder);
                  this.images.push(pdfImage);
                  return [2, pdfImage];
              }
            });
          });
        };
        PDFDocument3.prototype.embedPdf = function(pdf, indices) {
          if (indices === void 0) {
            indices = [0];
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var srcDoc, _a, srcPages;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  utils_1.assertIs(pdf, "pdf", [
                    "string",
                    Uint8Array,
                    ArrayBuffer,
                    [PDFDocument3, "PDFDocument"]
                  ]);
                  utils_1.assertIs(indices, "indices", [Array]);
                  if (!(pdf instanceof PDFDocument3))
                    return [3, 1];
                  _a = pdf;
                  return [3, 3];
                case 1:
                  return [4, PDFDocument3.load(pdf)];
                case 2:
                  _a = _b.sent();
                  _b.label = 3;
                case 3:
                  srcDoc = _a;
                  srcPages = utils_1.pluckIndices(srcDoc.getPages(), indices);
                  return [2, this.embedPages(srcPages)];
              }
            });
          });
        };
        PDFDocument3.prototype.embedPage = function(page, boundingBox, transformationMatrix) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var embeddedPage;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  utils_1.assertIs(page, "page", [[PDFPage_1.default, "PDFPage"]]);
                  return [4, this.embedPages([page], [boundingBox], [transformationMatrix])];
                case 1:
                  embeddedPage = _a.sent()[0];
                  return [2, embeddedPage];
              }
            });
          });
        };
        PDFDocument3.prototype.embedPages = function(pages, boundingBoxes, transformationMatrices) {
          if (boundingBoxes === void 0) {
            boundingBoxes = [];
          }
          if (transformationMatrices === void 0) {
            transformationMatrices = [];
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var idx, len, currPage, nextPage, context, maybeCopyPage, embeddedPages, idx, len, page, box, matrix, embedder, ref;
            var _a;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (pages.length === 0)
                    return [2, []];
                  for (idx = 0, len = pages.length - 1; idx < len; idx++) {
                    currPage = pages[idx];
                    nextPage = pages[idx + 1];
                    if (currPage.node.context !== nextPage.node.context) {
                      throw new core_1.PageEmbeddingMismatchedContextError();
                    }
                  }
                  context = pages[0].node.context;
                  maybeCopyPage = context === this.context ? function(p) {
                    return p;
                  } : core_1.PDFObjectCopier.for(context, this.context).copy;
                  embeddedPages = new Array(pages.length);
                  idx = 0, len = pages.length;
                  _b.label = 1;
                case 1:
                  if (!(idx < len))
                    return [3, 4];
                  page = maybeCopyPage(pages[idx].node);
                  box = boundingBoxes[idx];
                  matrix = transformationMatrices[idx];
                  return [4, core_1.PDFPageEmbedder.for(page, box, matrix)];
                case 2:
                  embedder = _b.sent();
                  ref = this.context.nextRef();
                  embeddedPages[idx] = PDFEmbeddedPage_1.default.of(ref, this, embedder);
                  _b.label = 3;
                case 3:
                  idx++;
                  return [3, 1];
                case 4:
                  (_a = this.embeddedPages).push.apply(_a, embeddedPages);
                  return [2, embeddedPages];
              }
            });
          });
        };
        PDFDocument3.prototype.flush = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.embedAll(this.fonts)];
                case 1:
                  _a.sent();
                  return [4, this.embedAll(this.images)];
                case 2:
                  _a.sent();
                  return [4, this.embedAll(this.embeddedPages)];
                case 3:
                  _a.sent();
                  return [4, this.embedAll(this.embeddedFiles)];
                case 4:
                  _a.sent();
                  return [4, this.embedAll(this.javaScripts)];
                case 5:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFDocument3.prototype.save = function(options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, useObjectStreams, _b, addDefaultPage, _c, objectsPerTick, _d, updateFieldAppearances, form, Writer;
            return tslib_1.__generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  _a = options.useObjectStreams, useObjectStreams = _a === void 0 ? true : _a, _b = options.addDefaultPage, addDefaultPage = _b === void 0 ? true : _b, _c = options.objectsPerTick, objectsPerTick = _c === void 0 ? 50 : _c, _d = options.updateFieldAppearances, updateFieldAppearances = _d === void 0 ? true : _d;
                  utils_1.assertIs(useObjectStreams, "useObjectStreams", ["boolean"]);
                  utils_1.assertIs(addDefaultPage, "addDefaultPage", ["boolean"]);
                  utils_1.assertIs(objectsPerTick, "objectsPerTick", ["number"]);
                  utils_1.assertIs(updateFieldAppearances, "updateFieldAppearances", ["boolean"]);
                  if (addDefaultPage && this.getPageCount() === 0)
                    this.addPage();
                  if (updateFieldAppearances) {
                    form = this.formCache.getValue();
                    if (form)
                      form.updateFieldAppearances();
                  }
                  return [4, this.flush()];
                case 1:
                  _e.sent();
                  Writer = useObjectStreams ? core_1.PDFStreamWriter : core_1.PDFWriter;
                  return [2, Writer.forContext(this.context, objectsPerTick).serializeToBuffer()];
              }
            });
          });
        };
        PDFDocument3.prototype.saveAsBase64 = function(options) {
          if (options === void 0) {
            options = {};
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, dataUri, otherOptions, bytes, base64;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a = options.dataUri, dataUri = _a === void 0 ? false : _a, otherOptions = tslib_1.__rest(options, ["dataUri"]);
                  utils_1.assertIs(dataUri, "dataUri", ["boolean"]);
                  return [4, this.save(otherOptions)];
                case 1:
                  bytes = _b.sent();
                  base64 = utils_1.encodeToBase64(bytes);
                  return [2, dataUri ? "data:application/pdf;base64," + base64 : base64];
              }
            });
          });
        };
        PDFDocument3.prototype.findPageForAnnotationRef = function(ref) {
          var pages = this.getPages();
          for (var idx = 0, len = pages.length; idx < len; idx++) {
            var page = pages[idx];
            var annotations = page.node.Annots();
            if ((annotations === null || annotations === void 0 ? void 0 : annotations.indexOf(ref)) !== void 0) {
              return page;
            }
          }
          return void 0;
        };
        PDFDocument3.prototype.embedAll = function(embeddables) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var idx, len;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  idx = 0, len = embeddables.length;
                  _a.label = 1;
                case 1:
                  if (!(idx < len))
                    return [3, 4];
                  return [4, embeddables[idx].embed()];
                case 2:
                  _a.sent();
                  _a.label = 3;
                case 3:
                  idx++;
                  return [3, 1];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        PDFDocument3.prototype.updateInfoDict = function() {
          var pdfLib = "pdf-lib (https://github.com/Hopding/pdf-lib)";
          var now2 = /* @__PURE__ */ new Date();
          var info = this.getInfoDict();
          this.setProducer(pdfLib);
          this.setModificationDate(now2);
          if (!info.get(core_1.PDFName.of("Creator")))
            this.setCreator(pdfLib);
          if (!info.get(core_1.PDFName.of("CreationDate")))
            this.setCreationDate(now2);
        };
        PDFDocument3.prototype.getInfoDict = function() {
          var existingInfo = this.context.lookup(this.context.trailerInfo.Info);
          if (existingInfo instanceof core_1.PDFDict)
            return existingInfo;
          var newInfo = this.context.obj({});
          this.context.trailerInfo.Info = this.context.register(newInfo);
          return newInfo;
        };
        PDFDocument3.prototype.assertFontkit = function() {
          if (!this.fontkit)
            throw new errors_1.FontkitNotRegisteredError();
          return this.fontkit;
        };
        return PDFDocument3;
      }()
    );
    exports.default = PDFDocument2;
    function assertIsLiteralOrHexString(pdfObject) {
      if (!(pdfObject instanceof core_1.PDFHexString) && !(pdfObject instanceof core_1.PDFString)) {
        throw new core_1.UnexpectedObjectTypeError([core_1.PDFHexString, core_1.PDFString], pdfObject);
      }
    }
  }
});

// ../../../node_modules/pdf-lib/cjs/api/PDFPageOptions.js
var require_PDFPageOptions = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/PDFPageOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlendMode = void 0;
    var BlendMode;
    (function(BlendMode2) {
      BlendMode2["Normal"] = "Normal";
      BlendMode2["Multiply"] = "Multiply";
      BlendMode2["Screen"] = "Screen";
      BlendMode2["Overlay"] = "Overlay";
      BlendMode2["Darken"] = "Darken";
      BlendMode2["Lighten"] = "Lighten";
      BlendMode2["ColorDodge"] = "ColorDodge";
      BlendMode2["ColorBurn"] = "ColorBurn";
      BlendMode2["HardLight"] = "HardLight";
      BlendMode2["SoftLight"] = "SoftLight";
      BlendMode2["Difference"] = "Difference";
      BlendMode2["Exclusion"] = "Exclusion";
    })(BlendMode = exports.BlendMode || (exports.BlendMode = {}));
  }
});

// ../../../node_modules/pdf-lib/cjs/api/PDFPage.js
var require_PDFPage = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/PDFPage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var colors_1 = require_colors();
    var operations_1 = require_operations();
    var operators_1 = require_operators();
    var PDFDocument_1 = tslib_1.__importDefault(require_PDFDocument());
    var PDFEmbeddedPage_1 = tslib_1.__importDefault(require_PDFEmbeddedPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var PDFImage_1 = tslib_1.__importDefault(require_PDFImage());
    var PDFPageOptions_1 = require_PDFPageOptions();
    var rotations_1 = require_rotations();
    var StandardFonts_1 = require_StandardFonts();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFPage = (
      /** @class */
      function() {
        function PDFPage2(leafNode, ref, doc) {
          this.fontSize = 24;
          this.fontColor = colors_1.rgb(0, 0, 0);
          this.lineHeight = 24;
          this.x = 0;
          this.y = 0;
          utils_1.assertIs(leafNode, "leafNode", [[core_1.PDFPageLeaf, "PDFPageLeaf"]]);
          utils_1.assertIs(ref, "ref", [[core_1.PDFRef, "PDFRef"]]);
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          this.node = leafNode;
          this.ref = ref;
          this.doc = doc;
        }
        PDFPage2.prototype.setRotation = function(angle) {
          var degreesAngle = rotations_1.toDegrees(angle);
          utils_1.assertMultiple(degreesAngle, "degreesAngle", 90);
          this.node.set(core_1.PDFName.of("Rotate"), this.doc.context.obj(degreesAngle));
        };
        PDFPage2.prototype.getRotation = function() {
          var Rotate = this.node.Rotate();
          return rotations_1.degrees(Rotate ? Rotate.asNumber() : 0);
        };
        PDFPage2.prototype.setSize = function(width, height) {
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var mediaBox = this.getMediaBox();
          this.setMediaBox(mediaBox.x, mediaBox.y, width, height);
          var cropBox = this.getCropBox();
          var bleedBox = this.getBleedBox();
          var trimBox = this.getTrimBox();
          var artBox = this.getArtBox();
          var hasCropBox = this.node.CropBox();
          var hasBleedBox = this.node.BleedBox();
          var hasTrimBox = this.node.TrimBox();
          var hasArtBox = this.node.ArtBox();
          if (hasCropBox && utils_1.rectanglesAreEqual(cropBox, mediaBox)) {
            this.setCropBox(mediaBox.x, mediaBox.y, width, height);
          }
          if (hasBleedBox && utils_1.rectanglesAreEqual(bleedBox, mediaBox)) {
            this.setBleedBox(mediaBox.x, mediaBox.y, width, height);
          }
          if (hasTrimBox && utils_1.rectanglesAreEqual(trimBox, mediaBox)) {
            this.setTrimBox(mediaBox.x, mediaBox.y, width, height);
          }
          if (hasArtBox && utils_1.rectanglesAreEqual(artBox, mediaBox)) {
            this.setArtBox(mediaBox.x, mediaBox.y, width, height);
          }
        };
        PDFPage2.prototype.setWidth = function(width) {
          utils_1.assertIs(width, "width", ["number"]);
          this.setSize(width, this.getSize().height);
        };
        PDFPage2.prototype.setHeight = function(height) {
          utils_1.assertIs(height, "height", ["number"]);
          this.setSize(this.getSize().width, height);
        };
        PDFPage2.prototype.setMediaBox = function(x, y, width, height) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var mediaBox = this.doc.context.obj([x, y, x + width, y + height]);
          this.node.set(core_1.PDFName.MediaBox, mediaBox);
        };
        PDFPage2.prototype.setCropBox = function(x, y, width, height) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var cropBox = this.doc.context.obj([x, y, x + width, y + height]);
          this.node.set(core_1.PDFName.CropBox, cropBox);
        };
        PDFPage2.prototype.setBleedBox = function(x, y, width, height) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var bleedBox = this.doc.context.obj([x, y, x + width, y + height]);
          this.node.set(core_1.PDFName.BleedBox, bleedBox);
        };
        PDFPage2.prototype.setTrimBox = function(x, y, width, height) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var trimBox = this.doc.context.obj([x, y, x + width, y + height]);
          this.node.set(core_1.PDFName.TrimBox, trimBox);
        };
        PDFPage2.prototype.setArtBox = function(x, y, width, height) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          utils_1.assertIs(width, "width", ["number"]);
          utils_1.assertIs(height, "height", ["number"]);
          var artBox = this.doc.context.obj([x, y, x + width, y + height]);
          this.node.set(core_1.PDFName.ArtBox, artBox);
        };
        PDFPage2.prototype.getSize = function() {
          var _a = this.getMediaBox(), width = _a.width, height = _a.height;
          return { width, height };
        };
        PDFPage2.prototype.getWidth = function() {
          return this.getSize().width;
        };
        PDFPage2.prototype.getHeight = function() {
          return this.getSize().height;
        };
        PDFPage2.prototype.getMediaBox = function() {
          var mediaBox = this.node.MediaBox();
          return mediaBox.asRectangle();
        };
        PDFPage2.prototype.getCropBox = function() {
          var _a;
          var cropBox = this.node.CropBox();
          return (_a = cropBox === null || cropBox === void 0 ? void 0 : cropBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getMediaBox();
        };
        PDFPage2.prototype.getBleedBox = function() {
          var _a;
          var bleedBox = this.node.BleedBox();
          return (_a = bleedBox === null || bleedBox === void 0 ? void 0 : bleedBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
        };
        PDFPage2.prototype.getTrimBox = function() {
          var _a;
          var trimBox = this.node.TrimBox();
          return (_a = trimBox === null || trimBox === void 0 ? void 0 : trimBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
        };
        PDFPage2.prototype.getArtBox = function() {
          var _a;
          var artBox = this.node.ArtBox();
          return (_a = artBox === null || artBox === void 0 ? void 0 : artBox.asRectangle()) !== null && _a !== void 0 ? _a : this.getCropBox();
        };
        PDFPage2.prototype.translateContent = function(x, y) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          this.node.normalize();
          this.getContentStream();
          var start = this.createContentStream(operators_1.pushGraphicsState(), operators_1.translate(x, y));
          var startRef = this.doc.context.register(start);
          var end = this.createContentStream(operators_1.popGraphicsState());
          var endRef = this.doc.context.register(end);
          this.node.wrapContentStreams(startRef, endRef);
        };
        PDFPage2.prototype.scale = function(x, y) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          this.setSize(this.getWidth() * x, this.getHeight() * y);
          this.scaleContent(x, y);
          this.scaleAnnotations(x, y);
        };
        PDFPage2.prototype.scaleContent = function(x, y) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          this.node.normalize();
          this.getContentStream();
          var start = this.createContentStream(operators_1.pushGraphicsState(), operators_1.scale(x, y));
          var startRef = this.doc.context.register(start);
          var end = this.createContentStream(operators_1.popGraphicsState());
          var endRef = this.doc.context.register(end);
          this.node.wrapContentStreams(startRef, endRef);
        };
        PDFPage2.prototype.scaleAnnotations = function(x, y) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          var annots = this.node.Annots();
          if (!annots)
            return;
          for (var idx = 0; idx < annots.size(); idx++) {
            var annot = annots.lookup(idx);
            if (annot instanceof core_1.PDFDict)
              this.scaleAnnot(annot, x, y);
          }
        };
        PDFPage2.prototype.resetPosition = function() {
          this.getContentStream(false);
          this.x = 0;
          this.y = 0;
        };
        PDFPage2.prototype.setFont = function(font) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          this.font = font;
          this.fontKey = this.node.newFontDictionary(this.font.name, this.font.ref);
        };
        PDFPage2.prototype.setFontSize = function(fontSize) {
          utils_1.assertIs(fontSize, "fontSize", ["number"]);
          this.fontSize = fontSize;
        };
        PDFPage2.prototype.setFontColor = function(fontColor) {
          utils_1.assertIs(fontColor, "fontColor", [[Object, "Color"]]);
          this.fontColor = fontColor;
        };
        PDFPage2.prototype.setLineHeight = function(lineHeight) {
          utils_1.assertIs(lineHeight, "lineHeight", ["number"]);
          this.lineHeight = lineHeight;
        };
        PDFPage2.prototype.getPosition = function() {
          return { x: this.x, y: this.y };
        };
        PDFPage2.prototype.getX = function() {
          return this.x;
        };
        PDFPage2.prototype.getY = function() {
          return this.y;
        };
        PDFPage2.prototype.moveTo = function(x, y) {
          utils_1.assertIs(x, "x", ["number"]);
          utils_1.assertIs(y, "y", ["number"]);
          this.x = x;
          this.y = y;
        };
        PDFPage2.prototype.moveDown = function(yDecrease) {
          utils_1.assertIs(yDecrease, "yDecrease", ["number"]);
          this.y -= yDecrease;
        };
        PDFPage2.prototype.moveUp = function(yIncrease) {
          utils_1.assertIs(yIncrease, "yIncrease", ["number"]);
          this.y += yIncrease;
        };
        PDFPage2.prototype.moveLeft = function(xDecrease) {
          utils_1.assertIs(xDecrease, "xDecrease", ["number"]);
          this.x -= xDecrease;
        };
        PDFPage2.prototype.moveRight = function(xIncrease) {
          utils_1.assertIs(xIncrease, "xIncrease", ["number"]);
          this.x += xIncrease;
        };
        PDFPage2.prototype.pushOperators = function() {
          var operator = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            operator[_i] = arguments[_i];
          }
          utils_1.assertEachIs(operator, "operator", [[core_1.PDFOperator, "PDFOperator"]]);
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operator);
        };
        PDFPage2.prototype.drawText = function(text, options) {
          var _a, _b, _c, _d, _e, _f, _g;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertIs(text, "text", ["string"]);
          utils_1.assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertOrUndefined(options.font, "options.font", [[PDFFont_1.default, "PDFFont"]]);
          utils_1.assertOrUndefined(options.size, "options.size", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.lineHeight, "options.lineHeight", ["number"]);
          utils_1.assertOrUndefined(options.maxWidth, "options.maxWidth", ["number"]);
          utils_1.assertOrUndefined(options.wordBreaks, "options.wordBreaks", [Array]);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var _h = this.setOrEmbedFont(options.font), oldFont = _h.oldFont, newFont = _h.newFont, newFontKey = _h.newFontKey;
          var fontSize = options.size || this.fontSize;
          var wordBreaks = options.wordBreaks || this.doc.defaultWordBreaks;
          var textWidth = function(t2) {
            return newFont.widthOfTextAtSize(t2, fontSize);
          };
          var lines = options.maxWidth === void 0 ? utils_1.lineSplit(utils_1.cleanText(text)) : utils_1.breakTextIntoLines(text, wordBreaks, options.maxWidth, textWidth);
          var encodedLines = new Array(lines.length);
          for (var idx = 0, len = lines.length; idx < len; idx++) {
            encodedLines[idx] = newFont.encodeText(lines[idx]);
          }
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            blendMode: options.blendMode
          });
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawLinesOfText(encodedLines, {
            color: (_a = options.color) !== null && _a !== void 0 ? _a : this.fontColor,
            font: newFontKey,
            size: fontSize,
            rotate: (_b = options.rotate) !== null && _b !== void 0 ? _b : rotations_1.degrees(0),
            xSkew: (_c = options.xSkew) !== null && _c !== void 0 ? _c : rotations_1.degrees(0),
            ySkew: (_d = options.ySkew) !== null && _d !== void 0 ? _d : rotations_1.degrees(0),
            x: (_e = options.x) !== null && _e !== void 0 ? _e : this.x,
            y: (_f = options.y) !== null && _f !== void 0 ? _f : this.y,
            lineHeight: (_g = options.lineHeight) !== null && _g !== void 0 ? _g : this.lineHeight,
            graphicsState: graphicsStateKey
          }));
          if (options.font) {
            if (oldFont)
              this.setFont(oldFont);
            else
              this.resetFont();
          }
        };
        PDFPage2.prototype.drawImage = function(image, options) {
          var _a, _b, _c, _d, _e, _f, _g;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertIs(image, "image", [[PDFImage_1.default, "PDFImage"]]);
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.width, "options.width", ["number"]);
          utils_1.assertOrUndefined(options.height, "options.height", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var xObjectKey = this.node.newXObject("Image", image.ref);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            blendMode: options.blendMode
          });
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawImage(xObjectKey, {
            x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : image.size().width,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : image.size().height,
            rotate: (_e = options.rotate) !== null && _e !== void 0 ? _e : rotations_1.degrees(0),
            xSkew: (_f = options.xSkew) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            ySkew: (_g = options.ySkew) !== null && _g !== void 0 ? _g : rotations_1.degrees(0),
            graphicsState: graphicsStateKey
          }));
        };
        PDFPage2.prototype.drawPage = function(embeddedPage, options) {
          var _a, _b, _c, _d, _e;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertIs(embeddedPage, "embeddedPage", [
            [PDFEmbeddedPage_1.default, "PDFEmbeddedPage"]
          ]);
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.xScale, "options.xScale", ["number"]);
          utils_1.assertOrUndefined(options.yScale, "options.yScale", ["number"]);
          utils_1.assertOrUndefined(options.width, "options.width", ["number"]);
          utils_1.assertOrUndefined(options.height, "options.height", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var xObjectKey = this.node.newXObject("EmbeddedPdfPage", embeddedPage.ref);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            blendMode: options.blendMode
          });
          var xScale = options.width !== void 0 ? options.width / embeddedPage.width : options.xScale !== void 0 ? options.xScale : 1;
          var yScale = options.height !== void 0 ? options.height / embeddedPage.height : options.yScale !== void 0 ? options.yScale : 1;
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawPage(xObjectKey, {
            x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
            xScale,
            yScale,
            rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : rotations_1.degrees(0),
            xSkew: (_d = options.xSkew) !== null && _d !== void 0 ? _d : rotations_1.degrees(0),
            ySkew: (_e = options.ySkew) !== null && _e !== void 0 ? _e : rotations_1.degrees(0),
            graphicsState: graphicsStateKey
          }));
        };
        PDFPage2.prototype.drawSvgPath = function(path2, options) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertIs(path2, "path", ["string"]);
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.scale, "options.scale", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
          utils_1.assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertOrUndefined(options.borderColor, "options.borderColor", [
            [Object, "Color"]
          ]);
          utils_1.assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
            Array
          ]);
          utils_1.assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
            "number"
          ]);
          utils_1.assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", operators_1.LineCapStyle);
          utils_1.assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            borderOpacity: options.borderOpacity,
            blendMode: options.blendMode
          });
          if (!("color" in options) && !("borderColor" in options)) {
            options.borderColor = colors_1.rgb(0, 0, 0);
          }
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawSvgPath(path2, {
            x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
            scale: options.scale,
            rotate: (_c = options.rotate) !== null && _c !== void 0 ? _c : rotations_1.degrees(0),
            color: (_d = options.color) !== null && _d !== void 0 ? _d : void 0,
            borderColor: (_e = options.borderColor) !== null && _e !== void 0 ? _e : void 0,
            borderWidth: (_f = options.borderWidth) !== null && _f !== void 0 ? _f : 0,
            borderDashArray: (_g = options.borderDashArray) !== null && _g !== void 0 ? _g : void 0,
            borderDashPhase: (_h = options.borderDashPhase) !== null && _h !== void 0 ? _h : void 0,
            borderLineCap: (_j = options.borderLineCap) !== null && _j !== void 0 ? _j : void 0,
            graphicsState: graphicsStateKey
          }));
        };
        PDFPage2.prototype.drawLine = function(options) {
          var _a, _b, _c, _d, _e;
          utils_1.assertIs(options.start, "options.start", [
            [Object, "{ x: number, y: number }"]
          ]);
          utils_1.assertIs(options.end, "options.end", [
            [Object, "{ x: number, y: number }"]
          ]);
          utils_1.assertIs(options.start.x, "options.start.x", ["number"]);
          utils_1.assertIs(options.start.y, "options.start.y", ["number"]);
          utils_1.assertIs(options.end.x, "options.end.x", ["number"]);
          utils_1.assertIs(options.end.y, "options.end.y", ["number"]);
          utils_1.assertOrUndefined(options.thickness, "options.thickness", ["number"]);
          utils_1.assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
          utils_1.assertOrUndefined(options.dashArray, "options.dashArray", [Array]);
          utils_1.assertOrUndefined(options.dashPhase, "options.dashPhase", ["number"]);
          utils_1.assertIsOneOfOrUndefined(options.lineCap, "options.lineCap", operators_1.LineCapStyle);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            borderOpacity: options.opacity,
            blendMode: options.blendMode
          });
          if (!("color" in options)) {
            options.color = colors_1.rgb(0, 0, 0);
          }
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawLine({
            start: options.start,
            end: options.end,
            thickness: (_a = options.thickness) !== null && _a !== void 0 ? _a : 1,
            color: (_b = options.color) !== null && _b !== void 0 ? _b : void 0,
            dashArray: (_c = options.dashArray) !== null && _c !== void 0 ? _c : void 0,
            dashPhase: (_d = options.dashPhase) !== null && _d !== void 0 ? _d : void 0,
            lineCap: (_e = options.lineCap) !== null && _e !== void 0 ? _e : void 0,
            graphicsState: graphicsStateKey
          }));
        };
        PDFPage2.prototype.drawRectangle = function(options) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.width, "options.width", ["number"]);
          utils_1.assertOrUndefined(options.height, "options.height", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.xSkew, "options.xSkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.ySkew, "options.ySkew", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
          utils_1.assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertOrUndefined(options.borderColor, "options.borderColor", [
            [Object, "Color"]
          ]);
          utils_1.assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
            Array
          ]);
          utils_1.assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
            "number"
          ]);
          utils_1.assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", operators_1.LineCapStyle);
          utils_1.assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            borderOpacity: options.borderOpacity,
            blendMode: options.blendMode
          });
          if (!("color" in options) && !("borderColor" in options)) {
            options.color = colors_1.rgb(0, 0, 0);
          }
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawRectangle({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
            width: (_c = options.width) !== null && _c !== void 0 ? _c : 150,
            height: (_d = options.height) !== null && _d !== void 0 ? _d : 100,
            rotate: (_e = options.rotate) !== null && _e !== void 0 ? _e : rotations_1.degrees(0),
            xSkew: (_f = options.xSkew) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),
            ySkew: (_g = options.ySkew) !== null && _g !== void 0 ? _g : rotations_1.degrees(0),
            borderWidth: (_h = options.borderWidth) !== null && _h !== void 0 ? _h : 0,
            color: (_j = options.color) !== null && _j !== void 0 ? _j : void 0,
            borderColor: (_k = options.borderColor) !== null && _k !== void 0 ? _k : void 0,
            borderDashArray: (_l = options.borderDashArray) !== null && _l !== void 0 ? _l : void 0,
            borderDashPhase: (_m = options.borderDashPhase) !== null && _m !== void 0 ? _m : void 0,
            graphicsState: graphicsStateKey,
            borderLineCap: (_o = options.borderLineCap) !== null && _o !== void 0 ? _o : void 0
          }));
        };
        PDFPage2.prototype.drawSquare = function(options) {
          if (options === void 0) {
            options = {};
          }
          var size = options.size;
          utils_1.assertOrUndefined(size, "size", ["number"]);
          this.drawRectangle(tslib_1.__assign(tslib_1.__assign({}, options), { width: size, height: size }));
        };
        PDFPage2.prototype.drawEllipse = function(options) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
          if (options === void 0) {
            options = {};
          }
          utils_1.assertOrUndefined(options.x, "options.x", ["number"]);
          utils_1.assertOrUndefined(options.y, "options.y", ["number"]);
          utils_1.assertOrUndefined(options.xScale, "options.xScale", ["number"]);
          utils_1.assertOrUndefined(options.yScale, "options.yScale", ["number"]);
          utils_1.assertOrUndefined(options.rotate, "options.rotate", [[Object, "Rotation"]]);
          utils_1.assertOrUndefined(options.color, "options.color", [[Object, "Color"]]);
          utils_1.assertRangeOrUndefined(options.opacity, "opacity.opacity", 0, 1);
          utils_1.assertOrUndefined(options.borderColor, "options.borderColor", [
            [Object, "Color"]
          ]);
          utils_1.assertRangeOrUndefined(options.borderOpacity, "options.borderOpacity", 0, 1);
          utils_1.assertOrUndefined(options.borderWidth, "options.borderWidth", ["number"]);
          utils_1.assertOrUndefined(options.borderDashArray, "options.borderDashArray", [
            Array
          ]);
          utils_1.assertOrUndefined(options.borderDashPhase, "options.borderDashPhase", [
            "number"
          ]);
          utils_1.assertIsOneOfOrUndefined(options.borderLineCap, "options.borderLineCap", operators_1.LineCapStyle);
          utils_1.assertIsOneOfOrUndefined(options.blendMode, "options.blendMode", PDFPageOptions_1.BlendMode);
          var graphicsStateKey = this.maybeEmbedGraphicsState({
            opacity: options.opacity,
            borderOpacity: options.borderOpacity,
            blendMode: options.blendMode
          });
          if (!("color" in options) && !("borderColor" in options)) {
            options.color = colors_1.rgb(0, 0, 0);
          }
          var contentStream = this.getContentStream();
          contentStream.push.apply(contentStream, operations_1.drawEllipse({
            x: (_a = options.x) !== null && _a !== void 0 ? _a : this.x,
            y: (_b = options.y) !== null && _b !== void 0 ? _b : this.y,
            xScale: (_c = options.xScale) !== null && _c !== void 0 ? _c : 100,
            yScale: (_d = options.yScale) !== null && _d !== void 0 ? _d : 100,
            rotate: (_e = options.rotate) !== null && _e !== void 0 ? _e : void 0,
            color: (_f = options.color) !== null && _f !== void 0 ? _f : void 0,
            borderColor: (_g = options.borderColor) !== null && _g !== void 0 ? _g : void 0,
            borderWidth: (_h = options.borderWidth) !== null && _h !== void 0 ? _h : 0,
            borderDashArray: (_j = options.borderDashArray) !== null && _j !== void 0 ? _j : void 0,
            borderDashPhase: (_k = options.borderDashPhase) !== null && _k !== void 0 ? _k : void 0,
            borderLineCap: (_l = options.borderLineCap) !== null && _l !== void 0 ? _l : void 0,
            graphicsState: graphicsStateKey
          }));
        };
        PDFPage2.prototype.drawCircle = function(options) {
          if (options === void 0) {
            options = {};
          }
          var _a = options.size, size = _a === void 0 ? 100 : _a;
          utils_1.assertOrUndefined(size, "size", ["number"]);
          this.drawEllipse(tslib_1.__assign(tslib_1.__assign({}, options), { xScale: size, yScale: size }));
        };
        PDFPage2.prototype.setOrEmbedFont = function(font) {
          var oldFont = this.font;
          var oldFontKey = this.fontKey;
          if (font)
            this.setFont(font);
          else
            this.getFont();
          var newFont = this.font;
          var newFontKey = this.fontKey;
          return { oldFont, oldFontKey, newFont, newFontKey };
        };
        PDFPage2.prototype.getFont = function() {
          if (!this.font || !this.fontKey) {
            var font = this.doc.embedStandardFont(StandardFonts_1.StandardFonts.Helvetica);
            this.setFont(font);
          }
          return [this.font, this.fontKey];
        };
        PDFPage2.prototype.resetFont = function() {
          this.font = void 0;
          this.fontKey = void 0;
        };
        PDFPage2.prototype.getContentStream = function(useExisting) {
          if (useExisting === void 0) {
            useExisting = true;
          }
          if (useExisting && this.contentStream)
            return this.contentStream;
          this.contentStream = this.createContentStream();
          this.contentStreamRef = this.doc.context.register(this.contentStream);
          this.node.addContentStream(this.contentStreamRef);
          return this.contentStream;
        };
        PDFPage2.prototype.createContentStream = function() {
          var operators = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            operators[_i] = arguments[_i];
          }
          var dict = this.doc.context.obj({});
          var contentStream = core_1.PDFContentStream.of(dict, operators);
          return contentStream;
        };
        PDFPage2.prototype.maybeEmbedGraphicsState = function(options) {
          var opacity = options.opacity, borderOpacity = options.borderOpacity, blendMode = options.blendMode;
          if (opacity === void 0 && borderOpacity === void 0 && blendMode === void 0) {
            return void 0;
          }
          var graphicsState = this.doc.context.obj({
            Type: "ExtGState",
            ca: opacity,
            CA: borderOpacity,
            BM: blendMode
          });
          var key = this.node.newExtGState("GS", graphicsState);
          return key;
        };
        PDFPage2.prototype.scaleAnnot = function(annot, x, y) {
          var selectors = ["RD", "CL", "Vertices", "QuadPoints", "L", "Rect"];
          for (var idx = 0, len = selectors.length; idx < len; idx++) {
            var list = annot.lookup(core_1.PDFName.of(selectors[idx]));
            if (list instanceof core_1.PDFArray)
              list.scalePDFNumbers(x, y);
          }
          var inkLists = annot.lookup(core_1.PDFName.of("InkList"));
          if (inkLists instanceof core_1.PDFArray) {
            for (var idx = 0, len = inkLists.size(); idx < len; idx++) {
              var arr2 = inkLists.lookup(idx);
              if (arr2 instanceof core_1.PDFArray)
                arr2.scalePDFNumbers(x, y);
            }
          }
        };
        PDFPage2.of = function(leafNode, ref, doc) {
          return new PDFPage2(leafNode, ref, doc);
        };
        PDFPage2.create = function(doc) {
          utils_1.assertIs(doc, "doc", [[PDFDocument_1.default, "PDFDocument"]]);
          var dummyRef = core_1.PDFRef.of(-1);
          var pageLeaf = core_1.PDFPageLeaf.withContextAndParent(doc.context, dummyRef);
          var pageRef = doc.context.register(pageLeaf);
          return new PDFPage2(pageLeaf, pageRef, doc);
        };
        return PDFPage2;
      }()
    );
    exports.default = PDFPage;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/form/PDFButton.js
var require_PDFButton = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/form/PDFButton.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PDFPage_1 = tslib_1.__importDefault(require_PDFPage());
    var PDFFont_1 = tslib_1.__importDefault(require_PDFFont());
    var alignment_1 = require_alignment2();
    var appearances_1 = require_appearances();
    var PDFField_1 = tslib_1.__importStar(require_PDFField());
    var colors_1 = require_colors();
    var rotations_1 = require_rotations();
    var core_1 = require_core();
    var utils_1 = require_utils2();
    var PDFButton = (
      /** @class */
      function(_super) {
        tslib_1.__extends(PDFButton2, _super);
        function PDFButton2(acroPushButton, ref, doc) {
          var _this = _super.call(this, acroPushButton, ref, doc) || this;
          utils_1.assertIs(acroPushButton, "acroButton", [
            [core_1.PDFAcroPushButton, "PDFAcroPushButton"]
          ]);
          _this.acroField = acroPushButton;
          return _this;
        }
        PDFButton2.prototype.setImage = function(image, alignment) {
          if (alignment === void 0) {
            alignment = alignment_1.ImageAlignment.Center;
          }
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var streamRef = this.createImageAppearanceStream(widget, image, alignment);
            this.updateWidgetAppearances(widget, { normal: streamRef });
          }
          this.markAsClean();
        };
        PDFButton2.prototype.setFontSize = function(fontSize) {
          utils_1.assertPositive(fontSize, "fontSize");
          this.acroField.setFontSize(fontSize);
          this.markAsDirty();
        };
        PDFButton2.prototype.addToPage = function(text, page, options) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
          utils_1.assertOrUndefined(text, "text", ["string"]);
          utils_1.assertOrUndefined(page, "page", [[PDFPage_1.default, "PDFPage"]]);
          PDFField_1.assertFieldAppearanceOptions(options);
          var widget = this.createWidget({
            x: ((_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0) - ((_b = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _b !== void 0 ? _b : 0) / 2,
            y: ((_c = options === null || options === void 0 ? void 0 : options.y) !== null && _c !== void 0 ? _c : 0) - ((_d = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _d !== void 0 ? _d : 0) / 2,
            width: (_e = options === null || options === void 0 ? void 0 : options.width) !== null && _e !== void 0 ? _e : 100,
            height: (_f = options === null || options === void 0 ? void 0 : options.height) !== null && _f !== void 0 ? _f : 50,
            textColor: (_g = options === null || options === void 0 ? void 0 : options.textColor) !== null && _g !== void 0 ? _g : colors_1.rgb(0, 0, 0),
            backgroundColor: (_h = options === null || options === void 0 ? void 0 : options.backgroundColor) !== null && _h !== void 0 ? _h : colors_1.rgb(0.75, 0.75, 0.75),
            borderColor: options === null || options === void 0 ? void 0 : options.borderColor,
            borderWidth: (_j = options === null || options === void 0 ? void 0 : options.borderWidth) !== null && _j !== void 0 ? _j : 0,
            rotate: (_k = options === null || options === void 0 ? void 0 : options.rotate) !== null && _k !== void 0 ? _k : rotations_1.degrees(0),
            caption: text,
            hidden: options === null || options === void 0 ? void 0 : options.hidden,
            page: page.ref
          });
          var widgetRef = this.doc.context.register(widget.dict);
          this.acroField.addWidget(widgetRef);
          var font = (_l = options === null || options === void 0 ? void 0 : options.font) !== null && _l !== void 0 ? _l : this.doc.getForm().getDefaultFont();
          this.updateWidgetAppearance(widget, font);
          page.node.addAnnot(widgetRef);
        };
        PDFButton2.prototype.needsAppearancesUpdate = function() {
          var _a;
          if (this.isDirty())
            return true;
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof core_1.PDFStream;
            if (!hasAppearances)
              return true;
          }
          return false;
        };
        PDFButton2.prototype.defaultUpdateAppearances = function(font) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          this.updateAppearances(font);
        };
        PDFButton2.prototype.updateAppearances = function(font, provider) {
          utils_1.assertIs(font, "font", [[PDFFont_1.default, "PDFFont"]]);
          utils_1.assertOrUndefined(provider, "provider", [Function]);
          var widgets = this.acroField.getWidgets();
          for (var idx = 0, len = widgets.length; idx < len; idx++) {
            var widget = widgets[idx];
            this.updateWidgetAppearance(widget, font, provider);
          }
        };
        PDFButton2.prototype.updateWidgetAppearance = function(widget, font, provider) {
          var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultButtonAppearanceProvider;
          var appearances = appearances_1.normalizeAppearance(apProvider(this, widget, font));
          this.updateWidgetAppearanceWithFont(widget, font, appearances);
        };
        PDFButton2.of = function(acroPushButton, ref, doc) {
          return new PDFButton2(acroPushButton, ref, doc);
        };
        return PDFButton2;
      }(PDFField_1.default)
    );
    exports.default = PDFButton;
  }
});

// ../../../node_modules/pdf-lib/cjs/api/form/index.js
var require_form = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/form/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_appearances(), exports);
    var PDFButton_1 = require_PDFButton();
    Object.defineProperty(exports, "PDFButton", { enumerable: true, get: function() {
      return PDFButton_1.default;
    } });
    var PDFCheckBox_1 = require_PDFCheckBox();
    Object.defineProperty(exports, "PDFCheckBox", { enumerable: true, get: function() {
      return PDFCheckBox_1.default;
    } });
    var PDFDropdown_1 = require_PDFDropdown();
    Object.defineProperty(exports, "PDFDropdown", { enumerable: true, get: function() {
      return PDFDropdown_1.default;
    } });
    var PDFField_1 = require_PDFField();
    Object.defineProperty(exports, "PDFField", { enumerable: true, get: function() {
      return PDFField_1.default;
    } });
    var PDFForm_1 = require_PDFForm();
    Object.defineProperty(exports, "PDFForm", { enumerable: true, get: function() {
      return PDFForm_1.default;
    } });
    var PDFOptionList_1 = require_PDFOptionList();
    Object.defineProperty(exports, "PDFOptionList", { enumerable: true, get: function() {
      return PDFOptionList_1.default;
    } });
    var PDFRadioGroup_1 = require_PDFRadioGroup();
    Object.defineProperty(exports, "PDFRadioGroup", { enumerable: true, get: function() {
      return PDFRadioGroup_1.default;
    } });
    var PDFSignature_1 = require_PDFSignature();
    Object.defineProperty(exports, "PDFSignature", { enumerable: true, get: function() {
      return PDFSignature_1.default;
    } });
    var PDFTextField_1 = require_PDFTextField();
    Object.defineProperty(exports, "PDFTextField", { enumerable: true, get: function() {
      return PDFTextField_1.default;
    } });
  }
});

// ../../../node_modules/pdf-lib/cjs/api/text/index.js
var require_text = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/text/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_alignment(), exports);
    tslib_1.__exportStar(require_layout(), exports);
  }
});

// ../../../node_modules/pdf-lib/cjs/api/index.js
var require_api = __commonJS({
  "../../../node_modules/pdf-lib/cjs/api/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_form(), exports);
    tslib_1.__exportStar(require_text(), exports);
    tslib_1.__exportStar(require_colors(), exports);
    tslib_1.__exportStar(require_errors3(), exports);
    tslib_1.__exportStar(require_image(), exports);
    tslib_1.__exportStar(require_objects2(), exports);
    tslib_1.__exportStar(require_operations(), exports);
    tslib_1.__exportStar(require_operators(), exports);
    tslib_1.__exportStar(require_rotations(), exports);
    tslib_1.__exportStar(require_sizes(), exports);
    tslib_1.__exportStar(require_PDFPageOptions(), exports);
    tslib_1.__exportStar(require_PDFDocumentOptions(), exports);
    tslib_1.__exportStar(require_StandardFonts(), exports);
    var PDFDocument_1 = require_PDFDocument();
    Object.defineProperty(exports, "PDFDocument", { enumerable: true, get: function() {
      return PDFDocument_1.default;
    } });
    var PDFFont_1 = require_PDFFont();
    Object.defineProperty(exports, "PDFFont", { enumerable: true, get: function() {
      return PDFFont_1.default;
    } });
    var PDFImage_1 = require_PDFImage();
    Object.defineProperty(exports, "PDFImage", { enumerable: true, get: function() {
      return PDFImage_1.default;
    } });
    var PDFPage_1 = require_PDFPage();
    Object.defineProperty(exports, "PDFPage", { enumerable: true, get: function() {
      return PDFPage_1.default;
    } });
    var PDFEmbeddedPage_1 = require_PDFEmbeddedPage();
    Object.defineProperty(exports, "PDFEmbeddedPage", { enumerable: true, get: function() {
      return PDFEmbeddedPage_1.default;
    } });
    var PDFJavaScript_1 = require_PDFJavaScript();
    Object.defineProperty(exports, "PDFJavaScript", { enumerable: true, get: function() {
      return PDFJavaScript_1.default;
    } });
  }
});

// ../../../node_modules/pdf-lib/cjs/types/index.js
var require_types = __commonJS({
  "../../../node_modules/pdf-lib/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../../node_modules/pdf-lib/cjs/index.js
var require_cjs = __commonJS({
  "../../../node_modules/pdf-lib/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_api(), exports);
    tslib_1.__exportStar(require_core(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_utils2(), exports);
  }
});

// ../../../node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "../../../node_modules/delayed-stream/lib/delayed_stream.js"(exports, module2) {
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// ../../../node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "../../../node_modules/combined-stream/lib/combined_stream.js"(exports, module2) {
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// ../../../node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../../node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../../node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../../node_modules/mime-db/index.js"(exports, module2) {
    module2.exports = require_db();
  }
});

// ../../../node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../../node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup9;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match2 = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match2 && db[match2[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match2 && TEXT_TYPE_REGEXP.test(match2[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match2 = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match2 && exports.extensions[match2[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup9(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types2[extension2]) {
            var from = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type;
        }
      });
    }
  }
});

// ../../../node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "../../../node_modules/asynckit/lib/defer.js"(exports, module2) {
    module2.exports = defer2;
    function defer2(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// ../../../node_modules/asynckit/lib/async.js
var require_async2 = __commonJS({
  "../../../node_modules/asynckit/lib/async.js"(exports, module2) {
    var defer2 = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer2(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer2(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// ../../../node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "../../../node_modules/asynckit/lib/abort.js"(exports, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// ../../../node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "../../../node_modules/asynckit/lib/iterate.js"(exports, module2) {
    var async = require_async2();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// ../../../node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "../../../node_modules/asynckit/lib/state.js"(exports, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// ../../../node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "../../../node_modules/asynckit/lib/terminator.js"(exports, module2) {
    var abort = require_abort();
    var async = require_async2();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// ../../../node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "../../../node_modules/asynckit/parallel.js"(exports, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// ../../../node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "../../../node_modules/asynckit/serialOrdered.js"(exports, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// ../../../node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "../../../node_modules/asynckit/serial.js"(exports, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// ../../../node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "../../../node_modules/asynckit/index.js"(exports, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// ../../../node_modules/axios/node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "../../../node_modules/axios/node_modules/form-data/lib/populate.js"(exports, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// ../../../node_modules/axios/node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "../../../node_modules/axios/node_modules/form-data/lib/form_data.js"(exports, module2) {
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path2 = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData2;
    util.inherits(FormData2, CombinedStream);
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path2.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path2.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path2.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request, options, defaults2 = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults2);
      } else {
        options = populate(params, defaults2);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// ../../../node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "../../../node_modules/proxy-from-env/index.js"(exports) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s2) {
      return s2.length <= this.length && this.indexOf(s2, this.length - s2.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname2 = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname2 !== "string" || !hostname2 || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname2 = hostname2.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname2, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname2, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname2 !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname2, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports.getProxyForUrl = getProxyForUrl;
  }
});

// ../../../node_modules/ms/index.js
var require_ms = __commonJS({
  "../../../node_modules/ms/index.js"(exports, module2) {
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match2) {
        return;
      }
      var n2 = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../../node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "../../../node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format) => {
            if (match2 === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match2 = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match2;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search2, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search2.length) {
          if (templateIndex < template.length && (template[templateIndex] === search2[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../../node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index2++;
        if (match2 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common2()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../../node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../../node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../../node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../../node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init3;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init3(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../../../node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../../node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../../../node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../../../node_modules/follow-redirects/debug.js"(exports, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// ../../../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../../../node_modules/follow-redirects/index.js"(exports, module2) {
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL2(""));
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop2;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString3(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString3(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString3(options.host) && !isString3(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get3(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get3, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop2() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url.parse(input));
        if (!isString3(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base) {
      return useNativeURL ? new URL2(relative, base) : parseUrl(url.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop2);
      request.destroy(error);
    }
    function isSubdomain(subdomain2, domain) {
      assert(isString3(subdomain2) && isString3(domain));
      var dot = subdomain2.length - domain.length - 1;
      return dot > 0 && subdomain2[dot] === "." && subdomain2.endsWith(domain);
    }
    function isString3(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// ../../../node_modules/axios/dist/node/axios.cjs
var require_axios = __commonJS({
  "../../../node_modules/axios/dist/node/axios.cjs"(exports, module2) {
    "use strict";
    var FormData$1 = require_form_data();
    var url = require("url");
    var proxyFromEnv = require_proxy_from_env();
    var http = require("http");
    var https = require("https");
    var util = require("util");
    var followRedirects = require_follow_redirects();
    var zlib = require("zlib");
    var stream = require("stream");
    var events = require("events");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
    var url__default = /* @__PURE__ */ _interopDefaultLegacy(url);
    var proxyFromEnv__default = /* @__PURE__ */ _interopDefaultLegacy(proxyFromEnv);
    var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
    var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
    var followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
    var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
    var stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var kindOf = ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined2 = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined2(val) && val.constructor !== null && !isUndefined2(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString3 = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber2 = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject2 = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    var isDate2 = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l2;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l2 = obj.length; i < l2; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined2(context) && context !== _global;
    function merge2() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject2(result[targetKey]) && isPlainObject2(val)) {
          result[targetKey] = merge2(result[targetKey], val);
        } else if (isPlainObject2(val)) {
          result[targetKey] = merge2({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l2 = arguments.length; i < l2; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i = thing.length;
      if (!isNumber2(i))
        return null;
      const arr2 = new Array(i);
      while (i-- > 0) {
        arr2[i] = thing[i];
      }
      return arr2;
    };
    var isTypedArray = ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr2 = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr2.push(matches);
      }
      return arr2;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty2 = (({ hasOwnProperty: hasOwnProperty3 }) => (obj, prop) => hasOwnProperty3.call(obj, prop))(Object.prototype);
    var isRegExp2 = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr2) => {
        arr2.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop2 = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined2(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable2 = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction(_global.postMessage)
    );
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString3,
      isNumber: isNumber2,
      isBoolean,
      isObject,
      isPlainObject: isPlainObject2,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined: isUndefined2,
      isDate: isDate2,
      isFile,
      isBlob,
      isRegExp: isRegExp2,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge: merge2,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty: hasOwnProperty2,
      hasOwnProp: hasOwnProperty2,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop: noop2,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable: isThenable2,
      setImmediate: _setImmediate,
      asap
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
      }
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path2, key, dots) {
      if (!path2)
        return key;
      return path2.concat(key).map(function each2(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr2) {
      return utils$1.isArray(arr2) && !arr2.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (FormData__default["default"] || FormData)();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path2) {
        let arr2 = value;
        if (value && !path2 && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr2 = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr2.forEach(function each2(el, index2) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path2, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path2) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path2.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each2(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path2,
            exposedHelpers
          );
          if (result === true) {
            build(el, path2 ? path2.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
        return charMap[match2];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each2(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url2, params, options) {
      if (!params) {
        return url2;
      }
      const _encode = options && options.encode || encode;
      if (utils$1.isFunction(options)) {
        options = {
          serialize: options
        };
      }
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams2 = url__default["default"].URLSearchParams;
    var platform$1 = {
      isNode: true,
      classes: {
        URLSearchParams: URLSearchParams2,
        FormData: FormData__default["default"],
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      protocols: ["http", "https", "file", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var _navigator = typeof navigator === "object" && navigator || void 0;
    var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv,
      navigator: _navigator,
      origin
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path2, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
        return match2[0] === "[]" ? "" : match2[1] || match2[0];
      });
    }
    function arrayToObject(arr2) {
      const obj = {};
      const keys = Object.keys(arr2);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr2[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path2, value, target, index2) {
        let name = path2[index2++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index2 >= path2.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path2, value, target[name], index2);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults2 = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults2.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults2.headers[method] = {};
    });
    var defaults$1 = defaults2;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match2;
      while (match2 = tokensRE.exec(str)) {
        tokens[match2[1]] = match2[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isHeaders(header)) {
          for (const [key, value] of header.entries()) {
            setHeader(value, key, rewrite);
          }
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function isAbsoluteURL(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var VERSION = "1.7.9";
    function parseProtocol(url2) {
      const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
      return match2 && match2[1] || "";
    }
    var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
    function fromDataURI(uri, asBlob, options) {
      const _Blob = options && options.Blob || platform.classes.Blob;
      const protocol = parseProtocol(uri);
      if (asBlob === void 0 && _Blob) {
        asBlob = true;
      }
      if (protocol === "data") {
        uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
        const match2 = DATA_URL_PATTERN.exec(uri);
        if (!match2) {
          throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
        }
        const mime = match2[1];
        const isBase64 = match2[2];
        const body = match2[3];
        const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
        if (asBlob) {
          if (!_Blob) {
            throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
          }
          return new _Blob([buffer], { type: mime });
        }
        return buffer;
      }
      throw new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_NOT_SUPPORT);
    }
    var kInternals = Symbol("internals");
    var AxiosTransformStream = class extends stream__default["default"].Transform {
      constructor(options) {
        options = utils$1.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop, source) => {
          return !utils$1.isUndefined(source[prop]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const internals = this[kInternals] = {
          timeWindow: options.timeWindow,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        this.on("newListener", (event) => {
          if (event === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback) {
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        const pushChunk = (_chunk, _callback) => {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          internals.isCaptured && this.emit("progress", internals.bytesSeen);
          if (this.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        };
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now2 = Date.now();
            if (!internals.ts || (passed = now2 - internals.ts) >= timeWindow) {
              internals.ts = now2;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback(null);
          }
        });
      }
    };
    var AxiosTransformStream$1 = AxiosTransformStream;
    var { asyncIterator } = Symbol;
    var readBlob = async function* (blob) {
      if (blob.stream) {
        yield* blob.stream();
      } else if (blob.arrayBuffer) {
        yield await blob.arrayBuffer();
      } else if (blob[asyncIterator]) {
        yield* blob[asyncIterator]();
      } else {
        yield blob;
      }
    };
    var readBlob$1 = readBlob;
    var BOUNDARY_ALPHABET = utils$1.ALPHABET.ALPHA_DIGIT + "-_";
    var textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util__default["default"].TextEncoder();
    var CRLF = "\r\n";
    var CRLF_BYTES = textEncoder.encode(CRLF);
    var CRLF_BYTES_COUNT = 2;
    var FormDataPart = class {
      constructor(name, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils$1.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name;
        this.value = value;
      }
      async *encode() {
        yield this.headers;
        const { value } = this;
        if (utils$1.isTypedArray(value)) {
          yield value;
        } else {
          yield* readBlob$1(value);
        }
        yield CRLF_BYTES;
      }
      static escapeName(name) {
        return String(name).replace(/[\r\n"]/g, (match2) => ({
          "\r": "%0D",
          "\n": "%0A",
          '"': "%22"
        })[match2]);
      }
    };
    var formDataToStream = (form, headersHandler, options) => {
      const {
        tag = "form-data-boundary",
        size = 25,
        boundary = tag + "-" + utils$1.generateString(size, BOUNDARY_ALPHABET)
      } = options || {};
      if (!utils$1.isFormData(form)) {
        throw TypeError("FormData instance required");
      }
      if (boundary.length < 1 || boundary.length > 70) {
        throw Error("boundary must be 10-70 characters long");
      }
      const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
      const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name, value]) => {
        const part = new FormDataPart(name, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils$1.toFiniteNumber(contentLength);
      const computedHeaders = {
        "Content-Type": `multipart/form-data; boundary=${boundary}`
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders["Content-Length"] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return stream.Readable.from(async function* () {
        for (const part of parts) {
          yield boundaryBytes;
          yield* part.encode();
        }
        yield footerBytes;
      }());
    };
    var formDataToStream$1 = formDataToStream;
    var ZlibHeaderTransformStream = class extends stream__default["default"].Transform {
      __transform(chunk, encoding, callback) {
        this.push(chunk);
        callback();
      }
      _transform(chunk, encoding, callback) {
        if (chunk.length !== 0) {
          this._transform = this.__transform;
          if (chunk[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk, encoding, callback);
      }
    };
    var ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
    var callbackify = (fn, reducer) => {
      return utils$1.isAsyncFn(fn) ? function(...args) {
        const cb = args.pop();
        fn.apply(this, args).then((value) => {
          try {
            reducer ? cb(null, ...reducer(value)) : cb(null, value);
          } catch (err) {
            cb(err);
          }
        }, cb);
      } : fn;
    };
    var callbackify$1 = callbackify;
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now2 = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now2;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now2;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now2 - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now2 - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now2 = Date.now()) => {
        timestamp = now2;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn.apply(null, args);
      };
      const throttled = (...args) => {
        const now2 = Date.now();
        const passed = now2 - timestamp;
        if (passed >= threshold) {
          invoke(args, now2);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush2 = () => lastArgs && invoke(lastArgs);
      return [throttled, flush2];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
    var zlibOptions = {
      flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
      finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
    };
    var brotliOptions = {
      flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
      finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
    };
    var isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
    var { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
    var isHttps = /https:?/;
    var supportedProtocols = platform.protocols.map((protocol) => {
      return protocol + ":";
    });
    var flushOnFinish = (stream2, [throttled, flush2]) => {
      stream2.on("end", flush2).on("error", flush2);
      return throttled;
    };
    function dispatchBeforeRedirect(options, responseDetails) {
      if (options.beforeRedirects.proxy) {
        options.beforeRedirects.proxy(options);
      }
      if (options.beforeRedirects.config) {
        options.beforeRedirects.config(options, responseDetails);
      }
    }
    function setProxy(options, configProxy, location) {
      let proxy = configProxy;
      if (!proxy && proxy !== false) {
        const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
        if (proxyUrl) {
          proxy = new URL(proxyUrl);
        }
      }
      if (proxy) {
        if (proxy.username) {
          proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
        }
        if (proxy.auth) {
          if (proxy.auth.username || proxy.auth.password) {
            proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
          }
          const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
          options.headers["Proxy-Authorization"] = "Basic " + base64;
        }
        options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
        const proxyHost = proxy.hostname || proxy.host;
        options.hostname = proxyHost;
        options.host = proxyHost;
        options.port = proxy.port;
        options.path = location;
        if (proxy.protocol) {
          options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
        }
      }
      options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
        setProxy(redirectOptions, configProxy, redirectOptions.href);
      };
    }
    var isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
    var wrapAsync = (asyncExecutor) => {
      return new Promise((resolve, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone)
            return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
      });
    };
    var resolveFamily = ({ address, family }) => {
      if (!utils$1.isString(address)) {
        throw TypeError("address must be a string");
      }
      return {
        address,
        family: family || (address.indexOf(".") < 0 ? 6 : 4)
      };
    };
    var buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
    var httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
      return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
        let { data, lookup: lookup9, family } = config;
        const { responseType, responseEncoding } = config;
        const method = config.method.toUpperCase();
        let isDone;
        let rejected = false;
        let req;
        if (lookup9) {
          const _lookup = callbackify$1(lookup9, (value) => utils$1.isArray(value) ? value : [value]);
          lookup9 = (hostname2, opt, cb) => {
            _lookup(hostname2, opt, (err, arg0, arg1) => {
              if (err) {
                return cb(err);
              }
              const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
              opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
            });
          };
        }
        const emitter = new events.EventEmitter();
        const onFinished = () => {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(abort);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", abort);
          }
          emitter.removeAllListeners();
        };
        onDone((value, isRejected) => {
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
          }
        });
        function abort(reason) {
          emitter.emit("abort", !reason || reason.type ? new CanceledError(null, config, req) : reason);
        }
        emitter.once("abort", reject);
        if (config.cancelToken || config.signal) {
          config.cancelToken && config.cancelToken.subscribe(abort);
          if (config.signal) {
            config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
          }
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          let convertedData;
          if (method !== "GET") {
            return settle(resolve, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config
            });
          }
          try {
            convertedData = fromDataURI(config.url, responseType === "blob", {
              Blob: config.env && config.env.Blob
            });
          } catch (err) {
            throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              convertedData = utils$1.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = stream__default["default"].Readable.from(convertedData);
          }
          return settle(resolve, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: new AxiosHeaders$1(),
            config
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError(
            "Unsupported protocol " + protocol,
            AxiosError.ERR_BAD_REQUEST,
            config
          ));
        }
        const headers = AxiosHeaders$1.from(config.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const { onUploadProgress, onDownloadProgress } = config;
        const maxRate = config.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils$1.isSpecCompliantForm(data)) {
          const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
          data = formDataToStream$1(data, (formHeaders) => {
            headers.set(formHeaders);
          }, {
            tag: `axios-${VERSION}-boundary`,
            boundary: userBoundary && userBoundary[1] || void 0
          });
        } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
          if (!headers.hasContentLength()) {
            try {
              const knownLength = await util__default["default"].promisify(data.getLength).call(data);
              Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
            } catch (e) {
            }
          }
        } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
          data.size && headers.setContentType(data.type || "application/octet-stream");
          headers.setContentLength(data.size || 0);
          data = stream__default["default"].Readable.from(readBlob$1(data));
        } else if (data && !utils$1.isStream(data)) {
          if (Buffer.isBuffer(data))
            ;
          else if (utils$1.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils$1.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
          headers.setContentLength(data.length, false);
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(new AxiosError(
              "Request body larger than maxBodyLength limit",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
        }
        const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
        if (utils$1.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils$1.isStream(data)) {
            data = stream__default["default"].Readable.from(data, { objectMode: false });
          }
          data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
            maxRate: utils$1.toFiniteNumber(maxUploadRate)
          })], utils$1.noop);
          onUploadProgress && data.on("progress", flushOnFinish(
            data,
            progressEventDecorator(
              contentLength,
              progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
            )
          ));
        }
        let auth = void 0;
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path2;
        try {
          path2 = buildURL(
            parsed.pathname + parsed.search,
            config.params,
            config.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
          false
        );
        const options = {
          path: path2,
          method,
          headers: headers.toJSON(),
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth,
          protocol,
          family,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {}
        };
        !utils$1.isUndefined(lookup9) && (options.lookup = lookup9);
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsRequest ? https__default["default"] : http__default["default"];
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          if (config.beforeRedirect) {
            options.beforeRedirects.config = config.beforeRedirect;
          }
          transport = isHttpsRequest ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed)
            return;
          const streams = [res];
          const responseLength = +res.headers["content-length"];
          if (onDownloadProgress || maxDownloadRate) {
            const transformStream = new AxiosTransformStream$1({
              maxRate: utils$1.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", flushOnFinish(
              transformStream,
              progressEventDecorator(
                responseLength,
                progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
              )
            ));
            streams.push(transformStream);
          }
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config.decompress !== false && res.headers["content-encoding"]) {
            if (method === "HEAD" || res.statusCode === 204) {
              delete res.headers["content-encoding"];
            }
            switch ((res.headers["content-encoding"] || "").toLowerCase()) {
              case "gzip":
              case "x-gzip":
              case "compress":
              case "x-compress":
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "deflate":
                streams.push(new ZlibHeaderTransformStream$1());
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
                  delete res.headers["content-encoding"];
                }
            }
          }
          responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
          const offListeners = stream__default["default"].finished(responseStream, () => {
            offListeners();
            onFinished();
          });
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders$1(res.headers),
            config,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                reject(new AxiosError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  AxiosError.ERR_BAD_RESPONSE,
                  config,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError(
                "stream has been aborted",
                AxiosError.ERR_BAD_RESPONSE,
                config,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError(err) {
              if (req.destroyed)
                return;
              reject(AxiosError.from(err, null, config, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils$1.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                return reject(AxiosError.from(err, null, config, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
          emitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        emitter.once("abort", (err) => {
          reject(err);
          req.destroy(err);
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          const timeout = parseInt(config.timeout, 10);
          if (Number.isNaN(timeout)) {
            reject(new AxiosError(
              "error trying to parse `config.timeout` to int",
              AxiosError.ERR_BAD_OPTION_VALUE,
              config,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone)
              return;
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(new AxiosError(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              req
            ));
            abort();
          });
        }
        if (utils$1.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError("Request stream has been aborted", config, req));
            }
          });
          data.pipe(req);
        } else {
          req.end(data);
        }
      });
    };
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url2) => {
      url2 = new URL(url2, platform.origin);
      return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path2, domain, secure) {
          const cookie2 = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie2.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path2) && cookie2.push("path=" + path2);
          utils$1.isString(domain) && cookie2.push("domain=" + domain);
          secure === true && cookie2.push("secure");
          document.cookie = cookie2.join("; ");
        },
        read(name) {
          const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match2 ? decodeURIComponent(match2[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, prop, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge3 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge3(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var resolveConfig = (config) => {
      const newConfig = mergeConfig({}, config);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      let contentType;
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if ((contentType = headers.getContentType()) !== false) {
          const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
          headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    var composeSignals$1 = composeSignals;
    var streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    var readStream = async function* (stream2) {
      if (stream2[Symbol.asyncIterator]) {
        yield* stream2;
        return;
      }
      const reader = stream2.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    var trackStream = (stream2, chunkSize, onProgress, onFinish) => {
      const iterator = readBytes(stream2, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
    var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
    var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
    var test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    var supportsRequestStream = isReadableStreamSupported && test(() => {
      let duplexAccessed = false;
      const hasContentType = new Request(platform.origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("Content-Type");
      return duplexAccessed && !hasContentType;
    });
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
    var resolvers = {
      stream: supportsResponseStream && ((res) => res.body)
    };
    isFetchSupported && ((res) => {
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
        !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
          throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
        });
      });
    })(new Response());
    var getBodyLength = async (body) => {
      if (body == null) {
        return 0;
      }
      if (utils$1.isBlob(body)) {
        return body.size;
      }
      if (utils$1.isSpecCompliantForm(body)) {
        const _request = new Request(platform.origin, {
          method: "POST",
          body
        });
        return (await _request.arrayBuffer()).byteLength;
      }
      if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
        return body.byteLength;
      }
      if (utils$1.isURLSearchParams(body)) {
        body = body + "";
      }
      if (utils$1.isString(body)) {
        return (await encodeText(body)).byteLength;
      }
    };
    var resolveBodyLength = async (headers, body) => {
      const length = utils$1.toFiniteNumber(headers.getContentLength());
      return length == null ? getBodyLength(body) : length;
    };
    var fetchAdapter = isFetchSupported && (async (config) => {
      let {
        url: url2,
        method,
        data,
        signal,
        cancelToken,
        timeout,
        onDownloadProgress,
        onUploadProgress,
        responseType,
        headers,
        withCredentials = "same-origin",
        fetchOptions
      } = resolveConfig(config);
      responseType = responseType ? (responseType + "").toLowerCase() : "text";
      let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
      let request;
      const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
        composedSignal.unsubscribe();
      });
      let requestContentLength;
      try {
        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
          let _request = new Request(url2, {
            method: "POST",
            body: data,
            duplex: "half"
          });
          let contentTypeHeader;
          if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
            headers.setContentType(contentTypeHeader);
          }
          if (_request.body) {
            const [onProgress, flush2] = progressEventDecorator(
              requestContentLength,
              progressEventReducer(asyncDecorator(onUploadProgress))
            );
            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush2);
          }
        }
        if (!utils$1.isString(withCredentials)) {
          withCredentials = withCredentials ? "include" : "omit";
        }
        const isCredentialsSupported = "credentials" in Request.prototype;
        request = new Request(url2, {
          ...fetchOptions,
          signal: composedSignal,
          method: method.toUpperCase(),
          headers: headers.normalize().toJSON(),
          body: data,
          duplex: "half",
          credentials: isCredentialsSupported ? withCredentials : void 0
        });
        let response = await fetch(request);
        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
          const options = {};
          ["status", "statusText", "headers"].forEach((prop) => {
            options[prop] = response[prop];
          });
          const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
          const [onProgress, flush2] = onDownloadProgress && progressEventDecorator(
            responseContentLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true)
          ) || [];
          response = new Response(
            trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
              flush2 && flush2();
              unsubscribe && unsubscribe();
            }),
            options
          );
        }
        responseType = responseType || "text";
        let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
        !isStreamResponse && unsubscribe && unsubscribe();
        return await new Promise((resolve, reject) => {
          settle(resolve, reject, {
            data: responseData,
            headers: AxiosHeaders$1.from(response.headers),
            status: response.status,
            statusText: response.statusText,
            config,
            request
          });
        });
      } catch (err) {
        unsubscribe && unsubscribe();
        if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
          throw Object.assign(
            new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
            {
              cause: err.cause || err
            }
          );
        }
        throw AxiosError.from(err, err && err.code, config, request);
      }
    });
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: fetchAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s2,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        validator.assertOptions(config, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url: url2,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr2) {
        return callback.apply(null, arr2);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance2(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance2 = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance2, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance2, context, null, { allOwnKeys: true });
      instance2.create = function create3(instanceConfig) {
        return createInstance2(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance2;
    }
    var axios = createInstance2(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module2.exports = axios;
  }
});

// ../../../node_modules/@sendgrid/client/package.json
var require_package = __commonJS({
  "../../../node_modules/@sendgrid/client/package.json"(exports, module2) {
    module2.exports = {
      name: "@sendgrid/client",
      description: "Twilio SendGrid NodeJS API client",
      version: "8.1.4",
      author: "Twilio SendGrid <help@twilio.com> (sendgrid.com)",
      contributors: [
        "Kyle Partridge <kyle.partridge@sendgrid.com>",
        "David Tomberlin <david.tomberlin@sendgrid.com>",
        "Swift <swift@sendgrid.com>",
        "Brandon West <brandon.west@sendgrid.com>",
        "Scott Motte <scott.motte@sendgrid.com>",
        "Robert Acosta <robert.acosta@sendgrid.com>",
        "Elmer Thomas <ethomas@twilio.com>",
        "Adam Reis <adam@reis.nz>"
      ],
      license: "MIT",
      homepage: "https://sendgrid.com",
      repository: {
        type: "git",
        url: "git://github.com/sendgrid/sendgrid-nodejs.git"
      },
      publishConfig: {
        access: "public"
      },
      main: "index.js",
      engines: {
        node: ">=12.*"
      },
      dependencies: {
        "@sendgrid/helpers": "^8.0.0",
        axios: "^1.7.4"
      },
      devDependencies: {
        chai: "4.2.0",
        nock: "^10.0.6"
      },
      resolutions: {
        chai: "4.2.0"
      },
      tags: [
        "http",
        "rest",
        "api",
        "mail",
        "sendgrid"
      ],
      gitHead: "0bb5970f712d46444a41d0828fbbc606f000ebdc"
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/convert-keys.js
var require_convert_keys = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/convert-keys.js"(exports, module2) {
    "use strict";
    module2.exports = function convertKeys(obj, converter, ignored) {
      if (typeof obj !== "object" || obj === null) {
        throw new Error("Non object passed to convertKeys: " + obj);
      }
      if (Array.isArray(obj)) {
        return obj;
      }
      if (!Array.isArray(ignored)) {
        ignored = [];
      }
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const converted = converter(key);
          if (typeof obj[key] === "object" && obj[key] !== null) {
            if (!ignored.includes(key) && !ignored.includes(converted)) {
              obj[key] = convertKeys(obj[key], converter, ignored);
            }
          }
          if (converted !== key) {
            obj[converted] = obj[key];
            delete obj[key];
          }
        }
      }
      return obj;
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/str-to-camel-case.js
var require_str_to_camel_case = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/str-to-camel-case.js"(exports, module2) {
    "use strict";
    module2.exports = function strToCamelCase(str) {
      if (typeof str !== "string") {
        throw new Error("String expected for conversion to snake case");
      }
      return str.trim().replace(/_+|\-+/g, " ").replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, function(match2, index2) {
        if (Number(match2) === 0) {
          return "";
        }
        return index2 === 0 ? match2.toLowerCase() : match2.toUpperCase();
      });
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/to-camel-case.js
var require_to_camel_case = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/to-camel-case.js"(exports, module2) {
    "use strict";
    var convertKeys = require_convert_keys();
    var strToCamelCase = require_str_to_camel_case();
    module2.exports = function toCamelCase(obj, ignored) {
      return convertKeys(obj, strToCamelCase, ignored);
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/str-to-snake-case.js
var require_str_to_snake_case = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/str-to-snake-case.js"(exports, module2) {
    "use strict";
    module2.exports = function strToSnakeCase(str) {
      if (typeof str !== "string") {
        throw new Error("String expected for conversion to snake case");
      }
      return str.trim().replace(/(\s*\-*\b\w|[A-Z])/g, function($1) {
        $1 = $1.trim().toLowerCase().replace("-", "");
        return ($1[0] === "_" ? "" : "_") + $1;
      }).slice(1);
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/to-snake-case.js
var require_to_snake_case = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/to-snake-case.js"(exports, module2) {
    "use strict";
    var convertKeys = require_convert_keys();
    var strToSnakeCase = require_str_to_snake_case();
    module2.exports = function toSnakeCase(obj, ignored) {
      return convertKeys(obj, strToSnakeCase, ignored);
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/deep-clone.js
var require_deep_clone = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/deep-clone.js"(exports, module2) {
    "use strict";
    module2.exports = function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/classes/attachment.js
var require_attachment = __commonJS({
  "../../../node_modules/@sendgrid/helpers/classes/attachment.js"(exports, module2) {
    "use strict";
    var toCamelCase = require_to_camel_case();
    var toSnakeCase = require_to_snake_case();
    var deepClone = require_deep_clone();
    var fs = require("fs");
    var path2 = require("path");
    var Attachment = class {
      /**
       * Constructor
       */
      constructor(data) {
        if (data) {
          this.fromData(data);
        }
      }
      /**
       * From data
       */
      fromData(data) {
        if (typeof data !== "object") {
          throw new Error("Expecting object for Mail data");
        }
        data = deepClone(data);
        data = toCamelCase(data);
        const {
          content,
          filename,
          type,
          disposition,
          contentId,
          filePath
        } = data;
        if (typeof content !== "undefined" && typeof filePath !== "undefined") {
          throw new Error(
            "The props 'content' and 'filePath' cannot be used together."
          );
        }
        this.setFilename(filename);
        this.setType(type);
        this.setDisposition(disposition);
        this.setContentId(contentId);
        this.setContent(filePath ? this.readFile(filePath) : content);
      }
      /**
       * Read a file and return its content as base64
       */
      readFile(filePath) {
        return fs.readFileSync(path2.resolve(filePath));
      }
      /**
       * Set content
       */
      setContent(content) {
        if (typeof content === "string") {
          this.content = content;
          return;
        } else if (content instanceof Buffer && content.toString !== void 0) {
          this.content = content.toString();
          if (this.disposition === "attachment") {
            this.content = content.toString("base64");
          }
          return;
        }
        throw new Error("`content` expected to be either Buffer or string");
      }
      /**
       * Set content
       */
      setFileContent(content) {
        if (content instanceof Buffer && content.toString !== void 0) {
          this.content = content.toString("base64");
          return;
        }
        throw new Error("`content` expected to be Buffer");
      }
      /**
       * Set filename
       */
      setFilename(filename) {
        if (typeof filename === "undefined") {
          return;
        }
        if (filename && typeof filename !== "string") {
          throw new Error("String expected for `filename`");
        }
        this.filename = filename;
      }
      /**
       * Set type
       */
      setType(type) {
        if (typeof type === "undefined") {
          return;
        }
        if (typeof type !== "string") {
          throw new Error("String expected for `type`");
        }
        this.type = type;
      }
      /**
       * Set disposition
       */
      setDisposition(disposition) {
        if (typeof disposition === "undefined") {
          return;
        }
        if (typeof disposition !== "string") {
          throw new Error("String expected for `disposition`");
        }
        this.disposition = disposition;
      }
      /**
       * Set content ID
       */
      setContentId(contentId) {
        if (typeof contentId === "undefined") {
          return;
        }
        if (typeof contentId !== "string") {
          throw new Error("String expected for `contentId`");
        }
        this.contentId = contentId;
      }
      /**
       * To JSON
       */
      toJSON() {
        const { content, filename, type, disposition, contentId } = this;
        const json = { content, filename };
        if (typeof type !== "undefined") {
          json.type = type;
        }
        if (typeof disposition !== "undefined") {
          json.disposition = disposition;
        }
        if (typeof contentId !== "undefined") {
          json.contentId = contentId;
        }
        return toSnakeCase(json);
      }
    };
    module2.exports = Attachment;
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/split-name-email.js
var require_split_name_email = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/split-name-email.js"(exports, module2) {
    "use strict";
    module2.exports = function splitNameEmail(str) {
      if (str.indexOf("<") === -1) {
        return ["", str];
      }
      let [name, email] = str.split("<");
      name = name.trim();
      email = email.replace(">", "").trim();
      return [name, email];
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/classes/email-address.js
var require_email_address = __commonJS({
  "../../../node_modules/@sendgrid/helpers/classes/email-address.js"(exports, module2) {
    "use strict";
    var splitNameEmail = require_split_name_email();
    var EmailAddress = class _EmailAddress {
      /**
      * Constructor
      */
      constructor(data) {
        if (data) {
          this.fromData(data);
        }
      }
      /**
       * From data
       */
      fromData(data) {
        if (typeof data === "string") {
          const [name2, email2] = splitNameEmail(data);
          data = { name: name2, email: email2 };
        }
        if (typeof data !== "object") {
          throw new Error("Expecting object or string for EmailAddress data");
        }
        const { name, email } = data;
        this.setEmail(email);
        this.setName(name);
      }
      /**
       * Set name
       */
      setName(name) {
        if (typeof name === "undefined") {
          return;
        }
        if (typeof name !== "string") {
          throw new Error("String expected for `name`");
        }
        this.name = name;
      }
      /**
       * Set email (mandatory)
       */
      setEmail(email) {
        if (typeof email === "undefined") {
          throw new Error("Must provide `email`");
        }
        if (typeof email !== "string") {
          throw new Error("String expected for `email`");
        }
        this.email = email;
      }
      /**
      * To JSON
      */
      toJSON() {
        const { email, name } = this;
        const json = { email };
        if (name !== "") {
          json.name = name;
        }
        return json;
      }
      /**************************************************************************
       * Static helpers
       ***/
      /**
       * Create an EmailAddress instance from given data
       */
      static create(data) {
        if (Array.isArray(data)) {
          return data.filter((item) => !!item).map((item) => this.create(item));
        }
        if (data instanceof _EmailAddress) {
          return data;
        }
        return new _EmailAddress(data);
      }
    };
    module2.exports = EmailAddress;
  }
});

// ../../../node_modules/deepmerge/dist/cjs.js
var require_cjs2 = __commonJS({
  "../../../node_modules/deepmerge/dist/cjs.js"(exports, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object2, property) {
      try {
        return property in object2;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array2, options) {
      if (!Array.isArray(array2)) {
        throw new Error("first argument should be an array");
      }
      return array2.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module2.exports = deepmerge_1;
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/wrap-substitutions.js
var require_wrap_substitutions = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/wrap-substitutions.js"(exports, module2) {
    "use strict";
    module2.exports = function wrap(substitutions, left = "{{", right = "}}") {
      if (Array.isArray(substitutions)) {
        return substitutions.map((subs) => wrap(subs, left, right));
      }
      const wrapped = {};
      for (const key in substitutions) {
        if (substitutions.hasOwnProperty(key)) {
          wrapped[left + key + right] = String(substitutions[key]);
        }
      }
      return wrapped;
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/classes/personalization.js
var require_personalization = __commonJS({
  "../../../node_modules/@sendgrid/helpers/classes/personalization.js"(exports, module2) {
    "use strict";
    var EmailAddress = require_email_address();
    var toCamelCase = require_to_camel_case();
    var toSnakeCase = require_to_snake_case();
    var deepClone = require_deep_clone();
    var deepMerge = require_cjs2();
    var wrapSubstitutions = require_wrap_substitutions();
    var Personalization = class {
      /**
       * Constructor
       */
      constructor(data) {
        this.to = [];
        this.cc = [];
        this.bcc = [];
        this.headers = {};
        this.customArgs = {};
        this.substitutions = {};
        this.substitutionWrappers = ["{{", "}}"];
        this.dynamicTemplateData = {};
        if (data) {
          this.fromData(data);
        }
      }
      /**
       * From data
       */
      fromData(data) {
        if (typeof data !== "object") {
          throw new Error("Expecting object for Mail data");
        }
        data = deepClone(data);
        data = toCamelCase(data, ["substitutions", "dynamicTemplateData", "customArgs", "headers"]);
        const {
          to,
          from,
          cc,
          bcc,
          subject,
          headers,
          customArgs,
          sendAt,
          substitutions,
          substitutionWrappers,
          dynamicTemplateData
        } = data;
        this.setTo(to);
        this.setFrom(from);
        this.setCc(cc);
        this.setBcc(bcc);
        this.setSubject(subject);
        this.setHeaders(headers);
        this.setSubstitutions(substitutions);
        this.setSubstitutionWrappers(substitutionWrappers);
        this.setCustomArgs(customArgs);
        this.setDynamicTemplateData(dynamicTemplateData);
        this.setSendAt(sendAt);
      }
      /**
       * Set subject
       */
      setSubject(subject) {
        if (typeof subject === "undefined") {
          return;
        }
        if (typeof subject !== "string") {
          throw new Error("String expected for `subject`");
        }
        this.subject = subject;
      }
      /**
       * Set send at
       */
      setSendAt(sendAt) {
        if (typeof sendAt === "undefined") {
          return;
        }
        if (!Number.isInteger(sendAt)) {
          throw new Error("Integer expected for `sendAt`");
        }
        this.sendAt = sendAt;
      }
      /**
       * Set to
       */
      setTo(to) {
        if (typeof to === "undefined") {
          return;
        }
        if (!Array.isArray(to)) {
          to = [to];
        }
        this.to = EmailAddress.create(to);
      }
      /**
       * Set from
       * */
      setFrom(from) {
        if (typeof from === "undefined") {
          return;
        }
        this.from = EmailAddress.create(from);
      }
      /**
       * Add a single to
       */
      addTo(to) {
        if (typeof to === "undefined") {
          return;
        }
        this.to.push(EmailAddress.create(to));
      }
      /**
       * Set cc
       */
      setCc(cc) {
        if (typeof cc === "undefined") {
          return;
        }
        if (!Array.isArray(cc)) {
          cc = [cc];
        }
        this.cc = EmailAddress.create(cc);
      }
      /**
       * Add a single cc
       */
      addCc(cc) {
        if (typeof cc === "undefined") {
          return;
        }
        this.cc.push(EmailAddress.create(cc));
      }
      /**
       * Set bcc
       */
      setBcc(bcc) {
        if (typeof bcc === "undefined") {
          return;
        }
        if (!Array.isArray(bcc)) {
          bcc = [bcc];
        }
        this.bcc = EmailAddress.create(bcc);
      }
      /**
       * Add a single bcc
       */
      addBcc(bcc) {
        if (typeof bcc === "undefined") {
          return;
        }
        this.bcc.push(EmailAddress.create(bcc));
      }
      /**
       * Set headers
       */
      setHeaders(headers) {
        if (typeof headers === "undefined") {
          return;
        }
        if (typeof headers !== "object" || headers === null) {
          throw new Error("Object expected for `headers`");
        }
        this.headers = headers;
      }
      /**
       * Add a header
       */
      addHeader(key, value) {
        if (typeof key !== "string") {
          throw new Error("String expected for header key");
        }
        if (typeof value !== "string") {
          throw new Error("String expected for header value");
        }
        this.headers[key] = value;
      }
      /**
       * Set custom args
       */
      setCustomArgs(customArgs) {
        if (typeof customArgs === "undefined") {
          return;
        }
        if (typeof customArgs !== "object" || customArgs === null) {
          throw new Error("Object expected for `customArgs`");
        }
        this.customArgs = customArgs;
      }
      /**
       * Add a custom arg
       */
      addCustomArg(key, value) {
        if (typeof key !== "string") {
          throw new Error("String expected for custom arg key");
        }
        if (typeof value !== "string") {
          throw new Error("String expected for custom arg value");
        }
        this.customArgs[key] = value;
      }
      /**
       * Set substitutions
       */
      setSubstitutions(substitutions) {
        if (typeof substitutions === "undefined") {
          return;
        }
        if (typeof substitutions !== "object") {
          throw new Error("Object expected for `substitutions`");
        }
        this.substitutions = substitutions;
      }
      /**
       * Add a substitution
       */
      addSubstitution(key, value) {
        if (typeof key !== "string") {
          throw new Error("String expected for substitution key");
        }
        if (typeof value !== "string" && typeof value !== "number") {
          throw new Error("String or Number expected for substitution value");
        }
        this.substitutions[key] = value;
      }
      /**
       * Reverse merge substitutions, preserving existing ones
       */
      reverseMergeSubstitutions(substitutions) {
        if (typeof substitutions === "undefined" || substitutions === null) {
          return;
        }
        if (typeof substitutions !== "object") {
          throw new Error(
            "Object expected for `substitutions` in reverseMergeSubstitutions"
          );
        }
        this.substitutions = Object.assign({}, substitutions, this.substitutions);
      }
      /**
       * Set substitution wrappers
       */
      setSubstitutionWrappers(wrappers) {
        if (typeof wrappers === "undefined" || wrappers === null) {
          return;
        }
        if (!Array.isArray(wrappers) || wrappers.length !== 2) {
          throw new Error(
            "Array expected with two elements for `substitutionWrappers`"
          );
        }
        this.substitutionWrappers = wrappers;
      }
      /**
       * Reverse merge dynamic template data, preserving existing ones
       */
      deepMergeDynamicTemplateData(dynamicTemplateData) {
        if (typeof dynamicTemplateData === "undefined" || dynamicTemplateData === null) {
          return;
        }
        if (typeof dynamicTemplateData !== "object") {
          throw new Error(
            "Object expected for `dynamicTemplateData` in deepMergeDynamicTemplateData"
          );
        }
        this.dynamicTemplateData = deepMerge(dynamicTemplateData, this.dynamicTemplateData);
      }
      /**
       * Set dynamic template data
       */
      setDynamicTemplateData(dynamicTemplateData) {
        if (typeof dynamicTemplateData === "undefined") {
          return;
        }
        if (typeof dynamicTemplateData !== "object") {
          throw new Error("Object expected for `dynamicTemplateData`");
        }
        this.dynamicTemplateData = dynamicTemplateData;
      }
      /**
       * To JSON
       */
      toJSON() {
        const {
          to,
          from,
          cc,
          bcc,
          subject,
          headers,
          customArgs,
          sendAt,
          substitutions,
          substitutionWrappers,
          dynamicTemplateData
        } = this;
        const json = { to };
        if (Array.isArray(cc) && cc.length > 0) {
          json.cc = cc;
        }
        if (Array.isArray(bcc) && bcc.length > 0) {
          json.bcc = bcc;
        }
        if (Object.keys(headers).length > 0) {
          json.headers = headers;
        }
        if (substitutions && Object.keys(substitutions).length > 0) {
          const [left, right] = substitutionWrappers;
          json.substitutions = wrapSubstitutions(substitutions, left, right);
        }
        if (Object.keys(customArgs).length > 0) {
          json.customArgs = customArgs;
        }
        if (dynamicTemplateData && Object.keys(dynamicTemplateData).length > 0) {
          json.dynamicTemplateData = dynamicTemplateData;
        }
        if (typeof subject !== "undefined") {
          json.subject = subject;
        }
        if (typeof sendAt !== "undefined") {
          json.sendAt = sendAt;
        }
        if (typeof from !== "undefined") {
          json.from = from;
        }
        return toSnakeCase(json, ["substitutions", "dynamicTemplateData", "customArgs", "headers"]);
      }
    };
    module2.exports = Personalization;
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/array-to-json.js
var require_array_to_json = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/array-to-json.js"(exports, module2) {
    "use strict";
    module2.exports = function arrayToJSON(arr2) {
      return arr2.map((item) => {
        if (typeof item === "object" && item !== null && typeof item.toJSON === "function") {
          return item.toJSON();
        }
        return item;
      });
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/constants/index.js
var require_constants2 = __commonJS({
  "../../../node_modules/@sendgrid/helpers/constants/index.js"(exports, module2) {
    var DYNAMIC_TEMPLATE_CHAR_WARNING = `
Content with characters ', " or & may need to be escaped with three brackets
{{{ content }}}
See https://sendgrid.com/docs/for-developers/sending-email/using-handlebars/ for more information.`;
    module2.exports = {
      DYNAMIC_TEMPLATE_CHAR_WARNING
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/validate-settings.js
var require_validate_settings = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/validate-settings.js"(exports, module2) {
    "use strict";
    var validate = (parent, parentName, childName, childType) => {
      if (typeof parent === "undefined" || typeof parent[childName] === "undefined") {
        return;
      }
      if (typeof parent[childName] !== childType) {
        throw new Error(`${childType} expected for \`${parentName}.${childName}\``);
      }
    };
    module2.exports = {
      validateMailSettings(settings) {
        if (typeof settings !== "object") {
          throw new Error("Object expected for `mailSettings`");
        }
        const {
          bcc,
          bypassListManagement,
          bypassSpamManagement,
          bypassBounceManagement,
          bypassUnsubscribeManagement,
          footer,
          sandboxMode,
          spamCheck
        } = settings;
        validate(bcc, "bcc", "enable", "boolean");
        validate(bcc, "bcc", "email", "string");
        validate(bypassListManagement, "bypassListManagement", "enable", "boolean");
        validate(bypassSpamManagement, "bypassSpamManagement", "enable", "boolean");
        validate(bypassBounceManagement, "bypassBounceManagement", "enable", "boolean");
        validate(bypassUnsubscribeManagement, "bypassUnsubscribeManagement", "enable", "boolean");
        validate(footer, "footer", "enable", "boolean");
        validate(footer, "footer", "text", "string");
        validate(footer, "footer", "html", "string");
        validate(sandboxMode, "sandboxMode", "enable", "boolean");
        validate(spamCheck, "spamCheck", "enable", "boolean");
        validate(spamCheck, "spamCheck", "threshold", "number");
        validate(spamCheck, "spamCheck", "postToUrl", "string");
      },
      validateTrackingSettings(settings) {
        if (typeof settings !== "object") {
          throw new Error("Object expected for `trackingSettings`");
        }
        const {
          clickTracking,
          openTracking,
          subscriptionTracking,
          ganalytics
        } = settings;
        validate(clickTracking, "clickTracking", "enable", "boolean");
        validate(clickTracking, "clickTracking", "enableText", "boolean");
        validate(openTracking, "openTracking", "enable", "boolean");
        validate(openTracking, "openTracking", "substitutionTag", "string");
        validate(subscriptionTracking, "subscriptionTracking", "enable", "boolean");
        validate(subscriptionTracking, "subscriptionTracking", "text", "string");
        validate(subscriptionTracking, "subscriptionTracking", "html", "string");
        validate(subscriptionTracking, "subscriptionTracking", "substitutionTag", "string");
        validate(ganalytics, "ganalytics", "enable", "boolean");
        validate(ganalytics, "ganalytics", "utm_source", "string");
        validate(ganalytics, "ganalytics", "utm_medium", "string");
        validate(ganalytics, "ganalytics", "utm_term", "string");
        validate(ganalytics, "ganalytics", "utm_content", "string");
        validate(ganalytics, "ganalytics", "utm_campaign", "string");
      }
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/classes/mail.js
var require_mail = __commonJS({
  "../../../node_modules/@sendgrid/helpers/classes/mail.js"(exports, module2) {
    "use strict";
    var EmailAddress = require_email_address();
    var Personalization = require_personalization();
    var toCamelCase = require_to_camel_case();
    var toSnakeCase = require_to_snake_case();
    var deepClone = require_deep_clone();
    var arrayToJSON = require_array_to_json();
    var { DYNAMIC_TEMPLATE_CHAR_WARNING } = require_constants2();
    var { validateMailSettings, validateTrackingSettings } = require_validate_settings();
    var Mail = class _Mail {
      /**
       * Constructor
       */
      constructor(data) {
        this.isDynamic = false;
        this.hideWarnings = false;
        this.personalizations = [];
        this.attachments = [];
        this.content = [];
        this.categories = [];
        this.headers = {};
        this.sections = {};
        this.customArgs = {};
        this.trackingSettings = {};
        this.mailSettings = {};
        this.asm = {};
        this.substitutions = null;
        this.substitutionWrappers = null;
        this.dynamicTemplateData = null;
        if (data) {
          this.fromData(data);
        }
      }
      /**
       * Build from data
       */
      fromData(data) {
        if (typeof data !== "object") {
          throw new Error("Expecting object for Mail data");
        }
        data = deepClone(data);
        data = toCamelCase(data, ["substitutions", "dynamicTemplateData", "customArgs", "headers", "sections"]);
        const {
          to,
          from,
          replyTo,
          cc,
          bcc,
          sendAt,
          subject,
          text,
          html,
          content,
          templateId,
          personalizations,
          attachments,
          ipPoolName,
          batchId,
          sections,
          headers,
          categories,
          category,
          customArgs,
          asm,
          mailSettings,
          trackingSettings,
          substitutions,
          substitutionWrappers,
          dynamicTemplateData,
          isMultiple,
          hideWarnings,
          replyToList
        } = data;
        this.setFrom(from);
        this.setReplyTo(replyTo);
        this.setSubject(subject);
        this.setSendAt(sendAt);
        this.setTemplateId(templateId);
        this.setBatchId(batchId);
        this.setIpPoolName(ipPoolName);
        this.setAttachments(attachments);
        this.setContent(content);
        this.setSections(sections);
        this.setHeaders(headers);
        this.setCategories(category);
        this.setCategories(categories);
        this.setCustomArgs(customArgs);
        this.setAsm(asm);
        this.setMailSettings(mailSettings);
        this.setTrackingSettings(trackingSettings);
        this.setHideWarnings(hideWarnings);
        this.setReplyToList(replyToList);
        if (this.isDynamic) {
          this.setDynamicTemplateData(dynamicTemplateData);
        } else {
          this.setSubstitutions(substitutions);
          this.setSubstitutionWrappers(substitutionWrappers);
        }
        this.addTextContent(text);
        this.addHtmlContent(html);
        if (personalizations) {
          this.setPersonalizations(personalizations);
        } else if (isMultiple && Array.isArray(to)) {
          to.forEach((to2) => this.addTo(to2, cc, bcc));
        } else {
          this.addTo(to, cc, bcc);
        }
      }
      /**
       * Set from email
       */
      setFrom(from) {
        if (this._checkProperty("from", from, [this._checkUndefined])) {
          if (typeof from !== "string" && typeof from.email !== "string") {
            throw new Error("String or address object expected for `from`");
          }
          this.from = EmailAddress.create(from);
        }
      }
      /**
       * Set reply to
       */
      setReplyTo(replyTo) {
        if (this._checkProperty("replyTo", replyTo, [this._checkUndefined])) {
          if (typeof replyTo !== "string" && typeof replyTo.email !== "string") {
            throw new Error("String or address object expected for `replyTo`");
          }
          this.replyTo = EmailAddress.create(replyTo);
        }
      }
      /**
       * Set subject
       */
      setSubject(subject) {
        this._setProperty("subject", subject, "string");
      }
      /**
       * Set send at
       */
      setSendAt(sendAt) {
        if (this._checkProperty("sendAt", sendAt, [this._checkUndefined, this._createCheckThatThrows(Number.isInteger, "Integer expected for `sendAt`")])) {
          this.sendAt = sendAt;
        }
      }
      /**
       * Set template ID, also checks if the template is dynamic or legacy
       */
      setTemplateId(templateId) {
        if (this._setProperty("templateId", templateId, "string")) {
          if (templateId.indexOf("d-") === 0) {
            this.isDynamic = true;
          }
        }
      }
      /**
       * Set batch ID
       */
      setBatchId(batchId) {
        this._setProperty("batchId", batchId, "string");
      }
      /**
       * Set IP pool name
       */
      setIpPoolName(ipPoolName) {
        this._setProperty("ipPoolName", ipPoolName, "string");
      }
      /**
       * Set ASM
       */
      setAsm(asm) {
        if (this._checkProperty("asm", asm, [this._checkUndefined, this._createTypeCheck("object")])) {
          if (typeof asm.groupId !== "number") {
            throw new Error("Expected `asm` to include an integer in its `groupId` field");
          }
          if (asm.groupsToDisplay && (!Array.isArray(asm.groupsToDisplay) || !asm.groupsToDisplay.every((group) => typeof group === "number"))) {
            throw new Error("Array of integers expected for `asm.groupsToDisplay`");
          }
          this.asm = asm;
        }
      }
      /**
       * Set personalizations
       */
      setPersonalizations(personalizations) {
        if (!this._doArrayCheck("personalizations", personalizations)) {
          return;
        }
        if (!personalizations.every((personalization) => typeof personalization === "object")) {
          throw new Error("Array of objects expected for `personalizations`");
        }
        this.personalizations = [];
        personalizations.forEach((personalization) => this.addPersonalization(personalization));
      }
      /**
       * Add personalization
       */
      addPersonalization(personalization) {
        if (this.isDynamic && personalization.substitutions) {
          delete personalization.substitutions;
        } else if (!this.isDynamic && personalization.dynamicTemplateData) {
          delete personalization.dynamicTemplateData;
        }
        if (!(personalization instanceof Personalization)) {
          personalization = new Personalization(personalization);
        }
        if (this.isDynamic) {
          this.applyDynamicTemplateData(personalization);
        } else {
          this.applySubstitutions(personalization);
        }
        this.personalizations.push(personalization);
      }
      /**
       * Convenience method for quickly creating personalizations
       */
      addTo(to, cc, bcc) {
        if (typeof to === "undefined" && typeof cc === "undefined" && typeof bcc === "undefined") {
          throw new Error("Provide at least one of to, cc or bcc");
        }
        this.addPersonalization(new Personalization({ to, cc, bcc }));
      }
      /**
       * Set substitutions
       */
      setSubstitutions(substitutions) {
        this._setProperty("substitutions", substitutions, "object");
      }
      /**
       * Set substitution wrappers
       */
      setSubstitutionWrappers(substitutionWrappers) {
        let lengthCheck = (propertyName, value) => {
          if (!Array.isArray(value) || value.length !== 2) {
            throw new Error("Array expected with two elements for `" + propertyName + "`");
          }
        };
        if (this._checkProperty("substitutionWrappers", substitutionWrappers, [this._checkUndefined, lengthCheck])) {
          this.substitutionWrappers = substitutionWrappers;
        }
      }
      /**
       * Helper which applies globally set substitutions to personalizations
       */
      applySubstitutions(personalization) {
        if (personalization instanceof Personalization) {
          personalization.reverseMergeSubstitutions(this.substitutions);
          personalization.setSubstitutionWrappers(this.substitutionWrappers);
        }
      }
      /**
       * Helper which applies globally set dynamic_template_data to personalizations
       */
      applyDynamicTemplateData(personalization) {
        if (personalization instanceof Personalization) {
          personalization.deepMergeDynamicTemplateData(this.dynamicTemplateData);
        }
      }
      /**
       * Set dynamicTemplateData
       */
      setDynamicTemplateData(dynamicTemplateData) {
        if (typeof dynamicTemplateData === "undefined") {
          return;
        }
        if (typeof dynamicTemplateData !== "object") {
          throw new Error("Object expected for `dynamicTemplateData`");
        }
        if (!this.hideWarnings) {
          Object.values(dynamicTemplateData).forEach((value) => {
            if (/['"&]/.test(value)) {
              console.warn(DYNAMIC_TEMPLATE_CHAR_WARNING);
            }
          });
        }
        this.dynamicTemplateData = dynamicTemplateData;
      }
      /**
       * Set content
       */
      setContent(content) {
        if (this._doArrayCheck("content", content)) {
          if (!content.every((contentField) => typeof contentField === "object")) {
            throw new Error("Expected each entry in `content` to be an object");
          }
          if (!content.every((contentField) => typeof contentField.type === "string")) {
            throw new Error("Expected each `content` entry to contain a `type` string");
          }
          if (!content.every((contentField) => typeof contentField.value === "string")) {
            throw new Error("Expected each `content` entry to contain a `value` string");
          }
          this.content = content;
        }
      }
      /**
       * Add content
       */
      addContent(content) {
        if (this._checkProperty("content", content, [this._createTypeCheck("object")])) {
          this.content.push(content);
        }
      }
      /**
       * Add text content
       */
      addTextContent(text) {
        if (this._checkProperty("text", text, [this._checkUndefined, this._createTypeCheck("string")])) {
          this.addContent({
            value: text,
            type: "text/plain"
          });
        }
      }
      /**
       * Add HTML content
       */
      addHtmlContent(html) {
        if (this._checkProperty("html", html, [this._checkUndefined, this._createTypeCheck("string")])) {
          this.addContent({
            value: html,
            type: "text/html"
          });
        }
      }
      /**
       * Set attachments
       */
      setAttachments(attachments) {
        if (this._doArrayCheck("attachments", attachments)) {
          if (!attachments.every((attachment) => typeof attachment.content === "string")) {
            throw new Error("Expected each attachment to contain a `content` string");
          }
          if (!attachments.every((attachment) => typeof attachment.filename === "string")) {
            throw new Error("Expected each attachment to contain a `filename` string");
          }
          if (!attachments.every((attachment) => !attachment.type || typeof attachment.type === "string")) {
            throw new Error("Expected the attachment's `type` field to be a string");
          }
          if (!attachments.every((attachment) => !attachment.disposition || typeof attachment.disposition === "string")) {
            throw new Error("Expected the attachment's `disposition` field to be a string");
          }
          this.attachments = attachments;
        }
      }
      /**
       * Add attachment
       */
      addAttachment(attachment) {
        if (this._checkProperty("attachment", attachment, [this._checkUndefined, this._createTypeCheck("object")])) {
          this.attachments.push(attachment);
        }
      }
      /**
       * Set categories
       */
      setCategories(categories) {
        let allElementsAreStrings = (propertyName, value) => {
          if (!Array.isArray(value) || !value.every((item) => typeof item === "string")) {
            throw new Error("Array of strings expected for `" + propertyName + "`");
          }
        };
        if (typeof categories === "string") {
          categories = [categories];
        }
        if (this._checkProperty("categories", categories, [this._checkUndefined, allElementsAreStrings])) {
          this.categories = categories;
        }
      }
      /**
       * Add category
       */
      addCategory(category) {
        if (this._checkProperty("category", category, [this._createTypeCheck("string")])) {
          this.categories.push(category);
        }
      }
      /**
       * Set headers
       */
      setHeaders(headers) {
        this._setProperty("headers", headers, "object");
      }
      /**
       * Add a header
       */
      addHeader(key, value) {
        if (this._checkProperty("key", key, [this._createTypeCheck("string")]) && this._checkProperty("value", value, [this._createTypeCheck("string")])) {
          this.headers[key] = value;
        }
      }
      /**
       * Set sections
       */
      setSections(sections) {
        this._setProperty("sections", sections, "object");
      }
      /**
       * Set custom args
       */
      setCustomArgs(customArgs) {
        this._setProperty("customArgs", customArgs, "object");
      }
      /**
       * Set tracking settings
       */
      setTrackingSettings(settings) {
        if (typeof settings === "undefined") {
          return;
        }
        validateTrackingSettings(settings);
        this.trackingSettings = settings;
      }
      /**
       * Set mail settings
       */
      setMailSettings(settings) {
        if (typeof settings === "undefined") {
          return;
        }
        validateMailSettings(settings);
        this.mailSettings = settings;
      }
      /**
       * Set hide warnings
       */
      setHideWarnings(hide) {
        if (typeof hide === "undefined") {
          return;
        }
        if (typeof hide !== "boolean") {
          throw new Error("Boolean expected for `hideWarnings`");
        }
        this.hideWarnings = hide;
      }
      /**
       * To JSON
       */
      toJSON() {
        const {
          from,
          replyTo,
          sendAt,
          subject,
          content,
          templateId,
          personalizations,
          attachments,
          ipPoolName,
          batchId,
          asm,
          sections,
          headers,
          categories,
          customArgs,
          mailSettings,
          trackingSettings,
          replyToList
        } = this;
        const json = {
          from,
          subject,
          personalizations: arrayToJSON(personalizations)
        };
        if (Array.isArray(attachments) && attachments.length > 0) {
          json.attachments = arrayToJSON(attachments);
        }
        if (Array.isArray(categories) && categories.length > 0) {
          json.categories = categories.filter((cat) => cat !== "");
        }
        if (Array.isArray(content) && content.length > 0) {
          json.content = arrayToJSON(content);
        }
        if (Object.keys(headers).length > 0) {
          json.headers = headers;
        }
        if (Object.keys(mailSettings).length > 0) {
          json.mailSettings = mailSettings;
        }
        if (Object.keys(trackingSettings).length > 0) {
          json.trackingSettings = trackingSettings;
        }
        if (Object.keys(customArgs).length > 0) {
          json.customArgs = customArgs;
        }
        if (Object.keys(sections).length > 0) {
          json.sections = sections;
        }
        if (Object.keys(asm).length > 0) {
          json.asm = asm;
        }
        if (typeof replyTo !== "undefined") {
          json.replyTo = replyTo;
        }
        if (typeof sendAt !== "undefined") {
          json.sendAt = sendAt;
        }
        if (typeof batchId !== "undefined") {
          json.batchId = batchId;
        }
        if (typeof templateId !== "undefined") {
          json.templateId = templateId;
        }
        if (typeof ipPoolName !== "undefined") {
          json.ipPoolName = ipPoolName;
        }
        if (typeof replyToList !== "undefined") {
          json.replyToList = replyToList;
        }
        return toSnakeCase(json, ["substitutions", "dynamicTemplateData", "customArgs", "headers", "sections"]);
      }
      /**************************************************************************
       * Static helpers
       ***/
      /**
       * Create a Mail instance from given data
       */
      static create(data) {
        if (Array.isArray(data)) {
          return data.filter((item) => !!item).map((item) => this.create(item));
        }
        if (data instanceof _Mail) {
          return data;
        }
        return new _Mail(data);
      }
      /**************************************************************************
       * helpers for property-setting checks
       ***/
      /**
       * Perform a set of checks on the new property value. Returns true if all
       * checks complete successfully without throwing errors or returning true.
       */
      _checkProperty(propertyName, value, checks) {
        return !checks.some((e) => e(propertyName, value));
      }
      /**
       * Set a property with normal undefined and type-checks
       */
      _setProperty(propertyName, value, propertyType) {
        let propertyChecksPassed = this._checkProperty(
          propertyName,
          value,
          [this._checkUndefined, this._createTypeCheck(propertyType)]
        );
        if (propertyChecksPassed) {
          this[propertyName] = value;
        }
        return propertyChecksPassed;
      }
      /**
       * Fail if the value is undefined.
       */
      _checkUndefined(propertyName, value) {
        return typeof value === "undefined";
      }
      /**
       * Create and return a function that checks for a given type
       */
      _createTypeCheck(propertyType) {
        return (propertyName, value) => {
          if (typeof value !== propertyType) {
            throw new Error(propertyType + " expected for `" + propertyName + "`");
          }
        };
      }
      /**
       * Create a check out of a callback. If the callback
       * returns false, the check will throw an error.
       */
      _createCheckThatThrows(check, errorString) {
        return (propertyName, value) => {
          if (!check(value)) {
            throw new Error(errorString);
          }
        };
      }
      /**
       * Set an array property after checking that the new value is an
       * array.
       */
      _setArrayProperty(propertyName, value) {
        if (this._doArrayCheck(propertyName, value)) {
          this[propertyName] = value;
        }
      }
      /**
       * Check that a value isn't undefined and is an array.
       */
      _doArrayCheck(propertyName, value) {
        return this._checkProperty(
          propertyName,
          value,
          [this._checkUndefined, this._createCheckThatThrows(Array.isArray, "Array expected for`" + propertyName + "`")]
        );
      }
      /**
       * Set the replyToList from email body
       */
      setReplyToList(replyToList) {
        if (this._doArrayCheck("replyToList", replyToList) && replyToList.length) {
          if (!replyToList.every((replyTo) => replyTo && typeof replyTo.email === "string")) {
            throw new Error("Expected each replyTo to contain an `email` string");
          }
          this.replyToList = replyToList;
        }
      }
    };
    module2.exports = Mail;
  }
});

// ../../../node_modules/@sendgrid/helpers/classes/response.js
var require_response = __commonJS({
  "../../../node_modules/@sendgrid/helpers/classes/response.js"(exports, module2) {
    "use strict";
    var Response2 = class {
      constructor(statusCode, body, headers) {
        this.statusCode = statusCode;
        this.body = body;
        this.headers = headers;
      }
      toString() {
        return "HTTP " + this.statusCode + " " + this.body;
      }
    };
    module2.exports = Response2;
  }
});

// ../../../node_modules/@sendgrid/helpers/classes/response-error.js
var require_response_error = __commonJS({
  "../../../node_modules/@sendgrid/helpers/classes/response-error.js"(exports, module2) {
    "use strict";
    var ResponseError = class extends Error {
      /**
       * Constructor
       */
      constructor(response) {
        super();
        const { headers, status, statusText, data } = response;
        this.code = status;
        this.message = statusText;
        this.response = { headers, body: data };
        if (!this.stack) {
          Error.captureStackTrace(this, this.constructor);
        }
        const regex = new RegExp(process.cwd() + "/", "gi");
        this.stack = this.stack.replace(regex, "");
      }
      /**
       * Convert to string
       */
      toString() {
        const { body } = this.response;
        let err = `${this.message} (${this.code})`;
        if (body && Array.isArray(body.errors)) {
          body.errors.forEach((error) => {
            const message = error.message;
            const field = error.field;
            const help = error.help;
            err += `
  ${message}
    ${field}
    ${help}`;
          });
        }
        return err;
      }
      /**
       * Convert to simple object for JSON responses
       */
      toJSON() {
        const { message, code, response } = this;
        return { message, code, response };
      }
    };
    module2.exports = ResponseError;
  }
});

// ../../../node_modules/@sendgrid/helpers/classes/statistics.js
var require_statistics = __commonJS({
  "../../../node_modules/@sendgrid/helpers/classes/statistics.js"(exports, module2) {
    "use strict";
    var toCamelCase = require_to_camel_case();
    var deepClone = require_deep_clone();
    var AggregatedByOptions = ["day", "week", "month"];
    var CountryOptions = ["us", "ca"];
    var SortByDirection = ["desc", "asc"];
    var Statistics = class {
      constructor(data) {
        this.startDate = null;
        this.endDate = null;
        this.aggregatedBy = null;
        if (data) {
          this.fromData(data);
        }
      }
      /**
       * Build from data
       */
      fromData(data) {
        if (typeof data !== "object") {
          throw new Error("Expecting object for Statistics data");
        }
        data = deepClone(data);
        data = toCamelCase(data, ["substitutions", "customArgs"]);
        const {
          startDate,
          endDate,
          aggregatedBy
        } = data;
        this.setStartDate(startDate);
        this.setEndDate(endDate);
        this.setAggregatedBy(aggregatedBy);
      }
      /**
       * Set startDate
       */
      setStartDate(startDate) {
        if (typeof startDate === "undefined") {
          throw new Error("Date expected for `startDate`");
        }
        if (new Date(startDate) === "Invalid Date" || isNaN(new Date(startDate))) {
          throw new Error("Date expected for `startDate`");
        }
        console.log(startDate);
        this.startDate = new Date(startDate).toISOString().slice(0, 10);
      }
      /**
       * Set endDate
       */
      setEndDate(endDate) {
        if (typeof endDate === "undefined") {
          this.endDate = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
          return;
        }
        if (new Date(endDate) === "Invalid Date" || isNaN(new Date(endDate))) {
          throw new Error("Date expected for `endDate`");
        }
        this.endDate = new Date(endDate).toISOString().slice(0, 10);
      }
      /**
       * Set aggregatedBy
       */
      setAggregatedBy(aggregatedBy) {
        if (typeof aggregatedBy === "undefined") {
          return;
        }
        if (typeof aggregatedBy === "string" && AggregatedByOptions.includes(aggregatedBy.toLowerCase())) {
          this.aggregatedBy = aggregatedBy;
        } else {
          throw new Error("Incorrect value for `aggregatedBy`");
        }
      }
      /**
       * Get Global
       */
      getGlobal() {
        const { startDate, endDate, aggregatedBy } = this;
        return { startDate, endDate, aggregatedBy };
      }
      /**
       * Get Advanced
       */
      getAdvanced(country) {
        const json = this.getGlobal();
        if (typeof country === "undefined") {
          return json;
        }
        if (typeof country === "string" && CountryOptions.includes(country.toLowerCase())) {
          json.country = country;
        }
        return json;
      }
      /**
       * Get Advanced Mailbox Providers
       */
      getAdvancedMailboxProviders(mailBoxProviders) {
        const json = this.getGlobal();
        if (typeof mailBoxProviders === "undefined") {
          return json;
        }
        if (Array.isArray(mailBoxProviders) && mailBoxProviders.some((x) => typeof x !== "string")) {
          throw new Error("Array of strings expected for `mailboxProviders`");
        }
        json.mailBoxProviders = mailBoxProviders;
        return json;
      }
      /**
       * Get Advanced Browsers
       */
      getAdvancedBrowsers(browsers) {
        const json = this.getGlobal();
        if (typeof browsers === "undefined") {
          return json;
        }
        if (Array.isArray(browsers) && browsers.some((x) => typeof x !== "string")) {
          throw new Error("Array of strings expected for `browsers`");
        }
        json.browsers = browsers;
        return json;
      }
      /**
       * Get Categories
       */
      getCategories(categories) {
        if (typeof categories === "undefined") {
          throw new Error("Array of strings expected for `categories`");
        }
        if (!this._isValidArrayOfStrings(categories)) {
          throw new Error("Array of strings expected for `categories`");
        }
        const json = this.getGlobal();
        json.categories = categories;
        return json;
      }
      /**
       * Get Subuser
       */
      getSubuser(subusers) {
        if (typeof subusers === "undefined") {
          throw new Error("Array of strings expected for `subusers`");
        }
        if (!this._isValidArrayOfStrings(subusers)) {
          throw new Error("Array of strings expected for `subusers`");
        }
        const json = this.getGlobal();
        json.subusers = subusers;
        return json;
      }
      /**
       * Get Subuser Sum
       */
      getSubuserSum(sortByMetric = "delivered", sortByDirection = SortByDirection[0], limit = 5, offset2 = 0) {
        if (typeof sortByMetric !== "string") {
          throw new Error("string expected for `sortByMetric`");
        }
        if (!SortByDirection.includes(sortByDirection.toLowerCase())) {
          throw new Error("desc or asc expected for `sortByDirection`");
        }
        if (typeof limit !== "number") {
          throw new Error("number expected for `limit`");
        }
        if (typeof offset2 !== "number") {
          throw new Error("number expected for `offset`");
        }
        const json = this.getGlobal();
        json.sortByMetric = sortByMetric;
        json.sortByDirection = sortByDirection;
        json.limit = limit;
        json.offset = offset2;
        return json;
      }
      /**
       * Get Subuser Monthly
       */
      getSubuserMonthly(sortByMetric = "delivered", sortByDirection = SortByDirection[0], limit = 5, offset2 = 0) {
        if (typeof sortByMetric !== "string") {
          throw new Error("string expected for `sortByMetric`");
        }
        if (!SortByDirection.includes(sortByDirection.toLowerCase())) {
          throw new Error("desc or asc expected for `sortByDirection`");
        }
        if (typeof limit !== "number") {
          throw new Error("number expected for `limit`");
        }
        if (typeof offset2 !== "number") {
          throw new Error("number expected for `offset`");
        }
        const json = this.getGlobal();
        json.sortByMetric = sortByMetric;
        json.sortByDirection = sortByDirection;
        json.limit = limit;
        json.offset = offset2;
        return json;
      }
      _isValidArrayOfStrings(arr2) {
        if (!Array.isArray(arr2)) {
          return false;
        }
        if (arr2.length < 1 || arr2.some((x) => typeof x !== "string")) {
          return false;
        }
        return true;
      }
    };
    module2.exports = Statistics;
  }
});

// ../../../node_modules/@sendgrid/helpers/classes/index.js
var require_classes = __commonJS({
  "../../../node_modules/@sendgrid/helpers/classes/index.js"(exports, module2) {
    "use strict";
    var Attachment = require_attachment();
    var EmailAddress = require_email_address();
    var Mail = require_mail();
    var Personalization = require_personalization();
    var Response2 = require_response();
    var ResponseError = require_response_error();
    var Statistics = require_statistics();
    module2.exports = {
      Attachment,
      EmailAddress,
      Mail,
      Personalization,
      Response: Response2,
      ResponseError,
      Statistics
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/merge-data.js
var require_merge_data = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/merge-data.js"(exports, module2) {
    "use strict";
    module2.exports = function mergeData(base, data) {
      if (typeof base !== "object" || base === null) {
        throw new Error("Not an object provided for base");
      }
      if (typeof data !== "object" || data === null) {
        throw new Error("Not an object provided for data");
      }
      const merged = Object.assign({}, base);
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          if (data[key] && Array.isArray(data[key])) {
            merged[key] = data[key];
          } else if (data[key] && typeof data[key] === "object") {
            merged[key] = Object.assign({}, data[key]);
          } else if (data[key]) {
            merged[key] = data[key];
          }
        }
      }
      return merged;
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/helpers/index.js
var require_helpers = __commonJS({
  "../../../node_modules/@sendgrid/helpers/helpers/index.js"(exports, module2) {
    "use strict";
    var arrayToJSON = require_array_to_json();
    var convertKeys = require_convert_keys();
    var deepClone = require_deep_clone();
    var mergeData = require_merge_data();
    var splitNameEmail = require_split_name_email();
    var toCamelCase = require_to_camel_case();
    var toSnakeCase = require_to_snake_case();
    var wrapSubstitutions = require_wrap_substitutions();
    module2.exports = {
      arrayToJSON,
      convertKeys,
      deepClone,
      mergeData,
      splitNameEmail,
      toCamelCase,
      toSnakeCase,
      wrapSubstitutions
    };
  }
});

// ../../../node_modules/@sendgrid/helpers/index.js
var require_helpers2 = __commonJS({
  "../../../node_modules/@sendgrid/helpers/index.js"(exports, module2) {
    "use strict";
    var classes = require_classes();
    var helpers = require_helpers();
    module2.exports = { classes, helpers };
  }
});

// ../../../node_modules/@sendgrid/client/src/classes/client.js
var require_client = __commonJS({
  "../../../node_modules/@sendgrid/client/src/classes/client.js"(exports, module2) {
    "use strict";
    var axios = require_axios();
    var pkg = require_package();
    var {
      helpers: {
        mergeData
      },
      classes: {
        Response: Response2,
        ResponseError
      }
    } = require_helpers2();
    var API_KEY_PREFIX = "SG.";
    var SENDGRID_BASE_URL = "https://api.sendgrid.com/";
    var TWILIO_BASE_URL = "https://email.twilio.com/";
    var SENDGRID_REGION = "global";
    var REGION_HOST_MAP = {
      eu: "https://api.eu.sendgrid.com/",
      global: "https://api.sendgrid.com/"
    };
    var Client = class {
      constructor() {
        this.auth = "";
        this.impersonateSubuser = "";
        this.sendgrid_region = SENDGRID_REGION;
        this.defaultHeaders = {
          Accept: "application/json",
          "Content-Type": "application/json",
          "User-Agent": "sendgrid/" + pkg.version + ";nodejs"
        };
        this.defaultRequest = {
          baseUrl: SENDGRID_BASE_URL,
          url: "",
          method: "GET",
          headers: {},
          maxContentLength: Infinity,
          // Don't limit the content length.
          maxBodyLength: Infinity
        };
      }
      setApiKey(apiKey) {
        this.auth = "Bearer " + apiKey;
        this.setDefaultRequest("baseUrl", REGION_HOST_MAP[this.sendgrid_region]);
        if (!this.isValidApiKey(apiKey)) {
          console.warn(`API key does not start with "${API_KEY_PREFIX}".`);
        }
      }
      setTwilioEmailAuth(username, password) {
        const b64Auth = Buffer.from(username + ":" + password).toString("base64");
        this.auth = "Basic " + b64Auth;
        this.setDefaultRequest("baseUrl", TWILIO_BASE_URL);
        if (!this.isValidTwilioAuth(username, password)) {
          console.warn("Twilio Email credentials must be non-empty strings.");
        }
      }
      isValidApiKey(apiKey) {
        return this.isString(apiKey) && apiKey.trim().startsWith(API_KEY_PREFIX);
      }
      isValidTwilioAuth(username, password) {
        return this.isString(username) && username && this.isString(password) && password;
      }
      isString(value) {
        return typeof value === "string" || value instanceof String;
      }
      setImpersonateSubuser(subuser) {
        this.impersonateSubuser = subuser;
      }
      setDefaultHeader(key, value) {
        if (key !== null && typeof key === "object") {
          Object.assign(this.defaultHeaders, key);
          return this;
        }
        this.defaultHeaders[key] = value;
        return this;
      }
      setDefaultRequest(key, value) {
        if (key !== null && typeof key === "object") {
          Object.assign(this.defaultRequest, key);
          return this;
        }
        this.defaultRequest[key] = value;
        return this;
      }
      /**
       * Global is the default residency (or region)
       * Global region means the message will be sent through https://api.sendgrid.com
       * EU region means the message will be sent through https://api.eu.sendgrid.com
       **/
      setDataResidency(region) {
        if (!REGION_HOST_MAP.hasOwnProperty(region)) {
          console.warn('Region can only be "global" or "eu".');
        } else {
          this.sendgrid_region = region;
          this.setDefaultRequest("baseUrl", REGION_HOST_MAP[region]);
        }
        return this;
      }
      createHeaders(data) {
        const headers = mergeData(this.defaultHeaders, data);
        if (typeof headers.Authorization === "undefined" && this.auth) {
          headers.Authorization = this.auth;
        }
        if (this.impersonateSubuser) {
          headers["On-Behalf-Of"] = this.impersonateSubuser;
        }
        return headers;
      }
      createRequest(data) {
        let options = {
          url: data.uri || data.url,
          baseUrl: data.baseUrl,
          method: data.method,
          data: data.body,
          params: data.qs,
          headers: data.headers
        };
        options = mergeData(this.defaultRequest, options);
        options.headers = this.createHeaders(options.headers);
        options.baseURL = options.baseUrl;
        delete options.baseUrl;
        return options;
      }
      request(data, cb) {
        data = this.createRequest(data);
        const promise = new Promise((resolve, reject) => {
          axios(data).then((response) => {
            return resolve([
              new Response2(response.status, response.data, response.headers),
              response.data
            ]);
          }).catch((error) => {
            if (error.response) {
              if (error.response.status >= 400) {
                return reject(new ResponseError(error.response));
              }
            }
            return reject(error);
          });
        });
        if (cb && typeof cb !== "function") {
          throw new Error("Callback passed is not a function.");
        }
        if (cb) {
          return promise.then((result) => cb(null, result)).catch((error) => cb(error, null));
        }
        return promise;
      }
    };
    module2.exports = Client;
  }
});

// ../../../node_modules/@sendgrid/client/src/client.js
var require_client2 = __commonJS({
  "../../../node_modules/@sendgrid/client/src/client.js"(exports, module2) {
    "use strict";
    var Client = require_client();
    module2.exports = new Client();
  }
});

// ../../../node_modules/@sendgrid/client/index.js
var require_client3 = __commonJS({
  "../../../node_modules/@sendgrid/client/index.js"(exports, module2) {
    "use strict";
    var client = require_client2();
    var Client = require_client();
    module2.exports = client;
    module2.exports.Client = Client;
  }
});

// ../../../node_modules/@sendgrid/mail/src/classes/mail-service.js
var require_mail_service = __commonJS({
  "../../../node_modules/@sendgrid/mail/src/classes/mail-service.js"(exports, module2) {
    "use strict";
    var { Client } = require_client3();
    var { classes: { Mail } } = require_helpers2();
    var MailService = class {
      /**
       * Constructor
       */
      constructor() {
        this.setClient(new Client());
        this.setSubstitutionWrappers("{{", "}}");
        this.secretRules = [];
      }
      /**
       * Set client
       */
      setClient(client) {
        this.client = client;
        return this;
      }
      /**
       * SendGrid API key passthrough for convenience.
       */
      setApiKey(apiKey) {
        this.client.setApiKey(apiKey);
        return this;
      }
      /**
       * Twilio Email Auth passthrough for convenience.
       */
      setTwilioEmailAuth(username, password) {
        this.client.setTwilioEmailAuth(username, password);
      }
      /**
       * Set client timeout
       */
      setTimeout(timeout) {
        if (typeof timeout === "undefined") {
          return;
        }
        this.client.setDefaultRequest("timeout", timeout);
      }
      /**
       * Set substitution wrappers
       */
      setSubstitutionWrappers(left, right) {
        if (typeof left === "undefined" || typeof right === "undefined") {
          throw new Error("Must provide both left and right side wrappers");
        }
        if (!Array.isArray(this.substitutionWrappers)) {
          this.substitutionWrappers = [];
        }
        this.substitutionWrappers[0] = left;
        this.substitutionWrappers[1] = right;
        return this;
      }
      /**
       * Set secret rules for filtering the e-mail content
       */
      setSecretRules(rules) {
        if (!(rules instanceof Array)) {
          rules = [rules];
        }
        const tmpRules = rules.map(function(rule) {
          const ruleType = typeof rule;
          if (ruleType === "string") {
            return {
              pattern: new RegExp(rule)
            };
          } else if (ruleType === "object") {
            if (rule instanceof RegExp) {
              rule = {
                pattern: rule
              };
            } else if (rule.hasOwnProperty("pattern") && typeof rule.pattern === "string") {
              rule.pattern = new RegExp(rule.pattern);
            }
            try {
              rule.pattern.test("");
              return rule;
            } catch (err) {
            }
          }
        });
        this.secretRules = tmpRules.filter(function(val) {
          return val;
        });
      }
      /**
       * Check if the e-mail is safe to be sent
       */
      filterSecrets(body) {
        if (typeof body === "object" && !body.hasOwnProperty("content")) {
          return;
        }
        const self2 = this;
        body.content.forEach(function(data) {
          self2.secretRules.forEach(function(rule) {
            if (rule.hasOwnProperty("pattern") && !rule.pattern.test(data.value)) {
              return;
            }
            let message = `The pattern '${rule.pattern}'`;
            if (rule.name) {
              message += `identified by '${rule.name}'`;
            }
            message += " was found in the Mail content!";
            throw new Error(message);
          });
        });
      }
      /**
       * Send email
       */
      send(data, isMultiple = false, cb) {
        if (typeof isMultiple === "function") {
          cb = isMultiple;
          isMultiple = false;
        }
        if (Array.isArray(data)) {
          const promise = Promise.all(data.map((item) => {
            return this.send(item, isMultiple);
          }));
          if (cb) {
            promise.then((result) => cb(null, result)).catch((error) => cb(error, null));
          }
          return promise;
        }
        try {
          if (typeof data.isMultiple === "undefined") {
            data.isMultiple = isMultiple;
          }
          if (typeof data.substitutionWrappers === "undefined") {
            data.substitutionWrappers = this.substitutionWrappers;
          }
          const mail = Mail.create(data);
          const body = mail.toJSON();
          this.filterSecrets(body);
          const request = {
            method: "POST",
            url: "/v3/mail/send",
            headers: mail.headers,
            body
          };
          return this.client.request(request, cb);
        } catch (error) {
          if (cb) {
            cb(error, null);
          }
          return Promise.reject(error);
        }
      }
      /**
       * Send multiple emails (shortcut)
       */
      sendMultiple(data, cb) {
        return this.send(data, true, cb);
      }
    };
    module2.exports = MailService;
  }
});

// ../../../node_modules/@sendgrid/mail/src/mail.js
var require_mail2 = __commonJS({
  "../../../node_modules/@sendgrid/mail/src/mail.js"(exports, module2) {
    "use strict";
    var MailService = require_mail_service();
    module2.exports = new MailService();
  }
});

// ../../../node_modules/@sendgrid/mail/index.js
var require_mail3 = __commonJS({
  "../../../node_modules/@sendgrid/mail/index.js"(exports, module2) {
    "use strict";
    var mailer = require_mail2();
    var MailService = require_mail_service();
    module2.exports = mailer;
    module2.exports.MailService = MailService;
  }
});

// ../../../node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js
var require_lib2 = __commonJS({
  "../../../node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js"(exports, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts)
          opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound)
            x = lowerBound;
          if (x > upperBound)
            x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n2 = S.length;
      const U = [];
      for (let i = 0; i < n2; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n2 - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// ../../../node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js
var require_utils4 = __commonJS({
  "../../../node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js"(exports, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// ../../../node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "../../../node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json"(exports, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// ../../../node_modules/node-fetch/node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "../../../node_modules/node-fetch/node_modules/tr46/index.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s2) {
        return s2.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string2) {
      return string2.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l2) {
        try {
          return punycode.toASCII(l2);
        } catch (e) {
          result.error = true;
          return l2;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// ../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "../../../node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string2) {
      return string2.length === 2 && isASCIIAlpha(string2.codePointAt(0)) && (string2[1] === ":" || string2[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string2) {
      return string2.length === 2 && isASCIIAlpha(string2.codePointAt(0)) && string2[1] === ":";
    }
    function containsForbiddenHostCodePoint(string2) {
      return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string2) {
      return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n2 = parseIPv4Number(part);
        if (n2 === failure) {
          return input;
        }
        numbers.push(n2);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n2 of numbers) {
        ipv4 += n2 * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n2 = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n2 % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n2 = Math.floor(n2 / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr2) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr2.length; ++i) {
        if (arr2[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path2 = url.path;
      if (path2.length === 0) {
        return;
      }
      if (url.scheme === "file" && path2.length === 1 && isNormalizedWindowsDriveLetter(path2[0])) {
        return;
      }
      path2.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string2) {
      return /^[A-Za-z]:$/.test(string2);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string2 of url.path) {
          output += "/" + string2;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// ../../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "../../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// ../../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "../../../node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js"(exports, module2) {
    "use strict";
    var conversions = require_lib2();
    var utils = require_utils4();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// ../../../node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "../../../node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// ../../../node_modules/node-fetch/lib/index.js
var require_lib3 = __commonJS({
  "../../../node_modules/node-fetch/lib/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob2 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob2([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone3(instance2) {
      let p1, p2;
      let body = instance2.body;
      if (instance2.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance2[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance2) {
      const body = instance2.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance2) {
      const body = instance2.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init3 instanceof _Headers) {
          const rawHeaders = init3.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init3 == null)
          ;
        else if (typeof init3 === "object") {
          const method = init3[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init3) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init3)) {
              const value = init3[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index2 = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index2 >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index2 + 1;
        return {
          value: values[index2],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response2 = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone3(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response2.prototype);
    Object.defineProperties(Response2.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request2 = class _Request {
      constructor(input) {
        let init3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init3.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init3.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init3.body != null ? init3.body : isRequest(input) && input.body !== null ? clone3(input) : null;
        Body.call(this, inputBody, {
          timeout: init3.timeout || input.timeout || 0,
          size: init3.size || input.size || 0
        });
        const headers = new Headers(init3.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init3)
          signal = init3.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init3.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init3.follow !== void 0 ? init3.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init3.compress !== void 0 ? init3.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init3.counter || input.counter || 0;
        this.agent = init3.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request2.prototype);
    Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch3(url, opts) {
      if (!fetch3.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch3.Promise;
      return new fetch3.Promise(function(resolve, reject) {
        const request = new Request2(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream.Readable) {
            destroyStream(request.body, error);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          if (response && response.body) {
            destroyStream(response.body, err);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function(s2) {
            s2.addListener("close", function(hadError) {
              const hasDataListener = s2.listenerCount("data") > 0;
              if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                const err = new Error("Premature close");
                err.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err);
              }
            });
          });
        }
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch3.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch3(new Request2(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response2(body, response_options);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response2(body, response_options);
            resolve(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response2(body, response_options);
              resolve(response);
            });
            raw.on("end", function() {
              if (!response) {
                response = new Response2(body, response_options);
                resolve(response);
              }
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response2(body, response_options);
            resolve(response);
            return;
          }
          response = new Response2(body, response_options);
          resolve(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function(s2) {
        socket = s2;
      });
      request.on("response", function(response) {
        const headers = response.headers;
        if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
          response.once("close", function(hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err);
            }
          });
        }
      });
    }
    function destroyStream(stream, err) {
      if (stream.destroy) {
        stream.destroy(err);
      } else {
        stream.emit("error", err);
        stream.end();
      }
    }
    fetch3.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch3.Promise = global.Promise;
    module2.exports = exports = fetch3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = exports;
    exports.Headers = Headers;
    exports.Request = Request2;
    exports.Response = Response2;
    exports.FetchError = FetchError;
    exports.AbortError = AbortError;
  }
});

// src/appointment/prebook-cancel-appointment/index.ts
var prebook_cancel_appointment_exports = {};
__export(prebook_cancel_appointment_exports, {
  index: () => index
});
module.exports = __toCommonJS(prebook_cancel_appointment_exports);

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/debug-build.js
var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/version.js
var SDK_VERSION = "8.53.0";

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js
var GLOBAL_OBJ = globalThis;
function getGlobalSingleton(name, creator, obj) {
  const gbl = obj || GLOBAL_OBJ;
  const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
  const versionedCarrier = __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
  return versionedCarrier[name] || (versionedCarrier[name] = creator());
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/debug-build.js
var DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/logger.js
var PREFIX = "Sentry Logger ";
var CONSOLE_LEVELS = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
];
var originalConsoleMethods = {};
function consoleSandbox(callback) {
  if (!("console" in GLOBAL_OBJ)) {
    return callback();
  }
  const console2 = GLOBAL_OBJ.console;
  const wrappedFuncs = {};
  const wrappedLevels = Object.keys(originalConsoleMethods);
  wrappedLevels.forEach((level) => {
    const originalConsoleMethod = originalConsoleMethods[level];
    wrappedFuncs[level] = console2[level];
    console2[level] = originalConsoleMethod;
  });
  try {
    return callback();
  } finally {
    wrappedLevels.forEach((level) => {
      console2[level] = wrappedFuncs[level];
    });
  }
}
function makeLogger() {
  let enabled = false;
  const logger2 = {
    enable: () => {
      enabled = true;
    },
    disable: () => {
      enabled = false;
    },
    isEnabled: () => enabled
  };
  if (DEBUG_BUILD2) {
    CONSOLE_LEVELS.forEach((name) => {
      logger2[name] = (...args) => {
        if (enabled) {
          consoleSandbox(() => {
            GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
          });
        }
      };
    });
  } else {
    CONSOLE_LEVELS.forEach((name) => {
      logger2[name] = () => void 0;
    });
  }
  return logger2;
}
var logger = getGlobalSingleton("logger", makeLogger);

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/carrier.js
function getMainCarrier() {
  getSentryCarrier(GLOBAL_OBJ);
  return GLOBAL_OBJ;
}
function getSentryCarrier(carrier) {
  const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
  __SENTRY__.version = __SENTRY__.version || SDK_VERSION;
  return __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/is.js
var objectToString = Object.prototype.toString;
function isBuiltin(wat, className) {
  return objectToString.call(wat) === `[object ${className}]`;
}
function isString(wat) {
  return isBuiltin(wat, "String");
}
function isPlainObject(wat) {
  return isBuiltin(wat, "Object");
}
function isThenable(wat) {
  return Boolean(wat && wat.then && typeof wat.then === "function");
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/object.js
function addNonEnumerableProperty(obj, name, value) {
  try {
    Object.defineProperty(obj, name, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value,
      writable: true,
      configurable: true
    });
  } catch (o_O) {
    DEBUG_BUILD2 && logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
  }
}
function dropUndefinedKeys(inputValue) {
  const memoizationMap = /* @__PURE__ */ new Map();
  return _dropUndefinedKeys(inputValue, memoizationMap);
}
function _dropUndefinedKeys(inputValue, memoizationMap) {
  if (isPojo(inputValue)) {
    const memoVal = memoizationMap.get(inputValue);
    if (memoVal !== void 0) {
      return memoVal;
    }
    const returnValue = {};
    memoizationMap.set(inputValue, returnValue);
    for (const key of Object.getOwnPropertyNames(inputValue)) {
      if (typeof inputValue[key] !== "undefined") {
        returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
      }
    }
    return returnValue;
  }
  if (Array.isArray(inputValue)) {
    const memoVal = memoizationMap.get(inputValue);
    if (memoVal !== void 0) {
      return memoVal;
    }
    const returnValue = [];
    memoizationMap.set(inputValue, returnValue);
    inputValue.forEach((item) => {
      returnValue.push(_dropUndefinedKeys(item, memoizationMap));
    });
    return returnValue;
  }
  return inputValue;
}
function isPojo(input) {
  if (!isPlainObject(input)) {
    return false;
  }
  try {
    const name = Object.getPrototypeOf(input).constructor.name;
    return !name || name === "Object";
  } catch (e2) {
    return true;
  }
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/time.js
var ONE_SECOND_IN_MS = 1e3;
function dateTimestampInSeconds() {
  return Date.now() / ONE_SECOND_IN_MS;
}
function createUnixTimestampInSecondsFunc() {
  const { performance: performance2 } = GLOBAL_OBJ;
  if (!performance2 || !performance2.now) {
    return dateTimestampInSeconds;
  }
  const approxStartingTimeOrigin = Date.now() - performance2.now();
  const timeOrigin = performance2.timeOrigin == void 0 ? approxStartingTimeOrigin : performance2.timeOrigin;
  return () => {
    return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
  };
}
var timestampInSeconds = createUnixTimestampInSecondsFunc();
var _browserPerformanceTimeOriginMode;
var browserPerformanceTimeOrigin = (() => {
  const { performance: performance2 } = GLOBAL_OBJ;
  if (!performance2 || !performance2.now) {
    _browserPerformanceTimeOriginMode = "none";
    return void 0;
  }
  const threshold = 3600 * 1e3;
  const performanceNow = performance2.now();
  const dateNow = Date.now();
  const timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
  const timeOriginIsReliable = timeOriginDelta < threshold;
  const navigationStart = performance2.timing && performance2.timing.navigationStart;
  const hasNavigationStart = typeof navigationStart === "number";
  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
  const navigationStartIsReliable = navigationStartDelta < threshold;
  if (timeOriginIsReliable || navigationStartIsReliable) {
    if (timeOriginDelta <= navigationStartDelta) {
      _browserPerformanceTimeOriginMode = "timeOrigin";
      return performance2.timeOrigin;
    } else {
      _browserPerformanceTimeOriginMode = "navigationStart";
      return navigationStart;
    }
  }
  _browserPerformanceTimeOriginMode = "dateNow";
  return dateNow;
})();

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/misc.js
function uuid4() {
  const gbl = GLOBAL_OBJ;
  const crypto = gbl.crypto || gbl.msCrypto;
  let getRandomByte = () => Math.random() * 16;
  try {
    if (crypto && crypto.randomUUID) {
      return crypto.randomUUID().replace(/-/g, "");
    }
    if (crypto && crypto.getRandomValues) {
      getRandomByte = () => {
        const typedArray = new Uint8Array(1);
        crypto.getRandomValues(typedArray);
        return typedArray[0];
      };
    }
  } catch (_) {
  }
  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(
    /[018]/g,
    (c) => (
      // eslint-disable-next-line no-bitwise
      (c ^ (getRandomByte() & 15) >> c / 4).toString(16)
    )
  );
}
function getFirstException(event) {
  return event.exception && event.exception.values ? event.exception.values[0] : void 0;
}
function addExceptionMechanism(event, newMechanism) {
  const firstException = getFirstException(event);
  if (!firstException) {
    return;
  }
  const defaultMechanism = { type: "generic", handled: true };
  const currentMechanism = firstException.mechanism;
  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
  if (newMechanism && "data" in newMechanism) {
    const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };
    firstException.mechanism.data = mergedData;
  }
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/session.js
function updateSession(session, context = {}) {
  if (context.user) {
    if (!session.ipAddress && context.user.ip_address) {
      session.ipAddress = context.user.ip_address;
    }
    if (!session.did && !context.did) {
      session.did = context.user.id || context.user.email || context.user.username;
    }
  }
  session.timestamp = context.timestamp || timestampInSeconds();
  if (context.abnormal_mechanism) {
    session.abnormal_mechanism = context.abnormal_mechanism;
  }
  if (context.ignoreDuration) {
    session.ignoreDuration = context.ignoreDuration;
  }
  if (context.sid) {
    session.sid = context.sid.length === 32 ? context.sid : uuid4();
  }
  if (context.init !== void 0) {
    session.init = context.init;
  }
  if (!session.did && context.did) {
    session.did = `${context.did}`;
  }
  if (typeof context.started === "number") {
    session.started = context.started;
  }
  if (session.ignoreDuration) {
    session.duration = void 0;
  } else if (typeof context.duration === "number") {
    session.duration = context.duration;
  } else {
    const duration = session.timestamp - session.started;
    session.duration = duration >= 0 ? duration : 0;
  }
  if (context.release) {
    session.release = context.release;
  }
  if (context.environment) {
    session.environment = context.environment;
  }
  if (!session.ipAddress && context.ipAddress) {
    session.ipAddress = context.ipAddress;
  }
  if (!session.userAgent && context.userAgent) {
    session.userAgent = context.userAgent;
  }
  if (typeof context.errors === "number") {
    session.errors = context.errors;
  }
  if (context.status) {
    session.status = context.status;
  }
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/propagationContext.js
function generateTraceId() {
  return uuid4();
}
function generateSpanId() {
  return uuid4().substring(16);
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils/merge.js
function merge(initialObj, mergeObj, levels = 2) {
  if (!mergeObj || typeof mergeObj !== "object" || levels <= 0) {
    return mergeObj;
  }
  if (initialObj && mergeObj && Object.keys(mergeObj).length === 0) {
    return initialObj;
  }
  const output = { ...initialObj };
  for (const key in mergeObj) {
    if (Object.prototype.hasOwnProperty.call(mergeObj, key)) {
      output[key] = merge(output[key], mergeObj[key], levels - 1);
    }
  }
  return output;
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils/spanOnScope.js
var SCOPE_SPAN_FIELD = "_sentrySpan";
function _setSpanForScope(scope, span) {
  if (span) {
    addNonEnumerableProperty(scope, SCOPE_SPAN_FIELD, span);
  } else {
    delete scope[SCOPE_SPAN_FIELD];
  }
}
function _getSpanForScope(scope) {
  return scope[SCOPE_SPAN_FIELD];
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/scope.js
var DEFAULT_MAX_BREADCRUMBS = 100;
var ScopeClass = class _ScopeClass {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called during event processing. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  /**
   * Transaction Name
   *
   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
   */
  /** Session */
  /** Request Mode Session Status */
  // eslint-disable-next-line deprecation/deprecation
  /** The client on this scope */
  /** Contains the last event id of a captured event.  */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = false;
    this._scopeListeners = [];
    this._eventProcessors = [];
    this._breadcrumbs = [];
    this._attachments = [];
    this._user = {};
    this._tags = {};
    this._extra = {};
    this._contexts = {};
    this._sdkProcessingMetadata = {};
    this._propagationContext = {
      traceId: generateTraceId(),
      spanId: generateSpanId()
    };
  }
  /**
   * @inheritDoc
   */
  clone() {
    const newScope = new _ScopeClass();
    newScope._breadcrumbs = [...this._breadcrumbs];
    newScope._tags = { ...this._tags };
    newScope._extra = { ...this._extra };
    newScope._contexts = { ...this._contexts };
    if (this._contexts.flags) {
      newScope._contexts.flags = {
        values: [...this._contexts.flags.values]
      };
    }
    newScope._user = this._user;
    newScope._level = this._level;
    newScope._session = this._session;
    newScope._transactionName = this._transactionName;
    newScope._fingerprint = this._fingerprint;
    newScope._eventProcessors = [...this._eventProcessors];
    newScope._requestSession = this._requestSession;
    newScope._attachments = [...this._attachments];
    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
    newScope._propagationContext = { ...this._propagationContext };
    newScope._client = this._client;
    newScope._lastEventId = this._lastEventId;
    _setSpanForScope(newScope, _getSpanForScope(this));
    return newScope;
  }
  /**
   * @inheritDoc
   */
  setClient(client) {
    this._client = client;
  }
  /**
   * @inheritDoc
   */
  setLastEventId(lastEventId2) {
    this._lastEventId = lastEventId2;
  }
  /**
   * @inheritDoc
   */
  getClient() {
    return this._client;
  }
  /**
   * @inheritDoc
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   */
  addScopeListener(callback) {
    this._scopeListeners.push(callback);
  }
  /**
   * @inheritDoc
   */
  addEventProcessor(callback) {
    this._eventProcessors.push(callback);
    return this;
  }
  /**
   * @inheritDoc
   */
  setUser(user) {
    this._user = user || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      username: void 0
    };
    if (this._session) {
      updateSession(this._session, { user });
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  getUser() {
    return this._user;
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line deprecation/deprecation
  getRequestSession() {
    return this._requestSession;
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line deprecation/deprecation
  setRequestSession(requestSession) {
    this._requestSession = requestSession;
    return this;
  }
  /**
   * @inheritDoc
   */
  setTags(tags) {
    this._tags = {
      ...this._tags,
      ...tags
    };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setTag(key, value) {
    this._tags = { ...this._tags, [key]: value };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setExtras(extras) {
    this._extra = {
      ...this._extra,
      ...extras
    };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setExtra(key, extra) {
    this._extra = { ...this._extra, [key]: extra };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setFingerprint(fingerprint) {
    this._fingerprint = fingerprint;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setLevel(level) {
    this._level = level;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Sets the transaction name on the scope so that the name of e.g. taken server route or
   * the page location is attached to future events.
   *
   * IMPORTANT: Calling this function does NOT change the name of the currently active
   * root span. If you want to change the name of the active root span, use
   * `Sentry.updateSpanName(rootSpan, 'new name')` instead.
   *
   * By default, the SDK updates the scope's transaction name automatically on sensible
   * occasions, such as a page navigation or when handling a new request on the server.
   */
  setTransactionName(name) {
    this._transactionName = name;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setContext(key, context) {
    if (context === null) {
      delete this._contexts[key];
    } else {
      this._contexts[key] = context;
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setSession(session) {
    if (!session) {
      delete this._session;
    } else {
      this._session = session;
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  getSession() {
    return this._session;
  }
  /**
   * @inheritDoc
   */
  update(captureContext) {
    if (!captureContext) {
      return this;
    }
    const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
    const [scopeInstance, requestSession] = scopeToMerge instanceof Scope ? (
      // eslint-disable-next-line deprecation/deprecation
      [scopeToMerge.getScopeData(), scopeToMerge.getRequestSession()]
    ) : isPlainObject(scopeToMerge) ? [captureContext, captureContext.requestSession] : [];
    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};
    this._tags = { ...this._tags, ...tags };
    this._extra = { ...this._extra, ...extra };
    this._contexts = { ...this._contexts, ...contexts };
    if (user && Object.keys(user).length) {
      this._user = user;
    }
    if (level) {
      this._level = level;
    }
    if (fingerprint.length) {
      this._fingerprint = fingerprint;
    }
    if (propagationContext) {
      this._propagationContext = propagationContext;
    }
    if (requestSession) {
      this._requestSession = requestSession;
    }
    return this;
  }
  /**
   * @inheritDoc
   */
  clear() {
    this._breadcrumbs = [];
    this._tags = {};
    this._extra = {};
    this._user = {};
    this._contexts = {};
    this._level = void 0;
    this._transactionName = void 0;
    this._fingerprint = void 0;
    this._requestSession = void 0;
    this._session = void 0;
    _setSpanForScope(this, void 0);
    this._attachments = [];
    this.setPropagationContext({ traceId: generateTraceId() });
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  addBreadcrumb(breadcrumb, maxBreadcrumbs) {
    const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
    if (maxCrumbs <= 0) {
      return this;
    }
    const mergedBreadcrumb = {
      timestamp: dateTimestampInSeconds(),
      ...breadcrumb
    };
    this._breadcrumbs.push(mergedBreadcrumb);
    if (this._breadcrumbs.length > maxCrumbs) {
      this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);
      if (this._client) {
        this._client.recordDroppedEvent("buffer_overflow", "log_item");
      }
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * @inheritDoc
   */
  clearBreadcrumbs() {
    this._breadcrumbs = [];
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  addAttachment(attachment) {
    this._attachments.push(attachment);
    return this;
  }
  /**
   * @inheritDoc
   */
  clearAttachments() {
    this._attachments = [];
    return this;
  }
  /** @inheritDoc */
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: _getSpanForScope(this)
    };
  }
  /**
   * @inheritDoc
   */
  setSDKProcessingMetadata(newData) {
    this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, newData, 2);
    return this;
  }
  /**
   * @inheritDoc
   */
  setPropagationContext(context) {
    this._propagationContext = {
      // eslint-disable-next-line deprecation/deprecation
      spanId: generateSpanId(),
      ...context
    };
    return this;
  }
  /**
   * @inheritDoc
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * @inheritDoc
   */
  captureException(exception, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture exception!");
      return eventId;
    }
    const syntheticException = new Error("Sentry syntheticException");
    this._client.captureException(
      exception,
      {
        originalException: exception,
        syntheticException,
        ...hint,
        event_id: eventId
      },
      this
    );
    return eventId;
  }
  /**
   * @inheritDoc
   */
  captureMessage(message, level, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture message!");
      return eventId;
    }
    const syntheticException = new Error(message);
    this._client.captureMessage(
      message,
      level,
      {
        originalException: message,
        syntheticException,
        ...hint,
        event_id: eventId
      },
      this
    );
    return eventId;
  }
  /**
   * @inheritDoc
   */
  captureEvent(event, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture event!");
      return eventId;
    }
    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
    return eventId;
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    if (!this._notifyingListeners) {
      this._notifyingListeners = true;
      this._scopeListeners.forEach((callback) => {
        callback(this);
      });
      this._notifyingListeners = false;
    }
  }
};
var Scope = ScopeClass;

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/defaultScopes.js
function getDefaultCurrentScope() {
  return getGlobalSingleton("defaultCurrentScope", () => new Scope());
}
function getDefaultIsolationScope() {
  return getGlobalSingleton("defaultIsolationScope", () => new Scope());
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js
var AsyncContextStack = class {
  constructor(scope, isolationScope) {
    let assignedScope;
    if (!scope) {
      assignedScope = new Scope();
    } else {
      assignedScope = scope;
    }
    let assignedIsolationScope;
    if (!isolationScope) {
      assignedIsolationScope = new Scope();
    } else {
      assignedIsolationScope = isolationScope;
    }
    this._stack = [{ scope: assignedScope }];
    this._isolationScope = assignedIsolationScope;
  }
  /**
   * Fork a scope for the stack.
   */
  withScope(callback) {
    const scope = this._pushScope();
    let maybePromiseResult;
    try {
      maybePromiseResult = callback(scope);
    } catch (e) {
      this._popScope();
      throw e;
    }
    if (isThenable(maybePromiseResult)) {
      return maybePromiseResult.then(
        (res) => {
          this._popScope();
          return res;
        },
        (e) => {
          this._popScope();
          throw e;
        }
      );
    }
    this._popScope();
    return maybePromiseResult;
  }
  /**
   * Get the client of the stack.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * Get the isolation scope for the stack.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * Push a scope to the stack.
   */
  _pushScope() {
    const scope = this.getScope().clone();
    this._stack.push({
      client: this.getClient(),
      scope
    });
    return scope;
  }
  /**
   * Pop a scope from the stack.
   */
  _popScope() {
    if (this._stack.length <= 1)
      return false;
    return !!this._stack.pop();
  }
};
function getAsyncContextStack() {
  const registry = getMainCarrier();
  const sentry = getSentryCarrier(registry);
  return sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope());
}
function withScope(callback) {
  return getAsyncContextStack().withScope(callback);
}
function withSetScope(scope, callback) {
  const stack = getAsyncContextStack();
  return stack.withScope(() => {
    stack.getStackTop().scope = scope;
    return callback(scope);
  });
}
function withIsolationScope(callback) {
  return getAsyncContextStack().withScope(() => {
    return callback(getAsyncContextStack().getIsolationScope());
  });
}
function getStackAsyncContextStrategy() {
  return {
    withIsolationScope,
    withScope,
    withSetScope,
    withSetIsolationScope: (_isolationScope, callback) => {
      return withIsolationScope(callback);
    },
    getCurrentScope: () => getAsyncContextStack().getScope(),
    getIsolationScope: () => getAsyncContextStack().getIsolationScope()
  };
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/asyncContext/index.js
function getAsyncContextStrategy(carrier) {
  const sentry = getSentryCarrier(carrier);
  if (sentry.acs) {
    return sentry.acs;
  }
  return getStackAsyncContextStrategy();
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/currentScopes.js
function getCurrentScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getCurrentScope();
}
function getIsolationScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getIsolationScope();
}
function withScope2(...rest) {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (rest.length === 2) {
    const [scope, callback] = rest;
    if (!scope) {
      return acs.withScope(callback);
    }
    return acs.withSetScope(scope, callback);
  }
  return acs.withScope(rest[0]);
}
function getClient() {
  return getCurrentScope().getClient();
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/metrics/metric-summary.js
var METRICS_SPAN_FIELD = "_sentryMetrics";
function getMetricSummaryJsonForSpan(span) {
  const storage = span[METRICS_SPAN_FIELD];
  if (!storage) {
    return void 0;
  }
  const output = {};
  for (const [, [exportKey, summary]] of storage) {
    const arr2 = output[exportKey] || (output[exportKey] = []);
    arr2.push(dropUndefinedKeys(summary));
  }
  return output;
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/semanticAttributes.js
var SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source";
var SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate";
var SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op";
var SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin";
var SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = "sentry.measurement_unit";
var SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = "sentry.measurement_value";
var SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = "sentry.custom_span_name";
var SEMANTIC_ATTRIBUTE_PROFILE_ID = "sentry.profile_id";
var SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = "sentry.exclusive_time";

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/tracing/spanstatus.js
var SPAN_STATUS_UNSET = 0;
var SPAN_STATUS_OK = 1;
var SPAN_STATUS_ERROR = 2;

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/baggage.js
var SENTRY_BAGGAGE_KEY_PREFIX = "sentry-";
var SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;
function baggageHeaderToDynamicSamplingContext(baggageHeader) {
  const baggageObject = parseBaggageHeader(baggageHeader);
  if (!baggageObject) {
    return void 0;
  }
  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
      acc[nonPrefixedKey] = value;
    }
    return acc;
  }, {});
  if (Object.keys(dynamicSamplingContext).length > 0) {
    return dynamicSamplingContext;
  } else {
    return void 0;
  }
}
function parseBaggageHeader(baggageHeader) {
  if (!baggageHeader || !isString(baggageHeader) && !Array.isArray(baggageHeader)) {
    return void 0;
  }
  if (Array.isArray(baggageHeader)) {
    return baggageHeader.reduce((acc, curr) => {
      const currBaggageObject = baggageHeaderToObject(curr);
      Object.entries(currBaggageObject).forEach(([key, value]) => {
        acc[key] = value;
      });
      return acc;
    }, {});
  }
  return baggageHeaderToObject(baggageHeader);
}
function baggageHeaderToObject(baggageHeader) {
  return baggageHeader.split(",").map((baggageEntry) => baggageEntry.split("=").map((keyOrValue) => decodeURIComponent(keyOrValue.trim()))).reduce((acc, [key, value]) => {
    if (key && value) {
      acc[key] = value;
    }
    return acc;
  }, {});
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/tracing.js
var TRACEPARENT_REGEXP = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
  // whitespace
);
function extractTraceparentData(traceparent) {
  if (!traceparent) {
    return void 0;
  }
  const matches = traceparent.match(TRACEPARENT_REGEXP);
  if (!matches) {
    return void 0;
  }
  let parentSampled;
  if (matches[3] === "1") {
    parentSampled = true;
  } else if (matches[3] === "0") {
    parentSampled = false;
  }
  return {
    traceId: matches[1],
    parentSampled,
    parentSpanId: matches[2]
  };
}
function propagationContextFromHeaders(sentryTrace, baggage) {
  const traceparentData = extractTraceparentData(sentryTrace);
  const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);
  if (!traceparentData || !traceparentData.traceId) {
    return { traceId: generateTraceId(), spanId: generateSpanId() };
  }
  const { traceId, parentSpanId, parentSampled } = traceparentData;
  const virtualSpanId = generateSpanId();
  return {
    traceId,
    parentSpanId,
    spanId: virtualSpanId,
    sampled: parentSampled,
    dsc: dynamicSamplingContext || {}
    // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it
  };
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils/spanUtils.js
var TRACE_FLAG_NONE = 0;
var TRACE_FLAG_SAMPLED = 1;
var hasShownSpanDropWarning = false;
function spanToTransactionTraceContext(span) {
  const { spanId: span_id, traceId: trace_id } = span.spanContext();
  const { data, op, parent_span_id, status, origin } = spanToJSON(span);
  return dropUndefinedKeys({
    parent_span_id,
    span_id,
    trace_id,
    data,
    op,
    status,
    origin
  });
}
function spanTimeInputToSeconds(input) {
  if (typeof input === "number") {
    return ensureTimestampInSeconds(input);
  }
  if (Array.isArray(input)) {
    return input[0] + input[1] / 1e9;
  }
  if (input instanceof Date) {
    return ensureTimestampInSeconds(input.getTime());
  }
  return timestampInSeconds();
}
function ensureTimestampInSeconds(timestamp) {
  const isMs = timestamp > 9999999999;
  return isMs ? timestamp / 1e3 : timestamp;
}
function spanToJSON(span) {
  if (spanIsSentrySpan(span)) {
    return span.getSpanJSON();
  }
  try {
    const { spanId: span_id, traceId: trace_id } = span.spanContext();
    if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {
      const { attributes, startTime, name, endTime, parentSpanId, status } = span;
      return dropUndefinedKeys({
        span_id,
        trace_id,
        data: attributes,
        description: name,
        parent_span_id: parentSpanId,
        start_timestamp: spanTimeInputToSeconds(startTime),
        // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
        timestamp: spanTimeInputToSeconds(endTime) || void 0,
        status: getStatusMessage(status),
        op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
        origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
        _metrics_summary: getMetricSummaryJsonForSpan(span)
      });
    }
    return {
      span_id,
      trace_id
    };
  } catch (e) {
    return {};
  }
}
function spanIsOpenTelemetrySdkTraceBaseSpan(span) {
  const castSpan = span;
  return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;
}
function spanIsSentrySpan(span) {
  return typeof span.getSpanJSON === "function";
}
function spanIsSampled(span) {
  const { traceFlags } = span.spanContext();
  return traceFlags === TRACE_FLAG_SAMPLED;
}
function getStatusMessage(status) {
  if (!status || status.code === SPAN_STATUS_UNSET) {
    return void 0;
  }
  if (status.code === SPAN_STATUS_OK) {
    return "ok";
  }
  return status.message || "unknown_error";
}
var CHILD_SPANS_FIELD = "_sentryChildSpans";
var ROOT_SPAN_FIELD = "_sentryRootSpan";
function addChildSpanToSpan(span, childSpan) {
  const rootSpan = span[ROOT_SPAN_FIELD] || span;
  addNonEnumerableProperty(childSpan, ROOT_SPAN_FIELD, rootSpan);
  if (span[CHILD_SPANS_FIELD]) {
    span[CHILD_SPANS_FIELD].add(childSpan);
  } else {
    addNonEnumerableProperty(span, CHILD_SPANS_FIELD, /* @__PURE__ */ new Set([childSpan]));
  }
}
function getSpanDescendants(span) {
  const resultSet = /* @__PURE__ */ new Set();
  function addSpanChildren(span2) {
    if (resultSet.has(span2)) {
      return;
    } else if (spanIsSampled(span2)) {
      resultSet.add(span2);
      const childSpans = span2[CHILD_SPANS_FIELD] ? Array.from(span2[CHILD_SPANS_FIELD]) : [];
      for (const childSpan of childSpans) {
        addSpanChildren(childSpan);
      }
    }
  }
  addSpanChildren(span);
  return Array.from(resultSet);
}
function getRootSpan(span) {
  return span[ROOT_SPAN_FIELD] || span;
}
function showSpanDropWarning() {
  if (!hasShownSpanDropWarning) {
    consoleSandbox(() => {
      console.warn(
        "[Sentry] Deprecation warning: Returning null from `beforeSendSpan` will be disallowed from SDK version 9.0.0 onwards. The callback will only support mutating spans. To drop certain spans, configure the respective integrations directly."
      );
    });
    hasShownSpanDropWarning = true;
  }
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/tracing/utils.js
var SCOPE_ON_START_SPAN_FIELD = "_sentryScope";
var ISOLATION_SCOPE_ON_START_SPAN_FIELD = "_sentryIsolationScope";
function setCapturedScopesOnSpan(span, scope, isolationScope) {
  if (span) {
    addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);
    addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);
  }
}
function getCapturedScopesOnSpan(span) {
  return {
    scope: span[SCOPE_ON_START_SPAN_FIELD],
    isolationScope: span[ISOLATION_SCOPE_ON_START_SPAN_FIELD]
  };
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils/hasTracingEnabled.js
function hasTracingEnabled(maybeOptions) {
  if (typeof __SENTRY_TRACING__ === "boolean" && !__SENTRY_TRACING__) {
    return false;
  }
  const client = getClient();
  const options = maybeOptions || client && client.getOptions();
  return !!options && (options.enableTracing || "tracesSampleRate" in options || "tracesSampler" in options);
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/tracing/sentryNonRecordingSpan.js
var SentryNonRecordingSpan = class {
  constructor(spanContext = {}) {
    this._traceId = spanContext.traceId || generateTraceId();
    this._spanId = spanContext.spanId || generateSpanId();
  }
  /** @inheritdoc */
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: TRACE_FLAG_NONE
    };
  }
  /** @inheritdoc */
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  end(_timestamp) {
  }
  /** @inheritdoc */
  setAttribute(_key, _value) {
    return this;
  }
  /** @inheritdoc */
  setAttributes(_values) {
    return this;
  }
  /** @inheritdoc */
  setStatus(_status) {
    return this;
  }
  /** @inheritdoc */
  updateName(_name) {
    return this;
  }
  /** @inheritdoc */
  isRecording() {
    return false;
  }
  /** @inheritdoc */
  addEvent(_name, _attributesOrStartTime, _startTime) {
    return this;
  }
  /**
   * This should generally not be used,
   * but we need it for being compliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  addLink(_link) {
    return this;
  }
  /**
   * This should generally not be used,
   * but we need it for being compliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  addLinks(_links) {
    return this;
  }
  /**
   * This should generally not be used,
   * but we need it for being compliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  recordException(_exception, _time) {
  }
};

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils/handleCallbackErrors.js
function handleCallbackErrors(fn, onError, onFinally = () => {
}) {
  let maybePromiseResult;
  try {
    maybePromiseResult = fn();
  } catch (e) {
    onError(e);
    onFinally();
    throw e;
  }
  return maybeHandlePromiseRejection(maybePromiseResult, onError, onFinally);
}
function maybeHandlePromiseRejection(value, onError, onFinally) {
  if (isThenable(value)) {
    return value.then(
      (res) => {
        onFinally();
        return res;
      },
      (e) => {
        onError(e);
        onFinally();
        throw e;
      }
    );
  }
  onFinally();
  return value;
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/constants.js
var DEFAULT_ENVIRONMENT = "production";

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js
var FROZEN_DSC_FIELD = "_frozenDsc";
function freezeDscOnSpan(span, dsc) {
  const spanWithMaybeDsc = span;
  addNonEnumerableProperty(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);
}
function getDynamicSamplingContextFromClient(trace_id, client) {
  const options = client.getOptions();
  const { publicKey: public_key } = client.getDsn() || {};
  const dsc = dropUndefinedKeys({
    environment: options.environment || DEFAULT_ENVIRONMENT,
    release: options.release,
    public_key,
    trace_id
  });
  client.emit("createDsc", dsc);
  return dsc;
}
function getDynamicSamplingContextFromSpan(span) {
  const client = getClient();
  if (!client) {
    return {};
  }
  const rootSpan = getRootSpan(span);
  const frozenDsc = rootSpan[FROZEN_DSC_FIELD];
  if (frozenDsc) {
    return frozenDsc;
  }
  const traceState = rootSpan.spanContext().traceState;
  const traceStateDsc = traceState && traceState.get("sentry.dsc");
  const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);
  if (dscOnTraceState) {
    return dscOnTraceState;
  }
  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);
  const jsonSpan = spanToJSON(rootSpan);
  const attributes = jsonSpan.data || {};
  const maybeSampleRate = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
  if (maybeSampleRate != null) {
    dsc.sample_rate = `${maybeSampleRate}`;
  }
  const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
  const name = jsonSpan.description;
  if (source !== "url" && name) {
    dsc.transaction = name;
  }
  if (hasTracingEnabled()) {
    dsc.sampled = String(spanIsSampled(rootSpan));
  }
  client.emit("createDsc", dsc, rootSpan);
  return dsc;
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/tracing/logSpans.js
function logSpanStart(span) {
  if (!DEBUG_BUILD)
    return;
  const { description = "< unknown name >", op = "< unknown op >", parent_span_id: parentSpanId } = spanToJSON(span);
  const { spanId } = span.spanContext();
  const sampled = spanIsSampled(span);
  const rootSpan = getRootSpan(span);
  const isRootSpan = rootSpan === span;
  const header = `[Tracing] Starting ${sampled ? "sampled" : "unsampled"} ${isRootSpan ? "root " : ""}span`;
  const infoParts = [`op: ${op}`, `name: ${description}`, `ID: ${spanId}`];
  if (parentSpanId) {
    infoParts.push(`parent ID: ${parentSpanId}`);
  }
  if (!isRootSpan) {
    const { op: op2, description: description2 } = spanToJSON(rootSpan);
    infoParts.push(`root ID: ${rootSpan.spanContext().spanId}`);
    if (op2) {
      infoParts.push(`root op: ${op2}`);
    }
    if (description2) {
      infoParts.push(`root description: ${description2}`);
    }
  }
  logger.log(`${header}
  ${infoParts.join("\n  ")}`);
}
function logSpanEnd(span) {
  if (!DEBUG_BUILD)
    return;
  const { description = "< unknown name >", op = "< unknown op >" } = spanToJSON(span);
  const { spanId } = span.spanContext();
  const rootSpan = getRootSpan(span);
  const isRootSpan = rootSpan === span;
  const msg = `[Tracing] Finishing "${op}" ${isRootSpan ? "root " : ""}span "${description}" with ID ${spanId}`;
  logger.log(msg);
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils/parseSampleRate.js
function parseSampleRate(sampleRate) {
  if (typeof sampleRate === "boolean") {
    return Number(sampleRate);
  }
  const rate = typeof sampleRate === "string" ? parseFloat(sampleRate) : sampleRate;
  if (typeof rate !== "number" || isNaN(rate) || rate < 0 || rate > 1) {
    DEBUG_BUILD && logger.warn(
      `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
        sampleRate
      )} of type ${JSON.stringify(typeof sampleRate)}.`
    );
    return void 0;
  }
  return rate;
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/tracing/sampling.js
function sampleSpan(options, samplingContext) {
  if (!hasTracingEnabled(options)) {
    return [false];
  }
  const normalizedRequest = getIsolationScope().getScopeData().sdkProcessingMetadata.normalizedRequest;
  const enhancedSamplingContext = {
    ...samplingContext,
    normalizedRequest: samplingContext.normalizedRequest || normalizedRequest
  };
  let sampleRate;
  if (typeof options.tracesSampler === "function") {
    sampleRate = options.tracesSampler(enhancedSamplingContext);
  } else if (enhancedSamplingContext.parentSampled !== void 0) {
    sampleRate = enhancedSamplingContext.parentSampled;
  } else if (typeof options.tracesSampleRate !== "undefined") {
    sampleRate = options.tracesSampleRate;
  } else {
    sampleRate = 1;
  }
  const parsedSampleRate = parseSampleRate(sampleRate);
  if (parsedSampleRate === void 0) {
    DEBUG_BUILD && logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
    return [false];
  }
  if (!parsedSampleRate) {
    DEBUG_BUILD && logger.log(
      `[Tracing] Discarding transaction because ${typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
    );
    return [false, parsedSampleRate];
  }
  const shouldSample = Math.random() < parsedSampleRate;
  if (!shouldSample) {
    DEBUG_BUILD && logger.log(
      `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
        sampleRate
      )})`
    );
    return [false, parsedSampleRate];
  }
  return [true, parsedSampleRate];
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/dsn.js
function dsnToString(dsn, withPassword = false) {
  const { host, path: path2, pass, port, projectId, protocol, publicKey } = dsn;
  return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host}${port ? `:${port}` : ""}/${path2 ? `${path2}/` : path2}${projectId}`;
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils-hoist/envelope.js
function createEnvelope(headers, items = []) {
  return [headers, items];
}
function createSpanEnvelopeItem(spanJson) {
  const spanHeaders = {
    type: "span"
  };
  return [spanHeaders, spanJson];
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/envelope.js
function createSpanEnvelope(spans, client) {
  function dscHasRequiredProps(dsc2) {
    return !!dsc2.trace_id && !!dsc2.public_key;
  }
  const dsc = getDynamicSamplingContextFromSpan(spans[0]);
  const dsn = client && client.getDsn();
  const tunnel = client && client.getOptions().tunnel;
  const headers = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...dscHasRequiredProps(dsc) && { trace: dsc },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
  };
  const beforeSendSpan = client && client.getOptions().beforeSendSpan;
  const convertToSpanJSON = beforeSendSpan ? (span) => {
    const spanJson = beforeSendSpan(spanToJSON(span));
    if (!spanJson) {
      showSpanDropWarning();
    }
    return spanJson;
  } : (span) => spanToJSON(span);
  const items = [];
  for (const span of spans) {
    const spanJson = convertToSpanJSON(span);
    if (spanJson) {
      items.push(createSpanEnvelopeItem(spanJson));
    }
  }
  return createEnvelope(headers, items);
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/tracing/measurement.js
function timedEventsToMeasurements(events) {
  if (!events || events.length === 0) {
    return void 0;
  }
  const measurements = {};
  events.forEach((event) => {
    const attributes = event.attributes || {};
    const unit = attributes[SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT];
    const value = attributes[SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE];
    if (typeof unit === "string" && typeof value === "number") {
      measurements[event.name] = { value, unit };
    }
  });
  return measurements;
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/tracing/sentrySpan.js
var MAX_SPAN_COUNT = 1e3;
var SentrySpan = class {
  /** Epoch timestamp in seconds when the span started. */
  /** Epoch timestamp in seconds when the span ended. */
  /** Internal keeper of the status */
  /** The timed events added to this span. */
  /** if true, treat span as a standalone span (not part of a transaction) */
  /**
   * You should never call the constructor manually, always use `Sentry.startSpan()`
   * or other span methods.
   * @internal
   * @hideconstructor
   * @hidden
   */
  constructor(spanContext = {}) {
    this._traceId = spanContext.traceId || generateTraceId();
    this._spanId = spanContext.spanId || generateSpanId();
    this._startTime = spanContext.startTimestamp || timestampInSeconds();
    this._attributes = {};
    this.setAttributes({
      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "manual",
      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,
      ...spanContext.attributes
    });
    this._name = spanContext.name;
    if (spanContext.parentSpanId) {
      this._parentSpanId = spanContext.parentSpanId;
    }
    if ("sampled" in spanContext) {
      this._sampled = spanContext.sampled;
    }
    if (spanContext.endTimestamp) {
      this._endTime = spanContext.endTimestamp;
    }
    this._events = [];
    this._isStandaloneSpan = spanContext.isStandalone;
    if (this._endTime) {
      this._onSpanEnded();
    }
  }
  /**
   * This should generally not be used,
   * but it is needed for being compliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  addLink(_link) {
    return this;
  }
  /**
   * This should generally not be used,
   * but it is needed for being compliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  addLinks(_links) {
    return this;
  }
  /**
   * This should generally not be used,
   * but it is needed for being compliant with the OTEL Span interface.
   *
   * @hidden
   * @internal
   */
  recordException(_exception, _time) {
  }
  /** @inheritdoc */
  spanContext() {
    const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;
    return {
      spanId,
      traceId,
      traceFlags: sampled ? TRACE_FLAG_SAMPLED : TRACE_FLAG_NONE
    };
  }
  /** @inheritdoc */
  setAttribute(key, value) {
    if (value === void 0) {
      delete this._attributes[key];
    } else {
      this._attributes[key] = value;
    }
    return this;
  }
  /** @inheritdoc */
  setAttributes(attributes) {
    Object.keys(attributes).forEach((key) => this.setAttribute(key, attributes[key]));
    return this;
  }
  /**
   * This should generally not be used,
   * but we need it for browser tracing where we want to adjust the start time afterwards.
   * USE THIS WITH CAUTION!
   *
   * @hidden
   * @internal
   */
  updateStartTime(timeInput) {
    this._startTime = spanTimeInputToSeconds(timeInput);
  }
  /**
   * @inheritDoc
   */
  setStatus(value) {
    this._status = value;
    return this;
  }
  /**
   * @inheritDoc
   */
  updateName(name) {
    this._name = name;
    this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, "custom");
    return this;
  }
  /** @inheritdoc */
  end(endTimestamp) {
    if (this._endTime) {
      return;
    }
    this._endTime = spanTimeInputToSeconds(endTimestamp);
    logSpanEnd(this);
    this._onSpanEnded();
  }
  /**
   * Get JSON representation of this span.
   *
   * @hidden
   * @internal This method is purely for internal purposes and should not be used outside
   * of SDK code. If you need to get a JSON representation of a span,
   * use `spanToJSON(span)` instead.
   */
  getSpanJSON() {
    return dropUndefinedKeys({
      data: this._attributes,
      description: this._name,
      op: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: getStatusMessage(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
      _metrics_summary: getMetricSummaryJsonForSpan(this),
      profile_id: this._attributes[SEMANTIC_ATTRIBUTE_PROFILE_ID],
      exclusive_time: this._attributes[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],
      measurements: timedEventsToMeasurements(this._events),
      is_segment: this._isStandaloneSpan && getRootSpan(this) === this || void 0,
      segment_id: this._isStandaloneSpan ? getRootSpan(this).spanContext().spanId : void 0
    });
  }
  /** @inheritdoc */
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  /**
   * @inheritdoc
   */
  addEvent(name, attributesOrStartTime, startTime) {
    DEBUG_BUILD && logger.log("[Tracing] Adding an event to span:", name);
    const time = isSpanTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime || timestampInSeconds();
    const attributes = isSpanTimeInput(attributesOrStartTime) ? {} : attributesOrStartTime || {};
    const event = {
      name,
      time: spanTimeInputToSeconds(time),
      attributes
    };
    this._events.push(event);
    return this;
  }
  /**
   * This method should generally not be used,
   * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.
   * USE THIS WITH CAUTION!
   * @internal
   * @hidden
   * @experimental
   */
  isStandaloneSpan() {
    return !!this._isStandaloneSpan;
  }
  /** Emit `spanEnd` when the span is ended. */
  _onSpanEnded() {
    const client = getClient();
    if (client) {
      client.emit("spanEnd", this);
    }
    const isSegmentSpan = this._isStandaloneSpan || this === getRootSpan(this);
    if (!isSegmentSpan) {
      return;
    }
    if (this._isStandaloneSpan) {
      if (this._sampled) {
        sendSpanEnvelope(createSpanEnvelope([this], client));
      } else {
        DEBUG_BUILD && logger.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled.");
        if (client) {
          client.recordDroppedEvent("sample_rate", "span");
        }
      }
      return;
    }
    const transactionEvent = this._convertSpanToTransaction();
    if (transactionEvent) {
      const scope = getCapturedScopesOnSpan(this).scope || getCurrentScope();
      scope.captureEvent(transactionEvent);
    }
  }
  /**
   * Finish the transaction & prepare the event to send to Sentry.
   */
  _convertSpanToTransaction() {
    if (!isFullFinishedSpan(spanToJSON(this))) {
      return void 0;
    }
    if (!this._name) {
      DEBUG_BUILD && logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
      this._name = "<unlabeled transaction>";
    }
    const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = getCapturedScopesOnSpan(this);
    const scope = capturedSpanScope || getCurrentScope();
    const client = scope.getClient() || getClient();
    if (this._sampled !== true) {
      DEBUG_BUILD && logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
      if (client) {
        client.recordDroppedEvent("sample_rate", "transaction");
      }
      return void 0;
    }
    const finishedSpans = getSpanDescendants(this).filter((span) => span !== this && !isStandaloneSpan(span));
    const spans = finishedSpans.map((span) => spanToJSON(span)).filter(isFullFinishedSpan);
    const source = this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
    delete this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
    spans.forEach((span) => {
      span.data && delete span.data[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
    });
    const transaction2 = {
      contexts: {
        trace: spanToTransactionTraceContext(this)
      },
      spans: (
        // spans.sort() mutates the array, but `spans` is already a copy so we can safely do this here
        // we do not use spans anymore after this point
        spans.length > MAX_SPAN_COUNT ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT) : spans
      ),
      start_timestamp: this._startTime,
      timestamp: this._endTime,
      transaction: this._name,
      type: "transaction",
      sdkProcessingMetadata: {
        capturedSpanScope,
        capturedSpanIsolationScope,
        ...dropUndefinedKeys({
          dynamicSamplingContext: getDynamicSamplingContextFromSpan(this)
        })
      },
      _metrics_summary: getMetricSummaryJsonForSpan(this),
      ...source && {
        transaction_info: {
          source
        }
      }
    };
    const measurements = timedEventsToMeasurements(this._events);
    const hasMeasurements = measurements && Object.keys(measurements).length;
    if (hasMeasurements) {
      DEBUG_BUILD && logger.log(
        "[Measurements] Adding measurements to transaction event",
        JSON.stringify(measurements, void 0, 2)
      );
      transaction2.measurements = measurements;
    }
    return transaction2;
  }
};
function isSpanTimeInput(value) {
  return value && typeof value === "number" || value instanceof Date || Array.isArray(value);
}
function isFullFinishedSpan(input) {
  return !!input.start_timestamp && !!input.timestamp && !!input.span_id && !!input.trace_id;
}
function isStandaloneSpan(span) {
  return span instanceof SentrySpan && span.isStandaloneSpan();
}
function sendSpanEnvelope(envelope) {
  const client = getClient();
  if (!client) {
    return;
  }
  const spanItems = envelope[1];
  if (!spanItems || spanItems.length === 0) {
    client.recordDroppedEvent("before_send", "span");
    return;
  }
  client.sendEnvelope(envelope);
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/tracing/trace.js
var SUPPRESS_TRACING_KEY = "__SENTRY_SUPPRESS_TRACING__";
function startSpanManual(options, callback) {
  const acs = getAcs();
  if (acs.startSpanManual) {
    return acs.startSpanManual(options, callback);
  }
  const spanArguments = parseSentrySpanArguments(options);
  const { forceTransaction, parentSpan: customParentSpan } = options;
  return withScope2(options.scope, () => {
    const wrapper = getActiveSpanWrapper(customParentSpan);
    return wrapper(() => {
      const scope = getCurrentScope();
      const parentSpan = getParentSpan(scope);
      const shouldSkipSpan = options.onlyIfParent && !parentSpan;
      const activeSpan = shouldSkipSpan ? new SentryNonRecordingSpan() : createChildOrRootSpan({
        parentSpan,
        spanArguments,
        forceTransaction,
        scope
      });
      _setSpanForScope(scope, activeSpan);
      function finishAndSetSpan() {
        activeSpan.end();
      }
      return handleCallbackErrors(
        () => callback(activeSpan, finishAndSetSpan),
        () => {
          const { status } = spanToJSON(activeSpan);
          if (activeSpan.isRecording() && (!status || status === "ok")) {
            activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: "internal_error" });
          }
        }
      );
    });
  });
}
var continueTrace = (options, callback) => {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (acs.continueTrace) {
    return acs.continueTrace(options, callback);
  }
  const { sentryTrace, baggage } = options;
  return withScope2((scope) => {
    const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);
    scope.setPropagationContext(propagationContext);
    return callback();
  });
};
function withActiveSpan(span, callback) {
  const acs = getAcs();
  if (acs.withActiveSpan) {
    return acs.withActiveSpan(span, callback);
  }
  return withScope2((scope) => {
    _setSpanForScope(scope, span || void 0);
    return callback(scope);
  });
}
function createChildOrRootSpan({
  parentSpan,
  spanArguments,
  forceTransaction,
  scope
}) {
  if (!hasTracingEnabled()) {
    return new SentryNonRecordingSpan();
  }
  const isolationScope = getIsolationScope();
  let span;
  if (parentSpan && !forceTransaction) {
    span = _startChildSpan(parentSpan, scope, spanArguments);
    addChildSpanToSpan(parentSpan, span);
  } else if (parentSpan) {
    const dsc = getDynamicSamplingContextFromSpan(parentSpan);
    const { traceId, spanId: parentSpanId } = parentSpan.spanContext();
    const parentSampled = spanIsSampled(parentSpan);
    span = _startRootSpan(
      {
        traceId,
        parentSpanId,
        ...spanArguments
      },
      scope,
      parentSampled
    );
    freezeDscOnSpan(span, dsc);
  } else {
    const {
      traceId,
      dsc,
      parentSpanId,
      sampled: parentSampled
    } = {
      ...isolationScope.getPropagationContext(),
      ...scope.getPropagationContext()
    };
    span = _startRootSpan(
      {
        traceId,
        parentSpanId,
        ...spanArguments
      },
      scope,
      parentSampled
    );
    if (dsc) {
      freezeDscOnSpan(span, dsc);
    }
  }
  logSpanStart(span);
  setCapturedScopesOnSpan(span, scope, isolationScope);
  return span;
}
function parseSentrySpanArguments(options) {
  const exp = options.experimental || {};
  const initialCtx = {
    isStandalone: exp.standalone,
    ...options
  };
  if (options.startTime) {
    const ctx = { ...initialCtx };
    ctx.startTimestamp = spanTimeInputToSeconds(options.startTime);
    delete ctx.startTime;
    return ctx;
  }
  return initialCtx;
}
function getAcs() {
  const carrier = getMainCarrier();
  return getAsyncContextStrategy(carrier);
}
function _startRootSpan(spanArguments, scope, parentSampled) {
  const client = getClient();
  const options = client && client.getOptions() || {};
  const { name = "", attributes } = spanArguments;
  const [sampled, sampleRate] = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? [false] : sampleSpan(options, {
    name,
    parentSampled,
    attributes,
    transactionContext: {
      name,
      parentSampled
    }
  });
  const rootSpan = new SentrySpan({
    ...spanArguments,
    attributes: {
      [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "custom",
      ...spanArguments.attributes
    },
    sampled
  });
  if (sampleRate !== void 0) {
    rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, sampleRate);
  }
  if (client) {
    client.emit("spanStart", rootSpan);
  }
  return rootSpan;
}
function _startChildSpan(parentSpan, scope, spanArguments) {
  const { spanId, traceId } = parentSpan.spanContext();
  const sampled = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? false : spanIsSampled(parentSpan);
  const childSpan = sampled ? new SentrySpan({
    ...spanArguments,
    parentSpanId: spanId,
    traceId,
    sampled
  }) : new SentryNonRecordingSpan({ traceId });
  addChildSpanToSpan(parentSpan, childSpan);
  const client = getClient();
  if (client) {
    client.emit("spanStart", childSpan);
    if (spanArguments.endTimestamp) {
      client.emit("spanEnd", childSpan);
    }
  }
  return childSpan;
}
function getParentSpan(scope) {
  const span = _getSpanForScope(scope);
  if (!span) {
    return void 0;
  }
  const client = getClient();
  const options = client ? client.getOptions() : {};
  if (options.parentSpanIsAlwaysRootSpan) {
    return getRootSpan(span);
  }
  return span;
}
function getActiveSpanWrapper(parentSpan) {
  return parentSpan !== void 0 ? (callback) => {
    return withActiveSpan(parentSpan, callback);
  } : (callback) => callback();
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/utils/prepareEvent.js
function parseEventHintOrCaptureContext(hint) {
  if (!hint) {
    return void 0;
  }
  if (hintIsScopeOrFunction(hint)) {
    return { captureContext: hint };
  }
  if (hintIsScopeContext(hint)) {
    return {
      captureContext: hint
    };
  }
  return hint;
}
function hintIsScopeOrFunction(hint) {
  return hint instanceof Scope || typeof hint === "function";
}
var captureContextKeys = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext"
];
function hintIsScopeContext(hint) {
  return Object.keys(hint).some((key) => captureContextKeys.includes(key));
}

// ../../../node_modules/@sentry/aws-serverless/node_modules/@sentry/core/build/esm/exports.js
function captureException(exception, hint) {
  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));
}
function captureMessage(message, captureContext) {
  const level = typeof captureContext === "string" ? captureContext : void 0;
  const context = typeof captureContext !== "string" ? { captureContext } : void 0;
  return getCurrentScope().captureMessage(message, level, context);
}
function setTag(key, value) {
  getIsolationScope().setTag(key, value);
}
async function flush(timeout) {
  const client = getClient();
  if (client) {
    return client.flush(timeout);
  }
  DEBUG_BUILD && logger.warn("Cannot flush events. No client defined.");
  return Promise.resolve(false);
}
function isInitialized() {
  return !!getClient();
}

// ../../../node_modules/@sentry/aws-serverless/build/npm/esm/utils.js
function markEventUnhandled(scope) {
  scope.addEventProcessor((event) => {
    addExceptionMechanism(event, { handled: false });
    return event;
  });
  return scope;
}
function getAwsTraceData(event, context) {
  const headers = event.headers || {};
  const traceData = {
    "sentry-trace": headers["sentry-trace"],
    baggage: headers.baggage
  };
  if (context && context.clientContext && context.clientContext.Custom) {
    const customContext = context.clientContext.Custom;
    const sentryTrace = isString(customContext["sentry-trace"]) ? customContext["sentry-trace"] : void 0;
    if (sentryTrace) {
      traceData["sentry-trace"] = sentryTrace;
      traceData.baggage = isString(customContext.baggage) ? customContext.baggage : void 0;
    }
  }
  return traceData;
}

// ../../../node_modules/@sentry/aws-serverless/build/npm/esm/sdk.js
var import_os = require("os");
var import_util = require("util");
var import_perf_hooks = require("perf_hooks");

// ../../../node_modules/@sentry/aws-serverless/build/npm/esm/debug-build.js
var DEBUG_BUILD3 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;

// ../../../node_modules/@sentry/aws-serverless/build/npm/esm/sdk.js
var { isPromise } = import_util.types;
function isPromiseAllSettledResult(result) {
  return result.every(
    (v) => Object.prototype.hasOwnProperty.call(v, "status") && (Object.prototype.hasOwnProperty.call(v, "value") || Object.prototype.hasOwnProperty.call(v, "reason"))
  );
}
function getRejectedReasons(results) {
  return results.reduce((rejected, result) => {
    if (result.status === "rejected" && result.reason)
      rejected.push(result.reason);
    return rejected;
  }, []);
}
function tryGetRemainingTimeInMillis(context) {
  return typeof context.getRemainingTimeInMillis === "function" ? context.getRemainingTimeInMillis() : 0;
}
function enhanceScopeWithEnvironmentData(scope, context, startTime) {
  scope.setContext("aws.lambda", {
    aws_request_id: context.awsRequestId,
    function_name: context.functionName,
    function_version: context.functionVersion,
    invoked_function_arn: context.invokedFunctionArn,
    execution_duration_in_millis: import_perf_hooks.performance.now() - startTime,
    remaining_time_in_millis: tryGetRemainingTimeInMillis(context),
    "sys.argv": process.argv
  });
  scope.setContext("aws.cloudwatch.logs", {
    log_group: context.logGroupName,
    log_stream: context.logStreamName,
    url: `https://console.aws.amazon.com/cloudwatch/home?region=${process.env.AWS_REGION}#logsV2:log-groups/log-group/${encodeURIComponent(context.logGroupName)}/log-events/${encodeURIComponent(
      context.logStreamName
    )}?filterPattern="${context.awsRequestId}"`
  });
}
function enhanceScopeWithTransactionData(scope, context) {
  scope.setTransactionName(context.functionName);
  scope.setTag("server_name", process.env._AWS_XRAY_DAEMON_ADDRESS || process.env.SENTRY_NAME || (0, import_os.hostname)());
  scope.setTag("url", `awslambda:///${context.functionName}`);
}
function wrapHandler(handler, wrapOptions = {}) {
  const START_TIME = import_perf_hooks.performance.now();
  const options = {
    flushTimeout: 2e3,
    callbackWaitsForEmptyEventLoop: false,
    captureTimeoutWarning: true,
    timeoutWarningLimit: 500,
    captureAllSettledReasons: false,
    startTrace: true,
    ...wrapOptions
  };
  let timeoutWarningTimer;
  const asyncHandler = handler.length > 2 ? (event, context) => new Promise((resolve, reject) => {
    const rv = handler(event, context, (error, result) => {
      if (error === null || error === void 0) {
        resolve(result);
      } else {
        reject(error);
      }
    });
    if (isPromise(rv)) {
      void rv.then(resolve, reject);
    }
  }) : handler;
  return async (event, context) => {
    context.callbackWaitsForEmptyEventLoop = options.callbackWaitsForEmptyEventLoop;
    const configuredTimeout = Math.ceil(tryGetRemainingTimeInMillis(context) / 1e3);
    const configuredTimeoutMinutes = Math.floor(configuredTimeout / 60);
    const configuredTimeoutSeconds = configuredTimeout % 60;
    const humanReadableTimeout = configuredTimeoutMinutes > 0 ? `${configuredTimeoutMinutes}m${configuredTimeoutSeconds}s` : `${configuredTimeoutSeconds}s`;
    if (options.captureTimeoutWarning) {
      const timeoutWarningDelay = tryGetRemainingTimeInMillis(context) - options.timeoutWarningLimit;
      timeoutWarningTimer = setTimeout(() => {
        withScope2((scope) => {
          scope.setTag("timeout", humanReadableTimeout);
          captureMessage(`Possible function timeout: ${context.functionName}`, "warning");
        });
      }, timeoutWarningDelay);
    }
    async function processResult(span) {
      const scope = getCurrentScope();
      let rv;
      try {
        enhanceScopeWithEnvironmentData(scope, context, START_TIME);
        rv = await asyncHandler(event, context);
        if (options.captureAllSettledReasons && Array.isArray(rv) && isPromiseAllSettledResult(rv)) {
          const reasons = getRejectedReasons(rv);
          reasons.forEach((exception) => {
            captureException(exception, (scope2) => markEventUnhandled(scope2));
          });
        }
      } catch (e) {
        captureException(e, (scope2) => markEventUnhandled(scope2));
        throw e;
      } finally {
        clearTimeout(timeoutWarningTimer);
        if (span && span.isRecording()) {
          span.end();
        }
        await flush(options.flushTimeout).catch((e) => {
          DEBUG_BUILD3 && logger.error(e);
        });
      }
      return rv;
    }
    if (options.startTrace && !isWrappedByOtel(handler)) {
      const traceData = getAwsTraceData(event, context);
      return continueTrace({ sentryTrace: traceData["sentry-trace"], baggage: traceData.baggage }, () => {
        return startSpanManual(
          {
            name: context.functionName,
            op: "function.aws.lambda",
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "component",
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.function.serverless"
            }
          },
          (span) => {
            enhanceScopeWithTransactionData(getCurrentScope(), context);
            return processResult(span);
          }
        );
      });
    }
    return withScope2(async () => {
      return processResult(void 0);
    });
  };
}
function isWrappedByOtel(handler) {
  return typeof handler === "function" && typeof handler.__original === "function" && typeof handler.__unwrap === "function" && handler.__wrapped === true;
}

// ../../../node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// ../../../node_modules/luxon/src/impl/formats.js
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

// ../../../node_modules/luxon/src/zone.js
var Zone = class {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The IANA name of this zone.
   * Defaults to `name` if not overwritten by a subclass.
   * @abstract
   * @type {string}
   */
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// ../../../node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class _SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new _SystemZone();
    }
    return singleton;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// ../../../node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value } = formatted[i];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class _IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new _IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = _IANAZone.isValidZone(name);
  }
  /**
   * The type of zone. `iana` for all instances of `IANAZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "iana";
  }
  /**
   * The name of this zone (i.e. the IANA zone name).
   * @override
   * @type {string}
   */
  get name() {
    return this.zoneName;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns false for all IANA zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return false;
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @override
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /**
   * Return whether this Zone is equal to another zone
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /**
   * Return whether this Zone is valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return this.valid;
  }
};

// ../../../node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
var weekInfoCache = {};
function getCachedWeekInfo(locString) {
  let data = weekInfoCache[locString];
  if (!data) {
    const locale = new Intl.Locale(locString);
    data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    weekInfoCache[locString] = data;
  }
  return data;
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
var Locale = class _Locale {
  static fromOpts(opts) {
    return _Locale.create(
      opts.locale,
      opts.numberingSystem,
      opts.outputCalendar,
      opts.weekSettings,
      opts.defaultToEN
    );
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new _Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return _Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return _Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        validateWeekSettings(alts.weekSettings) || this.weekSettings,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format = false) {
    return listStuff(this, length, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false) {
    return listStuff(this, length, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
};

// ../../../node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class _FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new _FixedOffsetZone(0);
    }
    return singleton2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new _FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /**
   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "fixed";
  }
  /**
   * The name of this zone.
   * All fixed zones' names always start with "UTC" (plus optional offset)
   * @override
   * @type {string}
   */
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  /**
   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
   *
   * @override
   * @type {string}
   */
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /**
   * Returns the offset's common name at the specified timestamp.
   *
   * For fixed offset zones this equals to the zone name.
   * @override
   */
  offsetName() {
    return this.name;
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns true for all fixed offset zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return true;
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   *
   * For fixed offset zones, this is constant and does not depend on a timestamp.
   * @override
   * @return {number}
   */
  offset() {
    return this.fixed;
  }
  /**
   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /**
   * Return whether this Zone is valid:
   * All fixed offset zones are valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return true;
  }
};

// ../../../node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
};

// ../../../node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone2) {
  let offset2;
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString2(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// ../../../node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
var digitRegexCache = {};
function resetDigitRegexCache() {
  digitRegexCache = {};
}
function digitRegex({ numberingSystem }, append = "") {
  const ns = numberingSystem || "latn";
  if (!digitRegexCache[ns]) {
    digitRegexCache[ns] = {};
  }
  if (!digitRegexCache[ns][append]) {
    digitRegexCache[ns][append] = new RegExp(`${numberingSystems[ns]}${append}`);
  }
  return digitRegexCache[ns][append];
}

// ../../../node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var twoDigitCutoffYear = 60;
var throwOnInvalid;
var defaultWeekSettings = null;
var Settings = class {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }
  /**
   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t2) {
    throwOnInvalid = t2;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
    DateTime.resetCache();
    resetDigitRegexCache();
  }
};

// ../../../node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// ../../../node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    }
    if (!isUndefined(obj.localWeekday))
      obj.weekday = obj.localWeekday;
    if (!isUndefined(obj.localWeekNumber))
      obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined(obj.localWeekYear))
      obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
    obj.weekNumber,
    1,
    weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
  ), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}

// ../../../node_modules/luxon/src/impl/util.js
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString2(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr2, by, compare) {
  if (arr2.length === 0) {
    return void 0;
  }
  return arr2.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
  if (settings == null) {
    return null;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: Array.from(settings.weekend)
    };
  }
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string2) {
  if (isUndefined(string2) || string2 === null || string2 === "") {
    return void 0;
  } else {
    return parseInt(string2, 10);
  }
}
function parseFloating(string2) {
  if (isUndefined(string2) || string2 === null || string2 === "") {
    return void 0;
  } else {
    return parseFloat(string2);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null)
        continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

// ../../../node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// ../../../node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class _Formatter {
  static create(locale, opts = {}) {
    return new _Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string2 = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string2({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string2(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string2(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = _Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string2({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string2({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string2({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string2({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string2({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string2({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string2({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string2({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "n":
          return this.num(dt.localWeekNumber);
        case "nn":
          return this.num(dt.localWeekNumber, 2);
        case "ii":
          return this.num(dt.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(dt.localWeekYear, 4);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = _Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t2) => t2));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// ../../../node_modules/luxon/src/impl/regexParser.js
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match2[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m = match2[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse(s2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

// ../../../node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  let sum = vals.milliseconds ?? 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits.reduceRight((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  orderedUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
var Duration = class _Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return _Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new _Duration({
      values: normalizeObject(obj, _Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return _Duration.fromMillis(durationLike);
    } else if (_Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return _Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new _Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid)
      return INVALID;
    const l2 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid)
      return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid)
      return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = _Duration.fromDurationLike(duration), result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = _Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[_Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const mixed2 = { ...this.values, ...normalizeObject(values, _Duration.normalizeUnit) };
    return clone(this, { values: mixed2 });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => _Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone(this, { values: built }, true);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid)
      return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};

// ../../../node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class _Interval {
  /**
   * @private
   */
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new _Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new _Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
    return _Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
    return _Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s2, e] = (text || "").split("/", 2);
    if (s2 && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e2) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e2) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return _Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return _Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return _Interval.before(end, dur);
        }
      }
    }
    return _Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(unit = "milliseconds", opts) {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit, opts);
    let end;
    if (opts?.useLocaleWeeks) {
      end = this.end.reconfigure({ locale: start.locale });
    } else {
      end = this.end;
    }
    end = end.startOf(unit, opts);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return _Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  /**
   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return _Interval.fromDateTimes(s2, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
    return _Interval.fromDateTimes(s2, e);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr2 = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr2) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(_Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return _Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return _Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid)
      return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// ../../../node_modules/luxon/src/info.js
var Info = class {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
};

// ../../../node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

// ../../../node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t2) => ({ regex: RegExp(escapeToken(t2.val)), deser: ([s2]) => s2, literal: true }), unitate = (t2) => {
    if (token.literal) {
      return literal(t2);
    }
    switch (t2.val) {
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t2);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type, value } = part;
  if (type === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type];
  let actualType = type;
  if (type === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t2) => maybeExpandMacroToken(t2, locale)));
}
var TokenParser = class {
  constructor(locale, format) {
    this.locale = locale;
    this.format = format;
    this.tokens = expandMacroTokens(Formatter.parseFormat(format), locale);
    this.units = this.tokens.map((t2) => unitForToken(t2, locale));
    this.disqualifyingUnit = this.units.find((t2) => t2.invalidReason);
    if (!this.disqualifyingUnit) {
      const [regexString, handlers] = buildRegex(this.units);
      this.regex = RegExp(regexString, "i");
      this.handlers = handlers;
    }
  }
  explainFromTokens(input) {
    if (!this.isValid) {
      return { input, tokens: this.tokens, invalidReason: this.invalidReason };
    } else {
      const [rawMatches, matches] = match(input, this.regex, this.handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
      if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
        throw new ConflictingSpecificationError(
          "Can't include meridiem when specifying 24-hour format"
        );
      }
      return {
        input,
        tokens: this.tokens,
        regex: this.regex,
        rawMatches,
        matches,
        result,
        zone,
        specificOffset
      };
    }
  }
  get isValid() {
    return !this.disqualifyingUnit;
  }
  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
};
function explainFromTokens(locale, input, format) {
  const parser = new TokenParser(locale, format);
  return parser.explainFromTokens(input);
}
function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
}

// ../../../node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function possiblyCachedLocalWeekData(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(
      dt.c,
      dt.loc.getMinDaysInFirstWeek(),
      dt.loc.getStartOfWeek()
    );
  }
  return dt.localWeekData;
}
function clone2(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
    );
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0)
    c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit);
  return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
}
function guessOffsetForZone(zone) {
  if (!zoneOffsetGuessCache[zone]) {
    if (zoneOffsetTs === void 0) {
      zoneOffsetTs = Settings.now();
    }
    zoneOffsetGuessCache[zone] = zone.offset(zoneOffsetTs);
  }
  return zoneOffsetGuessCache[zone];
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone);
  if (!zone.isValid) {
    return DateTime.invalid(unsupportedZone(zone));
  }
  const loc = Locale.fromObject(opts);
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = guessOffsetForZone(zone);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = Settings.now();
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
    c = roundTo(c, round || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else
        return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var zoneOffsetTs;
var zoneOffsetGuessCache = {};
var DateTime = class _DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = isNumber(config.o) && !config.old ? config.o : zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.localWeekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new _DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return _DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new _DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return _DateTime.invalid("Timestamp out of range");
    } else {
      return new _DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new _DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return _DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return _DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    if (!inst.isValid) {
      return _DateTime.invalid(inst.invalid);
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return _DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return _DateTime.fromFormat(text, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new _DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t2) => t2 ? t2.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t2) => t2.val).join("");
  }
  static resetCache() {
    zoneOffsetTs = void 0;
    zoneOffsetGuessCache = {};
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
    }
    return [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return _DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone2(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed2;
    if (settingWeekStuff) {
      mixed2 = weekToGregorian(
        { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
        minDaysInFirstWeek,
        startOfWeek
      );
    } else if (!isUndefined(normalized.ordinal)) {
      mixed2 = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed2 = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed2.day = Math.min(daysInMonth(mixed2.year, mixed2.month), mixed2.day);
      }
    }
    const [ts, o] = objToTS(mixed2, this.o, this.zone);
    return clone2(this, { ts, o });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit, { useLocaleWeeks = false } = {}) {
    if (!this.isValid)
      return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const { weekday } = this;
        if (weekday < startOfWeek) {
          o.weekNumber = this.weekNumber - 1;
        }
        o.weekday = startOfWeek;
      } else {
        o.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit, opts) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(
      this,
      format === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(_DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return _DateTime.fromFormatExplain(text, fmt, options);
  }
  /**
   * Build a parser for `fmt` using the given locale. This parser can be passed
   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
   * can be used to optimize cases where many dates need to be parsed in a
   * specific format.
   *
   * @param {String} fmt - the format the string is expected to be in (see
   * description)
   * @param {Object} options - options used to set locale and numberingSystem
   * for parser
   * @returns {TokenParser} - opaque object to be used
   */
  static buildFormatParser(fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return new TokenParser(localeToUse, fmt);
  }
  /**
   * Create a DateTime from an input string and format parser.
   *
   * The format parser must have been created with the same locale as this call.
   *
   * @param {String} text - the string to parse
   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
   * @param {Object} opts - options taken by fromFormat()
   * @returns {DateTime}
   */
  static fromFormatParser(text, formatParser, opts = {}) {
    if (isUndefined(text) || isUndefined(formatParser)) {
      throw new InvalidArgumentError(
        "fromFormatParser requires an input string and a format parser"
      );
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    if (!localeToUse.equals(formatParser.locale)) {
      throw new InvalidArgumentError(
        `fromFormatParser called with a locale of ${localeToUse}, but the format parser was created for ${formatParser.locale}`
      );
    }
    const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text);
    if (invalidReason) {
      return _DateTime.invalid(invalidReason);
    } else {
      return parseDataToDateTime(
        result,
        zone,
        opts,
        `format ${formatParser.format}`,
        text,
        specificOffset
      );
    }
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// ../../utils/lib/auth/user-auth.helper.ts
async function getRelatedPersonForPatient(patientID, oystehr) {
  console.log(`getting user-relatedperson for patient with id ${patientID}`);
  const resources = (await oystehr.fhir.search({
    resourceType: "RelatedPerson",
    params: [
      {
        name: "patient",
        value: `Patient/${patientID}`
      },
      {
        name: "relationship",
        value: "user-relatedperson"
      }
    ]
  })).unbundle();
  if (resources.length !== 1) {
    return void 0;
  }
  return resources[0];
}

// ../../utils/lib/types/common.ts
var OVERRIDE_DATE_FORMAT = "M/d/yyyy";
var HOURS_OF_OPERATION_FORMAT = "TT";
var AllStates = [
  { value: "AL", label: "AL" },
  // Alabama
  { value: "AK", label: "AK" },
  // Alaska
  { value: "AZ", label: "AZ" },
  // Arizona
  { value: "AR", label: "AR" },
  // Arkansas
  { value: "CA", label: "CA" },
  // California
  { value: "CO", label: "CO" },
  // Colorado
  { value: "CT", label: "CT" },
  // Connecticut
  { value: "DE", label: "DE" },
  // Delaware
  { value: "DC", label: "DC" },
  { value: "FL", label: "FL" },
  // Florida
  { value: "GA", label: "GA" },
  // Georgia
  { value: "HI", label: "HI" },
  // Hawaii
  { value: "ID", label: "ID" },
  // Idaho
  { value: "IL", label: "IL" },
  // Illinois
  { value: "IN", label: "IN" },
  // Indiana
  { value: "IA", label: "IA" },
  // Iowa
  { value: "KS", label: "KS" },
  // Kansas
  { value: "KY", label: "KY" },
  // Kentucky
  { value: "LA", label: "LA" },
  // Louisiana
  { value: "ME", label: "ME" },
  // Maine
  { value: "MD", label: "MD" },
  // Maryland
  { value: "MA", label: "MA" },
  // Massachusetts
  { value: "MI", label: "MI" },
  // Michigan
  { value: "MN", label: "MN" },
  // Minnesota
  { value: "MS", label: "MS" },
  // Mississippi
  { value: "MO", label: "MO" },
  // Missouri
  { value: "MT", label: "MT" },
  // Montana
  { value: "NE", label: "NE" },
  // Nebraska
  { value: "NV", label: "NV" },
  // Nevada
  { value: "NH", label: "NH" },
  // New Hampshire
  { value: "NJ", label: "NJ" },
  // New Jersey
  { value: "NM", label: "NM" },
  // New Mexico
  { value: "NY", label: "NY" },
  // New York
  { value: "NC", label: "NC" },
  // North Carolina
  { value: "ND", label: "ND" },
  // North Dakota
  { value: "OH", label: "OH" },
  // Ohio
  { value: "OK", label: "OK" },
  // Oklahoma
  { value: "OR", label: "OR" },
  // Oregon
  { value: "PA", label: "PA" },
  // Pennsylvania
  { value: "RI", label: "RI" },
  // Rhode Island
  { value: "SC", label: "SC" },
  // South Carolina
  { value: "SD", label: "SD" },
  // South Dakota
  { value: "TN", label: "TN" },
  // Tennessee
  { value: "TX", label: "TX" },
  // Texas
  { value: "UT", label: "UT" },
  // Utah
  { value: "VT", label: "VT" },
  // Vermont
  { value: "VA", label: "VA" },
  // Virginia
  { value: "VI", label: "VI" },
  { value: "WA", label: "WA" },
  // Washington
  { value: "WV", label: "WV" },
  // West Virginia
  { value: "WI", label: "WI" },
  // Wisconsin
  { value: "WY", label: "WY" }
  // Wyoming
];

// ../../utils/lib/types/data/appointments/appointments.types.ts
var appointmentTypeMap = {
  ["OTTEHR-IP" /* IP */]: "In-Person",
  ["OTTEHR-TM" /* TM */]: "Telemedicine"
};

// ../../utils/lib/types/data/paperwork/paperwork.constants.ts
var SCHOOL_WORK_NOTE = "school-work-note";

// ../../utils/lib/types/data/labs/labs.constants.ts
var OYSTEHR_LAB_API_BASE = "https://labs-api.zapehr.com/v1";
var OYSTEHR_LAB_ORDERABLE_ITEM_SEARCH_API = `${OYSTEHR_LAB_API_BASE}/orderableItem`;

// ../../utils/lib/types/urgent-care/common.ts
var CancellationReasonOptionsInPerson = /* @__PURE__ */ ((CancellationReasonOptionsInPerson3) => {
  CancellationReasonOptionsInPerson3["Patient improved"] = "Patient improved";
  CancellationReasonOptionsInPerson3["Wait time too long"] = "Wait time too long";
  CancellationReasonOptionsInPerson3["Prefer another provider"] = "Prefer another provider";
  CancellationReasonOptionsInPerson3["Changing location"] = "Changing location";
  CancellationReasonOptionsInPerson3["Changing to telemedicine"] = "Changing to telemedicine";
  CancellationReasonOptionsInPerson3["Financial responsibility concern"] = "Financial responsibility concern";
  CancellationReasonOptionsInPerson3["Insurance issue"] = "Insurance issue";
  CancellationReasonOptionsInPerson3["Service never offered"] = "Service never offered";
  CancellationReasonOptionsInPerson3["Duplicate visit or account error"] = "Duplicate visit or account error";
  return CancellationReasonOptionsInPerson3;
})(CancellationReasonOptionsInPerson || {});
var CancellationReasonCodesInPerson = {
  "Patient improved": "patient-improved",
  "Wait time too long": "wait-time",
  "Prefer another provider": "prefer-another-provider",
  "Changing location": "changing-location",
  "Changing to telemedicine": "changing-telemedicine",
  "Financial responsibility concern": "financial-concern",
  "Insurance issue": "insurance-issue",
  "Service never offered": "service-not-offered",
  "Duplicate visit or account error": "duplicate-visit-or-account-error"
};
var CancellationReasonOptionsTelemedEHR = /* @__PURE__ */ ((CancellationReasonOptionsTelemedEHR2) => {
  CancellationReasonOptionsTelemedEHR2["Patient did not answer after multiple attempts"] = "Patient did not answer after multiple attempts";
  CancellationReasonOptionsTelemedEHR2["Wrong patient name on chart"] = "Wrong patient name on chart";
  CancellationReasonOptionsTelemedEHR2["Technical issues connecting and/ or with video"] = "Technical issues connecting and/ or with video";
  CancellationReasonOptionsTelemedEHR2["Other"] = "Other";
  return CancellationReasonOptionsTelemedEHR2;
})(CancellationReasonOptionsTelemedEHR || {});

// ../../utils/lib/types/errors/index.ts
var APIErrorCode = /* @__PURE__ */ ((APIErrorCode2) => {
  APIErrorCode2[APIErrorCode2["NOT_AUTHORIZED"] = 4e3] = "NOT_AUTHORIZED";
  APIErrorCode2[APIErrorCode2["CANT_UPDATE_CANCELED_APT_ERROR"] = 4001] = "CANT_UPDATE_CANCELED_APT_ERROR";
  APIErrorCode2[APIErrorCode2["DOB_UNCONFIRMED"] = 4002] = "DOB_UNCONFIRMED";
  APIErrorCode2[APIErrorCode2["NO_READ_ACCESS_TO_PATIENT"] = 4003] = "NO_READ_ACCESS_TO_PATIENT";
  APIErrorCode2[APIErrorCode2["APPOINTMENT_NOT_FOUND"] = 4004] = "APPOINTMENT_NOT_FOUND";
  APIErrorCode2[APIErrorCode2["CANT_CANCEL_CHECKEDIN_APT"] = 4005] = "CANT_CANCEL_CHECKEDIN_APT";
  APIErrorCode2[APIErrorCode2["APPOINTMENT_CANT_BE_CANCELED"] = 4006] = "APPOINTMENT_CANT_BE_CANCELED";
  APIErrorCode2[APIErrorCode2["PATIENT_TOO_OLD"] = 4007] = "PATIENT_TOO_OLD";
  APIErrorCode2[APIErrorCode2["PATIENT_NOT_BORN"] = 4008] = "PATIENT_NOT_BORN";
  APIErrorCode2[APIErrorCode2["CHARACTER_LIMIT_EXCEEDED"] = 4009] = "CHARACTER_LIMIT_EXCEEDED";
  APIErrorCode2[APIErrorCode2["SCHEDULE_NOT_FOUND"] = 4010] = "SCHEDULE_NOT_FOUND";
  APIErrorCode2[APIErrorCode2["APPOINTMENT_CANT_BE_MODIFIED"] = 4011] = "APPOINTMENT_CANT_BE_MODIFIED";
  APIErrorCode2[APIErrorCode2["APPOINTMENT_CANT_BE_IN_PAST"] = 4012] = "APPOINTMENT_CANT_BE_IN_PAST";
  APIErrorCode2[APIErrorCode2["PATIENT_NOT_FOUND"] = 4013] = "PATIENT_NOT_FOUND";
  APIErrorCode2[APIErrorCode2["MALFORMED_GET_ANSWER_OPTIONS_INPUT"] = 4014] = "MALFORMED_GET_ANSWER_OPTIONS_INPUT";
  APIErrorCode2[APIErrorCode2["ANSWER_OPTION_FROM_RESOURCE_UNDEFINED"] = 4015] = "ANSWER_OPTION_FROM_RESOURCE_UNDEFINED";
  APIErrorCode2[APIErrorCode2["BILLING_PROVIDER_NOT_FOUND"] = 4016] = "BILLING_PROVIDER_NOT_FOUND";
  APIErrorCode2[APIErrorCode2["QUESTIONNAIRE_RESPONSE_INVALID"] = 4100] = "QUESTIONNAIRE_RESPONSE_INVALID";
  APIErrorCode2[APIErrorCode2["MISSING_REQUEST_BODY"] = 4200] = "MISSING_REQUEST_BODY";
  APIErrorCode2[APIErrorCode2["CANNOT_JOIN_CALL_NOT_IN_PROGRESS"] = 4300] = "CANNOT_JOIN_CALL_NOT_IN_PROGRESS";
  APIErrorCode2[APIErrorCode2["MISSING_BILLING_PROVIDER_DETAILS"] = 4301] = "MISSING_BILLING_PROVIDER_DETAILS";
  return APIErrorCode2;
})(APIErrorCode || {});
var isApiError = (errorObject) => {
  if (!errorObject) {
    return false;
  }
  let asObj = errorObject;
  if (typeof asObj === "string") {
    try {
      asObj = JSON.parse(asObj);
    } catch (_) {
      return false;
    }
  }
  const asAny = asObj;
  const output = asAny?.output;
  if (asAny && asAny.code && asAny.message) {
    return typeof asAny.message === "string" && Object.values(APIErrorCode).includes(asAny.code);
  } else if (output && output.code && output.message) {
    return typeof output.message === "string" && Object.values(APIErrorCode).includes(output.code);
  }
  return false;
};
var APPOINTMENT_NOT_FOUND_ERROR = {
  code: 4004 /* APPOINTMENT_NOT_FOUND */,
  message: "Appointment is not found"
};
var CANT_CANCEL_CHECKEDIN_APT_ERROR = {
  code: 4005 /* CANT_CANCEL_CHECKEDIN_APT */,
  message: "You cannot cancel a checked-in appointment"
};
var POST_TELEMED_APPOINTMENT_CANT_BE_CANCELED_ERROR = {
  code: 4006 /* APPOINTMENT_CANT_BE_CANCELED */,
  message: "Post-telemed appointments are not cancelable"
};
var SCHEDULE_NOT_FOUND_ERROR = {
  code: 4010 /* SCHEDULE_NOT_FOUND */,
  message: "Schedule could not be found"
};

// ../../utils/lib/types/api/chart-data/chart-data.types.ts
var PATIENT_VITALS_META_SYSTEM = "patient-vitals-field";
var CSS_NOTE_ID = "css-note";

// ../../utils/lib/types/api/chart-data/chart-data.constants.ts
var SCHOOL_WORK_NOTE_TYPE_META_SYSTEM = `${SCHOOL_WORK_NOTE}/type`;
var VitalFieldNames = /* @__PURE__ */ ((VitalFieldNames3) => {
  VitalFieldNames3["VitalTemperature"] = "vital-temperature";
  VitalFieldNames3["VitalHeartbeat"] = "vital-heartbeat";
  VitalFieldNames3["VitalBloodPressure"] = "vital-blood-pressure";
  VitalFieldNames3["VitalOxygenSaturation"] = "vital-oxygen-sat";
  VitalFieldNames3["VitalRespirationRate"] = "vital-respiration-rate";
  VitalFieldNames3["VitalWeight"] = "vital-weight";
  VitalFieldNames3["VitalHeight"] = "vital-height";
  VitalFieldNames3["VitalVision"] = "vital-vision";
  return VitalFieldNames3;
})(VitalFieldNames || {});

// ../../utils/lib/types/api/chart-data/exam-fields-map.ts
function createCodingCode(code, display, system) {
  return {
    coding: [
      {
        code,
        display: display ?? void 0,
        system: system ?? void 0
      }
    ]
  };
}
var examCardsMap = {
  "general-comment": {
    code: createCodingCode("38266002", "Entire body as a whole (body structure)")
  },
  "head-comment": {
    code: createCodingCode("298364001", "Finding of head region (finding)")
  },
  "eyes-comment": {
    code: createCodingCode("118235002", "Eye / vision finding (finding)")
  },
  "nose-comment": {
    code: createCodingCode("118237005", "Nose finding (finding)")
  },
  "ears-comment": {
    code: createCodingCode("247234006", "Ear finding (finding)")
  },
  "mouth-comment": {
    code: createCodingCode("423066003", "Finding of mouth region (finding)")
  },
  "neck-comment": {
    code: createCodingCode("298378000", "Finding of neck region (finding)")
  },
  "chest-comment": {
    code: createCodingCode("724622000", "Problem of chest (finding)")
  },
  "abdomen-comment": {
    code: createCodingCode("609624008", "Finding of abdomen (finding)")
  },
  "back-comment": {
    code: createCodingCode("414252009", "Finding of back (finding)")
  },
  "skin-comment": {
    code: createCodingCode("106076001", "Skin finding (finding)")
  },
  "extremities-musculoskeletal-comment": {
    code: createCodingCode("106028002", "Musculoskeletal finding (finding)")
  },
  "neurological-comment": {
    code: createCodingCode("102957003", "Neurological finding (finding)")
  },
  "psych-comment": {
    code: createCodingCode("116367006", "Psychological finding (finding)")
  }
};
var inPersonExamCardsMap = {
  "general-comment": {
    code: createCodingCode("38266002", "Entire body as a whole (body structure)")
  },
  "skin-comment": {
    code: createCodingCode("106076001", "Skin finding (finding)")
  },
  "hair-comment": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "nails-comment": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "head-comment": {
    code: createCodingCode("298364001", "Finding of head region (finding)")
  },
  "eyes-comment": {
    code: createCodingCode("118235002", "Eye / vision finding (finding)")
  },
  "ears-comment": {
    code: createCodingCode("247234006", "Ear finding (finding)")
  },
  "nose-comment": {
    code: createCodingCode("118237005", "Nose finding (finding)")
  },
  "mouth-comment": {
    code: createCodingCode("423066003", "Finding of mouth region (finding)")
  },
  "teeth-comment": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "pharynx-comment": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "neck-comment": {
    code: createCodingCode("298378000", "Finding of neck region (finding)")
  },
  "heart-comment": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "lungs-comment": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abdomen-comment": {
    code: createCodingCode("609624008", "Finding of abdomen (finding)")
  },
  "back-comment": {
    code: createCodingCode("414252009", "Finding of back (finding)")
  },
  "rectal-comment": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "extremities-comment": {
    code: createCodingCode("106028002", "Musculoskeletal finding (finding)")
  },
  "musculoskeletal-comment": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "neurologic-comment": {
    code: createCodingCode("102957003", "Neurological finding (finding)")
  },
  "psychiatric-comment": {
    code: createCodingCode("116367006", "Psychological finding (finding)")
  }
};
var examFieldsMap = {
  // >>> CARD = general
  // >> GROUP = normal
  alert: {
    code: createCodingCode("248233002", "Mental alertness (observable entity)")
  },
  awake: {
    code: createCodingCode("248218005", "Awake (finding)")
  },
  calm: {
    code: createCodingCode("102894008", "Feeling calm (finding)")
  },
  "well-hydrated": {
    code: createCodingCode("405006006", "Hydration status (observable entity)")
  },
  "moist-mucous-membrane": {
    code: createCodingCode("276398005", "Moist oral mucosa (finding)"),
    bodySite: createCodingCode("123851003", "Mouth region structure (body structure)")
  },
  "distress-none": {
    code: createCodingCode("69328002", "Distress (finding)")
  },
  "playful-and-active": {
    code: createCodingCode("300776002", "Does play (finding)")
  },
  // >> GROUP = abnormal
  "tired-appearing": {
    code: createCodingCode("224960004", "Tired (finding)")
  },
  "ill-appearing": {
    code: createCodingCode("39104002", "Illness (finding)")
  },
  fussy: {
    code: createCodingCode("55929007", "Feeling irritable (finding)")
  },
  "dry-mucous-membranes": {
    code: createCodingCode("123640000", "Mucous membrane dryness (finding)"),
    bodySite: createCodingCode("276413003", "Nasal mucosa moist (finding)")
  },
  "sunken-eye": {
    code: createCodingCode("246923005", "Sunken eyes (finding)"),
    bodySite: createCodingCode("81745001", "Structure of eye proper (body structure)")
  },
  "mild-distress": {
    code: createCodingCode("69328003", "Distress (finding)")
  },
  "moderate-distress": {
    code: createCodingCode("69328004", "Distress (finding)")
  },
  "severe-distress": {
    code: createCodingCode("69328005", "Distress (finding)")
  },
  // >>> CARD = head
  // >> GROUP = normal
  normocephaly: {
    code: createCodingCode("17621005", "Normal (qualifier value)"),
    bodySite: createCodingCode("302548004", "Entire head (body structure)")
  },
  atraumatic: {
    code: createCodingCode("1149217004", "No traumatic injury (situation)"),
    bodySite: createCodingCode("302548004", "Entire head (body structure)")
  },
  // >>> CARD = eyes
  // >> GROUP = normal
  "pupils-symmetric": {
    code: createCodingCode("301943000", "Pupils equal (finding)"),
    bodySite: createCodingCode("392406005", "Pupil structure (body structure)")
  },
  eomi: {
    code: createCodingCode("103251002", "Normal ocular motility (finding)"),
    bodySite: createCodingCode("371398005", "Eye region structure (body structure)")
  },
  // >> GROUP = abnormal
  "pupils-asymmetric": {
    code: createCodingCode("247010007", "Pupil finding (finding)"),
    bodySite: createCodingCode("392406005", "Pupil structure (body structure)")
  },
  // >> GROUP = rightEye
  "right-eye-normal": {
    code: createCodingCode("860970003", "Normal eye proper (finding)"),
    bodySite: createCodingCode("1290043002", "Entire right eye proper (body structure)")
  },
  "right-eye-injected": {
    code: createCodingCode("246806002", "Injection of caruncle of eye (finding)"),
    bodySite: createCodingCode("43045000", "Lacrimal caruncle structure (body structure)")
  },
  "right-eye-discharge": {
    code: createCodingCode("246679005", "Discharge from eye (finding)"),
    bodySite: createCodingCode("371398005", "Eye region structure (body structure)")
  },
  "right-eye-watering": {
    code: createCodingCode("420103007", "Watery eye (finding)"),
    bodySite: createCodingCode("1284806009", "Structure of lumen of lacrimal apparatus (body structure)")
  },
  "right-eye-puffy-eyelids": {
    code: createCodingCode("193967004", "Swelling of eyelid (finding)"),
    bodySite: createCodingCode("80243003", "Eyelid structure (body structure)")
  },
  "right-eye-small-round-mass-in-eyelid": {
    code: createCodingCode("248514008", "Lump in eyelid (finding)"),
    bodySite: createCodingCode("80243003", "Eyelid structure (body structure)")
  },
  // >> GROUP = leftEye
  "left-eye-normal": {
    code: createCodingCode("860970003", "Normal eye proper (finding)"),
    bodySite: createCodingCode("1290041000", "Entire left eye proper (body structure)")
  },
  "left-eye-injected": {
    code: createCodingCode("246806002", "Injection of caruncle of eye (finding)"),
    bodySite: createCodingCode("43045000", "Lacrimal caruncle structure (body structure)")
  },
  "left-eye-discharge": {
    code: createCodingCode("246679005", "Discharge from eye (finding)"),
    bodySite: createCodingCode("371398005", "Eye region structure (body structure)")
  },
  "left-eye-watering": {
    code: createCodingCode("420103007", "Watery eye (finding)"),
    bodySite: createCodingCode("1284806009", "Structure of lumen of lacrimal apparatus (body structure)")
  },
  "left-eye-puffy-eyelids": {
    code: createCodingCode("193967004", "Swelling of eyelid (finding)"),
    bodySite: createCodingCode("80243003", "Eyelid structure (body structure)")
  },
  "left-eye-small-round-mass-in-eyelid": {
    code: createCodingCode("248514008", "Lump in eyelid (finding)"),
    bodySite: createCodingCode("80243003", "Eyelid structure (body structure)")
  },
  // >>> CARD = nose
  // >> GROUP = normal
  "no-drainage": {
    code: createCodingCode("64531003", "Nasal discharge (finding)"),
    bodySite: createCodingCode("45206002", "Nasal structure (body structure)")
  },
  // >> GROUP = abnormal
  "clear-rhinorrhea": {
    code: createCodingCode("64531003", "Nasal discharge (finding)"),
    bodySite: createCodingCode("45206000", "Nasal structure (body structure)")
  },
  "purulent-discharge": {
    code: createCodingCode("836475004", "Mucopurulent discharge from nose (finding)"),
    bodySite: createCodingCode("45206001", "Nasal structure (body structure)")
  },
  // >>> CARD = ears
  // >> GROUP = rightEar
  "normal-ear-right": {
    code: createCodingCode("300196000", "Ear normal (finding)"),
    bodySite: createCodingCode("25577004", "Right ear structure (body structure)")
  },
  "erythema-ear-right": {
    code: createCodingCode("247441003", "Erythema (finding)"),
    bodySite: createCodingCode("25577004", "Right ear structure (body structure)")
  },
  "swelling-ear-right": {
    code: createCodingCode("300874009", "Swelling of ear (finding)"),
    bodySite: createCodingCode("25577004", "Right ear structure (body structure)")
  },
  "pain-with-movement-of-pinna-ear-right": {
    code: createCodingCode("301388005", "Tenderness of ear structure (finding)"),
    bodySite: createCodingCode("25577004", "Right ear structure (body structure)")
  },
  "drainage-from-ear-canal-right": {
    code: createCodingCode("300132001", "Ear discharge (finding)"),
    bodySite: createCodingCode("25577004", "Right ear structure (body structure)")
  },
  "clear-discharge-ear-right": {
    code: createCodingCode("300132001", "Ear discharge (finding)"),
    bodySite: createCodingCode("25577004", "Right ear structure (body structure)")
  },
  // >> GROUP = leftEar
  "normal-ear-left": {
    code: createCodingCode("300196000", "Ear normal (finding)"),
    bodySite: createCodingCode("89644007", "Left ear structure (body structure)")
  },
  "erythema-ear-left": {
    code: createCodingCode("247441003", "Erythema (finding)"),
    bodySite: createCodingCode("89644007", "Left ear structure (body structure)")
  },
  "swelling-ear-left": {
    code: createCodingCode("300874009", "Swelling of ear (finding)"),
    bodySite: createCodingCode("89644007", "Left ear structure (body structure)")
  },
  "pain-with-movement-of-pinna-ear-left": {
    code: createCodingCode("301388005", "Tenderness of ear structure (finding)"),
    bodySite: createCodingCode("89644007", "Left ear structure (body structure)")
  },
  "drainage-from-ear-canal-left": {
    code: createCodingCode("300132001", "Ear discharge (finding)"),
    bodySite: createCodingCode("89644007", "Left ear structure (body structure)")
  },
  "clear-discharge-ear-left": {
    code: createCodingCode("300132001", "Ear discharge (finding)"),
    bodySite: createCodingCode("89644007", "Left ear structure (body structure)")
  },
  // >>> CARD = mouth
  // >> GROUP = normal
  "mouth-normal": {
    code: createCodingCode("162010006", "No mouth problem (situation)"),
    bodySite: createCodingCode("123851003", "Mouth region structure (body structure)")
  },
  "mouth-moist-mucous-membrane": {
    code: createCodingCode("276398005", "Moist oral mucosa (finding)"),
    bodySite: createCodingCode("123851003", "Mouth region structure (body structure)")
  },
  "oropharynx-clear": {
    code: createCodingCode("162010006", "No mouth problem (situation)"),
    bodySite: createCodingCode("31389004", "Oropharyngeal structure (body structure)")
  },
  "uvula-midline": {
    code: createCodingCode("249884003", "Deviation of uvula (finding)")
  },
  "tonsils-symmetric-and-not-enlarged": {
    code: createCodingCode("306962003", "Tonsil asymmetry (finding)"),
    bodySite: createCodingCode("26140008", "Uvula palatina structure (body structure)")
  },
  "normal-voice": {
    code: createCodingCode("10503001", "Normal voice (finding)"),
    bodySite: createCodingCode("4596009", "Laryngeal structure (body structure)")
  },
  // >> GROUP = abnormal
  "mouth-dry-mucous-membranes": {
    code: createCodingCode("262016004", "Open mouth (finding)"),
    bodySite: createCodingCode("123851003", "Mouth region structure (body structure)")
  },
  "erythema-of-pharynx": {
    code: createCodingCode("247441003", "Erythema (finding)"),
    bodySite: createCodingCode("54066008", "Pharyngeal structure (body structure)")
  },
  "white-patches-on-tongue-andor-buccal-mucosa-that-do-not-wipe-off": {
    code: createCodingCode("698193000", "Coating of mucous membrane of tongue (finding)"),
    bodySite: createCodingCode("21974007", "Tongue structure (body structure)")
  },
  "strawberry-tongue": {
    code: createCodingCode("42631002", "Strawberry tongue (disorder)"),
    bodySite: createCodingCode("21974007", "Tongue structure (body structure)")
  },
  "uvula-deviated": {
    code: createCodingCode("249884003", "Deviation of uvula (finding)"),
    bodySite: createCodingCode("26140008", "Uvula palatina structure (body structure)")
  },
  "tonsils-erythematous": {
    code: createCodingCode("195666007", "Acute erythematous tonsillitis (disorder)")
  },
  "exudate-on-tonsils": {
    code: createCodingCode("301791008", "Exudate on tonsils (finding)"),
    bodySite: createCodingCode("91636008", "Bilateral palatine tonsils (body structure)")
  },
  "hoarse-voice": {
    code: createCodingCode("50219008", "Hoarse (finding)"),
    bodySite: createCodingCode("4596009", "Laryngeal structure (body structure)")
  },
  "hot-potato-voice": {
    code: createCodingCode("100000000", "NOT REAL CODE Hot potato voice (finding)"),
    bodySite: createCodingCode("4596009", "Laryngeal structure (body structure)")
  },
  // >>> CARD = neck
  // >> GROUP = normal
  "supple-neck": {
    code: createCodingCode("48162006", "Supple (qualifier value)"),
    bodySite: createCodingCode("45048000", "Neck structure (body structure)")
  },
  "moves-in-all-directions": {
    code: createCodingCode("298475003", "Normal movement of neck (finding)"),
    bodySite: createCodingCode("786964009", "Structure of cervical spine joint region (body structure)")
  },
  // >>> CARD = chest
  // >> GROUP = normal
  "normal-respiratory-effort": {
    code: createCodingCode("1290338002", "Normal respiratory effort (finding)"),
    bodySite: createCodingCode("45048000", "Neck structure (body structure)")
  },
  "no-tachypnea": {
    code: createCodingCode("20716004", "Respiratory rate normal (finding)"),
    bodySite: createCodingCode("20139000", "Structure of respiratory system (body structure)")
  },
  "no-retractions": {
    code: createCodingCode("67909005", "Chest wall retraction (finding)"),
    bodySite: createCodingCode("302551006", "Entire thorax (body structure)")
  },
  "no-conversational-dyspnea": {
    code: createCodingCode("161938003", "No breathlessness (situation)")
  },
  // >> GROUP = abnormal
  tachypnea: {
    code: createCodingCode("271823003", "Tachypnea (finding)")
  },
  "suprasternal-retractions": {
    code: createCodingCode("67909005", "Chest wall retraction (finding)"),
    bodySite: createCodingCode("255569004", "Suprasternal (qualifier value)")
  },
  "intercostal-retractions": {
    code: createCodingCode("67909005", "Chest wall retraction (finding)"),
    bodySite: createCodingCode("1197041002", "Intercostal (qualifier value)")
  },
  "subcostal-retractions": {
    code: createCodingCode("67909005", "Chest wall retraction (finding)"),
    bodySite: createCodingCode("264208000", "Subcostal (qualifier value)")
  },
  "abdominal-breathing": {
    code: createCodingCode("57591009", "Diaphragmatic breathing (finding)"),
    bodySite: createCodingCode("20139000", "Structure of respiratory system (body structure)")
  },
  grunting: {
    code: createCodingCode("62085005", "Grunting respiration (finding)"),
    bodySite: createCodingCode("20139000", "Structure of respiratory system (body structure)")
  },
  "nasal-flaring": {
    code: createCodingCode("248568003", "Nasal flaring (finding)"),
    bodySite: createCodingCode("15562006", "Structure of respiratory region of nose (body structure)")
  },
  wheeze: {
    code: createCodingCode("56018004", "Wheezing (finding)"),
    bodySite: createCodingCode("20139000", "Structure of respiratory system (body structure)")
  },
  "barky-cough": {
    code: createCodingCode("17986004", "Barking cough (finding)"),
    bodySite: createCodingCode("321667001", "Respiratory tract structure (body structure)")
  },
  "stridor-with-each-breath": {
    code: createCodingCode("70407001", "Stridor (finding)"),
    bodySite: createCodingCode("58675001", "Upper respiratory tract structure (body structure)")
  },
  // >>> CARD = back
  // >> GROUP = normal
  "back-normal": {
    code: createCodingCode("17621005", "Normal (qualifier value)"),
    bodySite: createCodingCode("732054000", "Entire regional back (body structure)")
  },
  "able-to-flex-and-extend-back-and-move-side-to-side": {
    code: createCodingCode("364564000", "Range of joint movement (observable entity)"),
    bodySite: createCodingCode("304035006", "Regional back structure (body structure)")
  },
  // >> GROUP = abnormal
  "cva-tenderness": {
    code: createCodingCode("102830001", "Renal angle tenderness (finding)"),
    bodySite: createCodingCode("91773002", "Structure of costovertebral angle of twelfth rib (body structure)")
  },
  // >>> CARD = skin
  // >> GROUP = normal
  "no-rashes": {
    code: createCodingCode("225544001", "Skin appearance normal (finding)"),
    bodySite: createCodingCode("39937001", "Skin structure (body structure)")
  },
  // >> GROUP = form
  "consistent-with-viral-exam": {
    code: createCodingCode("271756005", "Macular eruption (disorder)"),
    bodySite: createCodingCode("22943007", "Trunk structure (body structure)")
  },
  "consistent-with-insect-bites": {
    code: createCodingCode("276433004", "Insect bite - wound (disorder)")
  },
  "consistent-with-urticaria": {
    code: createCodingCode("126485001", "Urticaria (disorder)")
  },
  "consistent-with-coxsackievirus": {
    code: createCodingCode("240546009", "Coxsackie virus exanthem (disorder)")
  },
  "consistent-with-irritant-diaper-rash": {
    code: createCodingCode("91487003", "Diaper rash (disorder)"),
    bodySite: createCodingCode("264104007", "Structure of diaper area (body structure)")
  },
  "consistent-with-ringworm": {
    code: createCodingCode("47382004", "Dermatophytosis (disorder)"),
    bodySite: createCodingCode("48075008", "Structure of integumentary system (body structure)")
  },
  "consistent-with-impetigo": {
    code: createCodingCode("48277006", "Impetigo (disorder)"),
    bodySite: createCodingCode("39937001", "Skin structure (body structure)")
  },
  "consistent-with-fifths-disease": {
    code: createCodingCode("1264021005", "Eruption of skin of face (disorder)"),
    bodySite: createCodingCode("39937001", "Skin structure (body structure)")
  },
  "consistent-with-atopic-dermatitis": {
    code: createCodingCode("24079001", "Atopic dermatitis (disorder)"),
    bodySite: createCodingCode("39937001", "Skin structure (body structure)")
  },
  "consistent-with-paronychia": {
    code: createCodingCode("71906005", "Paronychia (disorder)"),
    bodySite: createCodingCode("280418005", "Periungual skin structure (body structure)")
  },
  "consistent-with-poison-ivy-contact-dermatitis": {
    code: createCodingCode("46259007", "Hedera helix poisoning (disorder)"),
    bodySite: createCodingCode("39937001", "Skin structure (body structure)")
  },
  "consistent-with-tinea-capitis": {
    code: createCodingCode("5441008", "Tinea capitis (disorder)"),
    bodySite: createCodingCode("64013008", "Structure of hair of scalp (body structure)")
  },
  "consistent-with-pityriasis-rosea": {
    code: createCodingCode("77252004", "Pityriasis rosea (disorder)"),
    bodySite: createCodingCode("39937001", "Skin structure (body structure)")
  },
  "consistent-with-lyme-ecm": {
    code: createCodingCode("23502006", "Lyme disease (disorder)"),
    bodySite: createCodingCode("39937001", "Skin structure (body structure)")
  },
  // >>> CARD = abdomen
  // >> GROUP = normal
  "normal-appearing-on-parental-exam": {
    code: createCodingCode("163133003", "Abdomen examined - no abnormality detected (finding)"),
    bodySite: createCodingCode(
      "818983003",
      "Structure of abdominopelvic cavity and/or content of abdominopelvic cavity and/or anterior abdominal wall (body structure)"
    )
  },
  "non-tender-on-parental-exam": {
    code: createCodingCode("297125009", "Abdominal tenderness absent (situation)"),
    bodySite: createCodingCode(
      "818983003",
      "Structure of abdominopelvic cavity and/or content of abdominopelvic cavity and/or anterior abdominal wall (body structure)"
    )
  },
  "able-to-jump-up-down-without-abdominal-pain": {
    code: createCodingCode("282600008", "Able to jump (finding)"),
    bodySite: createCodingCode("108350001", "Structure of abdomen excluding retroperitoneal region (body structure)")
  },
  // >> GROUP = abnormal
  "left-lower-quadrant-abdomen": {
    code: createCodingCode("68505006", "Structure of left lower quadrant of abdomen (body structure)")
  },
  "right-lower-quadrant-abdomen": {
    code: createCodingCode("48544008", "Structure of right lower quadrant of abdomen (body structure)")
  },
  "right-upper-quadrant-abdomen": {
    code: createCodingCode("50519007", "Structure of right upper quadrant of abdomen (body structure)")
  },
  "left-upper-quadrant-abdomen": {
    code: createCodingCode("86367003", "Structure of left upper quadrant of abdomen (body structure)")
  },
  "epigastric-region-abdomen": {
    code: createCodingCode("27947004", "Epigastric region structure (body structure)")
  },
  "left-abdominal-lumbar-region-abdomen": {
    code: createCodingCode("1017212007", "Structure of left abdominal lumbar region (body structure)")
  },
  "right-abdominal-lumbar-region-abdomen": {
    code: createCodingCode("1017213002", "Structure of right abdominal lumbar region (body structure)")
  },
  "not-able-to-jump-up-down-due-to-abdominal-pain": {
    code: createCodingCode("282600008", "Able to jump (finding)"),
    bodySite: createCodingCode("108350001", "Structure of abdomen excluding retroperitoneal region (body structure)")
  },
  // >>> CARD = musculoskeletal
  // >> GROUP = normal
  "moving-extemities-equally": {
    code: createCodingCode("20658008", "Normal muscle function (finding)"),
    bodySite: createCodingCode("71616004", "Skeletal and/or smooth muscle structure (body structure)")
  },
  "normal-gait": {
    code: createCodingCode("8117002", "Gait normal (finding)"),
    bodySite: createCodingCode("71616004", "Skeletal and/or smooth muscle structure (body structure)")
  },
  "normal-rom": {
    code: createCodingCode("364564000", "Range of joint movement (observable entity)"),
    bodySite: createCodingCode("71616004", "Skeletal and/or smooth muscle structure (body structure)")
  },
  "no-swelling": {
    code: createCodingCode("65124004", "Swelling (finding)")
  },
  "no-bruising": {
    code: createCodingCode("297950006", "Finding related to bruising (finding)")
  },
  "no-deformity": {
    code: createCodingCode("417893002", "Deformity (finding)")
  },
  // >> GROUP = form
  "swelling-left-finger-index": {
    code: createCodingCode("65124006", "Swelling (finding)"),
    bodySite: createCodingCode("770841009", "Structure of left index finger (body structure)")
  },
  "swelling-right-finger-index": {
    code: createCodingCode("65124007", "Swelling (finding)"),
    bodySite: createCodingCode("770842002", "Structure of right index finger (body structure)")
  },
  "swelling-left-finger-middle": {
    code: createCodingCode("65124008", "Swelling (finding)"),
    bodySite: createCodingCode("770884005", "Structure of left middle finger (body structure)")
  },
  "swelling-right-finger-middle": {
    code: createCodingCode("65124009", "Swelling (finding)"),
    bodySite: createCodingCode("770885006", "Structure of right middle finger (body structure)")
  },
  "swelling-left-finger-ring": {
    code: createCodingCode("65124010", "Swelling (finding)"),
    bodySite: createCodingCode("770882009", "Structure of left ring finger (body structure)")
  },
  "swelling-right-finger-ring": {
    code: createCodingCode("65124011", "Swelling (finding)"),
    bodySite: createCodingCode("770883004", "Structure of right ring finger (body structure)")
  },
  "swelling-left-finger-little": {
    code: createCodingCode("65124014", "Swelling (finding)"),
    bodySite: createCodingCode("762101005", "Structure of left little finger (body structure)")
  },
  "swelling-right-finger-little": {
    code: createCodingCode("65124015", "Swelling (finding)"),
    bodySite: createCodingCode("762102003", "Structure of right little finger (body structure)")
  },
  "swelling-left-finger-thumb": {
    code: createCodingCode("65124016", "Swelling (finding)"),
    bodySite: createCodingCode("734143007", "Structure of left thumb (body structure)")
  },
  "swelling-right-finger-thumb": {
    code: createCodingCode("65124017", "Swelling (finding)"),
    bodySite: createCodingCode("734144001", "Structure of right thumb (body structure)")
  },
  "swelling-left-hand": {
    code: createCodingCode("65124018", "Swelling (finding)"),
    bodySite: createCodingCode("85151006", "Structure of left hand (body structure)")
  },
  "swelling-right-hand": {
    code: createCodingCode("65124019", "Swelling (finding)"),
    bodySite: createCodingCode("78791008", "Structure of right hand (body structure)")
  },
  "swelling-left-foot": {
    code: createCodingCode("65124020", "Swelling (finding)"),
    bodySite: createCodingCode("239919000", "Entire left foot (body structure)")
  },
  "swelling-right-foot": {
    code: createCodingCode("65124021", "Swelling (finding)"),
    bodySite: createCodingCode("239830003", "Entire right foot (body structure)")
  },
  "swelling-left-toe-great": {
    code: createCodingCode("65124024", "Swelling (finding)"),
    bodySite: createCodingCode("723724004", "Structure of left great toe (body structure)")
  },
  "swelling-right-toe-great": {
    code: createCodingCode("65124025", "Swelling (finding)"),
    bodySite: createCodingCode("723730004", "Structure of right great toe (body structure)")
  },
  "swelling-left-toe-second": {
    code: createCodingCode("65124026", "Swelling (finding)"),
    bodySite: createCodingCode("1285624003", "Structure of left second toe (body structure)")
  },
  "swelling-right-toe-second": {
    code: createCodingCode("65124027", "Swelling (finding)"),
    bodySite: createCodingCode("1285623009", "Structure of right second toe (body structure)")
  },
  "swelling-left-toe-third": {
    code: createCodingCode("65124028", "Swelling (finding)"),
    bodySite: createCodingCode("1285627005", "Structure of left third toe (body structure)")
  },
  "swelling-right-toe-third": {
    code: createCodingCode("65124029", "Swelling (finding)"),
    bodySite: createCodingCode("1285628000", "Structure of right third toe (body structure)")
  },
  "swelling-left-toe-fourth": {
    code: createCodingCode("65124030", "Swelling (finding)"),
    bodySite: createCodingCode("1285632006", "Structure of left fourth toe (body structure)")
  },
  "swelling-right-toe-fourth": {
    code: createCodingCode("65124031", "Swelling (finding)"),
    bodySite: createCodingCode("1285633001", "Structure of right fourth toe (body structure)")
  },
  "swelling-left-toe-fifth": {
    code: createCodingCode("65124032", "Swelling (finding)"),
    bodySite: createCodingCode("895650002", "Structure of fifth toe of left foot (body structure)")
  },
  "swelling-right-toe-fifth": {
    code: createCodingCode("65124033", "Swelling (finding)"),
    bodySite: createCodingCode("895651003", "Structure of fifth toe of right foot (body structure)")
  },
  "swelling-left-wrist": {
    code: createCodingCode("65124036", "Swelling (finding)"),
    bodySite: createCodingCode("5951000", "Structure of left wrist region (body structure)")
  },
  "swelling-right-wrist": {
    code: createCodingCode("65124037", "Swelling (finding)"),
    bodySite: createCodingCode("9736006", "Structure of right wrist region (body structure)")
  },
  "swelling-left-forearm": {
    code: createCodingCode("65124038", "Swelling (finding)"),
    bodySite: createCodingCode("66480008", "Structure of left forearm (body structure)")
  },
  "swelling-right-forearm": {
    code: createCodingCode("65124039", "Swelling (finding)"),
    bodySite: createCodingCode("64262003", "Structure of right forearm (body structure)")
  },
  "swelling-left-elbow": {
    code: createCodingCode("65124040", "Swelling (finding)"),
    bodySite: createCodingCode("368148009", "Left elbow region structure (body structure)")
  },
  "swelling-right-elbow": {
    code: createCodingCode("65124041", "Swelling (finding)"),
    bodySite: createCodingCode("368149001", "Right elbow region structure (body structure)")
  },
  "swelling-left-upperarm": {
    code: createCodingCode("65124042", "Swelling (finding)"),
    bodySite: createCodingCode("368208006", "Left upper arm structure (body structure)")
  },
  "swelling-right-upperarm": {
    code: createCodingCode("65124043", "Swelling (finding)"),
    bodySite: createCodingCode("368209003", "Right upper arm structure (body structure)")
  },
  "swelling-left-shoulder": {
    code: createCodingCode("65124044", "Swelling (finding)"),
    bodySite: createCodingCode("91775009", "Structure of left shoulder region (body structure)")
  },
  "swelling-right-shoulder": {
    code: createCodingCode("65124045", "Swelling (finding)"),
    bodySite: createCodingCode("91774008", "Structure of right shoulder region (body structure)")
  },
  "swelling-left-knee": {
    code: createCodingCode("65124046", "Swelling (finding)"),
    bodySite: createCodingCode("82169009", "Structure of left knee region (body structure)")
  },
  "swelling-right-knee": {
    code: createCodingCode("65124047", "Swelling (finding)"),
    bodySite: createCodingCode("6757004", "Structure of right knee region (body structure)")
  },
  "swelling-left-lowerleg": {
    code: createCodingCode("65124048", "Swelling (finding)"),
    bodySite: createCodingCode("48979004", "Structure of left lower leg (body structure)")
  },
  "swelling-right-lowerleg": {
    code: createCodingCode("65124049", "Swelling (finding)"),
    bodySite: createCodingCode("32696007", "Structure of right lower leg (body structure)")
  },
  "swelling-left-ankle": {
    code: createCodingCode("65124050", "Swelling (finding)"),
    bodySite: createCodingCode("51636004", "Structure of left ankle (body structure)")
  },
  "swelling-right-ankle": {
    code: createCodingCode("65124051", "Swelling (finding)"),
    bodySite: createCodingCode("6685009", "Structure of right ankle (body structure)")
  },
  "deformity-left-finger-index": {
    code: createCodingCode("417893004", "Deformity (finding)"),
    bodySite: createCodingCode("770841009", "Structure of left index finger (body structure)")
  },
  "deformity-right-finger-index": {
    code: createCodingCode("417893005", "Deformity (finding)"),
    bodySite: createCodingCode("770842002", "Structure of right index finger (body structure)")
  },
  "deformity-left-finger-middle": {
    code: createCodingCode("417893006", "Deformity (finding)"),
    bodySite: createCodingCode("770884005", "Structure of left middle finger (body structure)")
  },
  "deformity-right-finger-middle": {
    code: createCodingCode("417893007", "Deformity (finding)"),
    bodySite: createCodingCode("770885006", "Structure of right middle finger (body structure)")
  },
  "deformity-left-finger-ring": {
    code: createCodingCode("417893008", "Deformity (finding)"),
    bodySite: createCodingCode("770882009", "Structure of left ring finger (body structure)")
  },
  "deformity-right-finger-ring": {
    code: createCodingCode("417893009", "Deformity (finding)"),
    bodySite: createCodingCode("770883004", "Structure of right ring finger (body structure)")
  },
  "deformity-left-finger-little": {
    code: createCodingCode("417893012", "Deformity (finding)"),
    bodySite: createCodingCode("762101005", "Structure of left little finger (body structure)")
  },
  "deformity-right-finger-little": {
    code: createCodingCode("417893013", "Deformity (finding)"),
    bodySite: createCodingCode("762102003", "Structure of right little finger (body structure)")
  },
  "deformity-left-finger-thumb": {
    code: createCodingCode("417893014", "Deformity (finding)"),
    bodySite: createCodingCode("734143007", "Structure of left thumb (body structure)")
  },
  "deformity-right-finger-thumb": {
    code: createCodingCode("417893015", "Deformity (finding)"),
    bodySite: createCodingCode("734144001", "Structure of right thumb (body structure)")
  },
  "deformity-left-hand": {
    code: createCodingCode("417893016", "Deformity (finding)"),
    bodySite: createCodingCode("85151006", "Structure of left hand (body structure)")
  },
  "deformity-right-hand": {
    code: createCodingCode("417893017", "Deformity (finding)"),
    bodySite: createCodingCode("78791008", "Structure of right hand (body structure)")
  },
  "deformity-left-foot": {
    code: createCodingCode("417893018", "Deformity (finding)"),
    bodySite: createCodingCode("239919000", "Entire left foot (body structure)")
  },
  "deformity-right-foot": {
    code: createCodingCode("417893019", "Deformity (finding)"),
    bodySite: createCodingCode("239830003", "Entire right foot (body structure)")
  },
  "deformity-left-toe-great": {
    code: createCodingCode("417893022", "Deformity (finding)"),
    bodySite: createCodingCode("723724004", "Structure of left great toe (body structure)")
  },
  "deformity-right-toe-great": {
    code: createCodingCode("417893023", "Deformity (finding)"),
    bodySite: createCodingCode("723730004", "Structure of right great toe (body structure)")
  },
  "deformity-left-toe-second": {
    code: createCodingCode("417893024", "Deformity (finding)"),
    bodySite: createCodingCode("1285624003", "Structure of left second toe (body structure)")
  },
  "deformity-right-toe-second": {
    code: createCodingCode("417893025", "Deformity (finding)"),
    bodySite: createCodingCode("1285623009", "Structure of right second toe (body structure)")
  },
  "deformity-left-toe-third": {
    code: createCodingCode("417893026", "Deformity (finding)"),
    bodySite: createCodingCode("1285627005", "Structure of left third toe (body structure)")
  },
  "deformity-right-toe-third": {
    code: createCodingCode("417893027", "Deformity (finding)"),
    bodySite: createCodingCode("1285628000", "Structure of right third toe (body structure)")
  },
  "deformity-left-toe-fourth": {
    code: createCodingCode("417893028", "Deformity (finding)"),
    bodySite: createCodingCode("1285632006", "Structure of left fourth toe (body structure)")
  },
  "deformity-right-toe-fourth": {
    code: createCodingCode("417893029", "Deformity (finding)"),
    bodySite: createCodingCode("1285633001", "Structure of right fourth toe (body structure)")
  },
  "deformity-left-toe-fifth": {
    code: createCodingCode("417893030", "Deformity (finding)"),
    bodySite: createCodingCode("895650002", "Structure of fifth toe of left foot (body structure)")
  },
  "deformity-right-toe-fifth": {
    code: createCodingCode("417893031", "Deformity (finding)"),
    bodySite: createCodingCode("895651003", "Structure of fifth toe of right foot (body structure)")
  },
  "deformity-left-wrist": {
    code: createCodingCode("417893034", "Deformity (finding)"),
    bodySite: createCodingCode("5951000", "Structure of left wrist region (body structure)")
  },
  "deformity-right-wrist": {
    code: createCodingCode("417893035", "Deformity (finding)"),
    bodySite: createCodingCode("9736006", "Structure of right wrist region (body structure)")
  },
  "deformity-left-forearm": {
    code: createCodingCode("417893036", "Deformity (finding)"),
    bodySite: createCodingCode("66480008", "Structure of left forearm (body structure)")
  },
  "deformity-right-forearm": {
    code: createCodingCode("417893037", "Deformity (finding)"),
    bodySite: createCodingCode("64262003", "Structure of right forearm (body structure)")
  },
  "deformity-left-elbow": {
    code: createCodingCode("417893038", "Deformity (finding)"),
    bodySite: createCodingCode("368148009", "Left elbow region structure (body structure)")
  },
  "deformity-right-elbow": {
    code: createCodingCode("417893039", "Deformity (finding)"),
    bodySite: createCodingCode("368149001", "Right elbow region structure (body structure)")
  },
  "deformity-left-upperarm": {
    code: createCodingCode("417893040", "Deformity (finding)"),
    bodySite: createCodingCode("368208006", "Left upper arm structure (body structure)")
  },
  "deformity-right-upperarm": {
    code: createCodingCode("417893041", "Deformity (finding)"),
    bodySite: createCodingCode("368209003", "Right upper arm structure (body structure)")
  },
  "deformity-left-shoulder": {
    code: createCodingCode("417893042", "Deformity (finding)"),
    bodySite: createCodingCode("91775009", "Structure of left shoulder region (body structure)")
  },
  "deformity-right-shoulder": {
    code: createCodingCode("417893043", "Deformity (finding)"),
    bodySite: createCodingCode("91774008", "Structure of right shoulder region (body structure)")
  },
  "deformity-left-knee": {
    code: createCodingCode("417893044", "Deformity (finding)"),
    bodySite: createCodingCode("82169009", "Structure of left knee region (body structure)")
  },
  "deformity-right-knee": {
    code: createCodingCode("417893045", "Deformity (finding)"),
    bodySite: createCodingCode("6757004", "Structure of right knee region (body structure)")
  },
  "deformity-left-lowerleg": {
    code: createCodingCode("417893046", "Deformity (finding)"),
    bodySite: createCodingCode("48979004", "Structure of left lower leg (body structure)")
  },
  "deformity-right-lowerleg": {
    code: createCodingCode("417893047", "Deformity (finding)"),
    bodySite: createCodingCode("32696007", "Structure of right lower leg (body structure)")
  },
  "deformity-left-ankle": {
    code: createCodingCode("417893048", "Deformity (finding)"),
    bodySite: createCodingCode("51636004", "Structure of left ankle (body structure)")
  },
  "deformity-right-ankle": {
    code: createCodingCode("417893049", "Deformity (finding)"),
    bodySite: createCodingCode("6685009", "Structure of right ankle (body structure)")
  },
  "bruising-left-finger-index": {
    code: createCodingCode("297950008", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("770841009", "Structure of left index finger (body structure)")
  },
  "bruising-right-finger-index": {
    code: createCodingCode("297950009", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("770842002", "Structure of right index finger (body structure)")
  },
  "bruising-left-finger-middle": {
    code: createCodingCode("297950010", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("770884005", "Structure of left middle finger (body structure)")
  },
  "bruising-right-finger-middle": {
    code: createCodingCode("297950011", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("770885006", "Structure of right middle finger (body structure)")
  },
  "bruising-left-finger-ring": {
    code: createCodingCode("297950012", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("770882009", "Structure of left ring finger (body structure)")
  },
  "bruising-right-finger-ring": {
    code: createCodingCode("297950013", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("770883004", "Structure of right ring finger (body structure)")
  },
  "bruising-left-finger-little": {
    code: createCodingCode("297950016", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("762101005", "Structure of left little finger (body structure)")
  },
  "bruising-right-finger-little": {
    code: createCodingCode("297950017", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("762102003", "Structure of right little finger (body structure)")
  },
  "bruising-left-finger-thumb": {
    code: createCodingCode("297950018", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("734143007", "Structure of left thumb (body structure)")
  },
  "bruising-right-finger-thumb": {
    code: createCodingCode("297950019", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("734144001", "Structure of right thumb (body structure)")
  },
  "bruising-left-hand": {
    code: createCodingCode("297950020", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("85151006", "Structure of left hand (body structure)")
  },
  "bruising-right-hand": {
    code: createCodingCode("297950021", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("78791008", "Structure of right hand (body structure)")
  },
  "bruising-left-foot": {
    code: createCodingCode("297950022", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("239919000", "Entire left foot (body structure)")
  },
  "bruising-right-foot": {
    code: createCodingCode("297950023", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("239830003", "Entire right foot (body structure)")
  },
  "bruising-left-toe-great": {
    code: createCodingCode("297950026", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("723724004", "Structure of left great toe (body structure)")
  },
  "bruising-right-toe-great": {
    code: createCodingCode("297950027", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("723730004", "Structure of right great toe (body structure)")
  },
  "bruising-left-toe-second": {
    code: createCodingCode("297950028", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("1285624003", "Structure of left second toe (body structure)")
  },
  "bruising-right-toe-second": {
    code: createCodingCode("297950029", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("1285623009", "Structure of right second toe (body structure)")
  },
  "bruising-left-toe-third": {
    code: createCodingCode("297950030", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("1285627005", "Structure of left third toe (body structure)")
  },
  "bruising-right-toe-third": {
    code: createCodingCode("297950031", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("1285628000", "Structure of right third toe (body structure)")
  },
  "bruising-left-toe-fourth": {
    code: createCodingCode("297950032", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("1285632006", "Structure of left fourth toe (body structure)")
  },
  "bruising-right-toe-fourth": {
    code: createCodingCode("297950033", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("1285633001", "Structure of right fourth toe (body structure)")
  },
  "bruising-left-toe-fifth": {
    code: createCodingCode("297950034", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("895650002", "Structure of fifth toe of left foot (body structure)")
  },
  "bruising-right-toe-fifth": {
    code: createCodingCode("297950035", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("895651003", "Structure of fifth toe of right foot (body structure)")
  },
  "bruising-left-wrist": {
    code: createCodingCode("297950038", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("5951000", "Structure of left wrist region (body structure)")
  },
  "bruising-right-wrist": {
    code: createCodingCode("297950039", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("9736006", "Structure of right wrist region (body structure)")
  },
  "bruising-left-forearm": {
    code: createCodingCode("297950040", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("66480008", "Structure of left forearm (body structure)")
  },
  "bruising-right-forearm": {
    code: createCodingCode("297950041", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("64262003", "Structure of right forearm (body structure)")
  },
  "bruising-left-elbow": {
    code: createCodingCode("297950042", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("368148009", "Left elbow region structure (body structure)")
  },
  "bruising-right-elbow": {
    code: createCodingCode("297950043", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("368149001", "Right elbow region structure (body structure)")
  },
  "bruising-left-upperarm": {
    code: createCodingCode("297950044", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("368208006", "Left upper arm structure (body structure)")
  },
  "bruising-right-upperarm": {
    code: createCodingCode("297950045", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("368209003", "Right upper arm structure (body structure)")
  },
  "bruising-left-shoulder": {
    code: createCodingCode("297950046", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("91775009", "Structure of left shoulder region (body structure)")
  },
  "bruising-right-shoulder": {
    code: createCodingCode("297950047", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("91774008", "Structure of right shoulder region (body structure)")
  },
  "bruising-left-knee": {
    code: createCodingCode("297950048", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("82169009", "Structure of left knee region (body structure)")
  },
  "bruising-right-knee": {
    code: createCodingCode("297950049", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("6757004", "Structure of right knee region (body structure)")
  },
  "bruising-left-lowerleg": {
    code: createCodingCode("297950050", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("48979004", "Structure of left lower leg (body structure)")
  },
  "bruising-right-lowerleg": {
    code: createCodingCode("297950051", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("32696007", "Structure of right lower leg (body structure)")
  },
  "bruising-left-ankle": {
    code: createCodingCode("297950052", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("51636004", "Structure of left ankle (body structure)")
  },
  "bruising-right-ankle": {
    code: createCodingCode("297950053", "Finding related to bruising (finding)"),
    bodySite: createCodingCode("6685009", "Structure of right ankle (body structure)")
  },
  "abletobearweight-left-finger-index": {
    code: createCodingCode("249981007", "Weight-bearing (finding)"),
    bodySite: createCodingCode("770841009", "Structure of left index finger (body structure)")
  },
  "abletobearweight-right-finger-index": {
    code: createCodingCode("249981008", "Weight-bearing (finding)"),
    bodySite: createCodingCode("770842002", "Structure of right index finger (body structure)")
  },
  "abletobearweight-left-finger-middle": {
    code: createCodingCode("249981009", "Weight-bearing (finding)"),
    bodySite: createCodingCode("770884005", "Structure of left middle finger (body structure)")
  },
  "abletobearweight-right-finger-middle": {
    code: createCodingCode("249981010", "Weight-bearing (finding)"),
    bodySite: createCodingCode("770885006", "Structure of right middle finger (body structure)")
  },
  "abletobearweight-left-finger-ring": {
    code: createCodingCode("249981011", "Weight-bearing (finding)"),
    bodySite: createCodingCode("770882009", "Structure of left ring finger (body structure)")
  },
  "abletobearweight-right-finger-ring": {
    code: createCodingCode("249981012", "Weight-bearing (finding)"),
    bodySite: createCodingCode("770883004", "Structure of right ring finger (body structure)")
  },
  "abletobearweight-left-finger-little": {
    code: createCodingCode("249981015", "Weight-bearing (finding)"),
    bodySite: createCodingCode("762101005", "Structure of left little finger (body structure)")
  },
  "abletobearweight-right-finger-little": {
    code: createCodingCode("249981016", "Weight-bearing (finding)"),
    bodySite: createCodingCode("762102003", "Structure of right little finger (body structure)")
  },
  "abletobearweight-left-finger-thumb": {
    code: createCodingCode("249981017", "Weight-bearing (finding)"),
    bodySite: createCodingCode("734143007", "Structure of left thumb (body structure)")
  },
  "abletobearweight-right-finger-thumb": {
    code: createCodingCode("249981018", "Weight-bearing (finding)"),
    bodySite: createCodingCode("734144001", "Structure of right thumb (body structure)")
  },
  "abletobearweight-left-hand": {
    code: createCodingCode("249981019", "Weight-bearing (finding)"),
    bodySite: createCodingCode("85151006", "Structure of left hand (body structure)")
  },
  "abletobearweight-right-hand": {
    code: createCodingCode("249981020", "Weight-bearing (finding)"),
    bodySite: createCodingCode("78791008", "Structure of right hand (body structure)")
  },
  "abletobearweight-left-foot": {
    code: createCodingCode("249981021", "Weight-bearing (finding)"),
    bodySite: createCodingCode("239919000", "Entire left foot (body structure)")
  },
  "abletobearweight-right-foot": {
    code: createCodingCode("249981022", "Weight-bearing (finding)"),
    bodySite: createCodingCode("239830003", "Entire right foot (body structure)")
  },
  "abletobearweight-left-toe-great": {
    code: createCodingCode("249981025", "Weight-bearing (finding)"),
    bodySite: createCodingCode("723724004", "Structure of left great toe (body structure)")
  },
  "abletobearweight-right-toe-great": {
    code: createCodingCode("249981026", "Weight-bearing (finding)"),
    bodySite: createCodingCode("723730004", "Structure of right great toe (body structure)")
  },
  "abletobearweight-left-toe-second": {
    code: createCodingCode("249981027", "Weight-bearing (finding)"),
    bodySite: createCodingCode("1285624003", "Structure of left second toe (body structure)")
  },
  "abletobearweight-right-toe-second": {
    code: createCodingCode("249981028", "Weight-bearing (finding)"),
    bodySite: createCodingCode("1285623009", "Structure of right second toe (body structure)")
  },
  "abletobearweight-left-toe-third": {
    code: createCodingCode("249981029", "Weight-bearing (finding)"),
    bodySite: createCodingCode("1285627005", "Structure of left third toe (body structure)")
  },
  "abletobearweight-right-toe-third": {
    code: createCodingCode("249981030", "Weight-bearing (finding)"),
    bodySite: createCodingCode("1285628000", "Structure of right third toe (body structure)")
  },
  "abletobearweight-left-toe-fourth": {
    code: createCodingCode("249981031", "Weight-bearing (finding)"),
    bodySite: createCodingCode("1285632006", "Structure of left fourth toe (body structure)")
  },
  "abletobearweight-right-toe-fourth": {
    code: createCodingCode("249981032", "Weight-bearing (finding)"),
    bodySite: createCodingCode("1285633001", "Structure of right fourth toe (body structure)")
  },
  "abletobearweight-left-toe-fifth": {
    code: createCodingCode("249981033", "Weight-bearing (finding)"),
    bodySite: createCodingCode("895650002", "Structure of fifth toe of left foot (body structure)")
  },
  "abletobearweight-right-toe-fifth": {
    code: createCodingCode("249981034", "Weight-bearing (finding)"),
    bodySite: createCodingCode("895651003", "Structure of fifth toe of right foot (body structure)")
  },
  "abletobearweight-left-wrist": {
    code: createCodingCode("249981037", "Weight-bearing (finding)"),
    bodySite: createCodingCode("5951000", "Structure of left wrist region (body structure)")
  },
  "abletobearweight-right-wrist": {
    code: createCodingCode("249981038", "Weight-bearing (finding)"),
    bodySite: createCodingCode("9736006", "Structure of right wrist region (body structure)")
  },
  "abletobearweight-left-forearm": {
    code: createCodingCode("249981039", "Weight-bearing (finding)"),
    bodySite: createCodingCode("66480008", "Structure of left forearm (body structure)")
  },
  "abletobearweight-right-forearm": {
    code: createCodingCode("249981040", "Weight-bearing (finding)"),
    bodySite: createCodingCode("64262003", "Structure of right forearm (body structure)")
  },
  "abletobearweight-left-elbow": {
    code: createCodingCode("249981041", "Weight-bearing (finding)"),
    bodySite: createCodingCode("368148009", "Left elbow region structure (body structure)")
  },
  "abletobearweight-right-elbow": {
    code: createCodingCode("249981042", "Weight-bearing (finding)"),
    bodySite: createCodingCode("368149001", "Right elbow region structure (body structure)")
  },
  "abletobearweight-left-upperarm": {
    code: createCodingCode("249981043", "Weight-bearing (finding)"),
    bodySite: createCodingCode("368208006", "Left upper arm structure (body structure)")
  },
  "abletobearweight-right-upperarm": {
    code: createCodingCode("249981044", "Weight-bearing (finding)"),
    bodySite: createCodingCode("368209003", "Right upper arm structure (body structure)")
  },
  "abletobearweight-left-shoulder": {
    code: createCodingCode("249981045", "Weight-bearing (finding)"),
    bodySite: createCodingCode("91775009", "Structure of left shoulder region (body structure)")
  },
  "abletobearweight-right-shoulder": {
    code: createCodingCode("249981046", "Weight-bearing (finding)"),
    bodySite: createCodingCode("91774008", "Structure of right shoulder region (body structure)")
  },
  "abletobearweight-left-knee": {
    code: createCodingCode("249981047", "Weight-bearing (finding)"),
    bodySite: createCodingCode("82169009", "Structure of left knee region (body structure)")
  },
  "abletobearweight-right-knee": {
    code: createCodingCode("249981048", "Weight-bearing (finding)"),
    bodySite: createCodingCode("6757004", "Structure of right knee region (body structure)")
  },
  "abletobearweight-left-lowerleg": {
    code: createCodingCode("249981049", "Weight-bearing (finding)"),
    bodySite: createCodingCode("48979004", "Structure of left lower leg (body structure)")
  },
  "abletobearweight-right-lowerleg": {
    code: createCodingCode("249981050", "Weight-bearing (finding)"),
    bodySite: createCodingCode("32696007", "Structure of right lower leg (body structure)")
  },
  "abletobearweight-left-ankle": {
    code: createCodingCode("249981051", "Weight-bearing (finding)"),
    bodySite: createCodingCode("51636004", "Structure of left ankle (body structure)")
  },
  "abletobearweight-right-ankle": {
    code: createCodingCode("249981052", "Weight-bearing (finding)"),
    bodySite: createCodingCode("6685009", "Structure of right ankle (body structure)")
  },
  "decreasedrom-left-finger-index": {
    code: createCodingCode("304309006", "Decreased range of finger movement (finding)"),
    bodySite: createCodingCode("770841009", "Structure of left index finger (body structure)")
  },
  "decreasedrom-right-finger-index": {
    code: createCodingCode("304309007", "Decreased range of finger movement (finding)"),
    bodySite: createCodingCode("770842002", "Structure of right index finger (body structure)")
  },
  "decreasedrom-left-finger-middle": {
    code: createCodingCode("304309008", "Decreased range of finger movement (finding)"),
    bodySite: createCodingCode("770884005", "Structure of left middle finger (body structure)")
  },
  "decreasedrom-right-finger-middle": {
    code: createCodingCode("304309009", "Decreased range of finger movement (finding)"),
    bodySite: createCodingCode("770885006", "Structure of right middle finger (body structure)")
  },
  "decreasedrom-left-finger-ring": {
    code: createCodingCode("304309010", "Decreased range of finger movement (finding)"),
    bodySite: createCodingCode("770882009", "Structure of left ring finger (body structure)")
  },
  "decreasedrom-right-finger-ring": {
    code: createCodingCode("304309011", "Decreased range of finger movement (finding)"),
    bodySite: createCodingCode("770883004", "Structure of right ring finger (body structure)")
  },
  "decreasedrom-left-finger-little": {
    code: createCodingCode("304309014", "Decreased range of finger movement (finding)"),
    bodySite: createCodingCode("762101005", "Structure of left little finger (body structure)")
  },
  "decreasedrom-right-finger-little": {
    code: createCodingCode("304309015", "Decreased range of finger movement (finding)"),
    bodySite: createCodingCode("762102003", "Structure of right little finger (body structure)")
  },
  "decreasedrom-left-finger-thumb": {
    code: createCodingCode("304313006", "Decreased range of thumb movement (finding)"),
    bodySite: createCodingCode("734143007", "Structure of left thumb (body structure)")
  },
  "decreasedrom-right-finger-thumb": {
    code: createCodingCode("304313006", "Decreased range of thumb movement (finding)"),
    bodySite: createCodingCode("734144001", "Structure of right thumb (body structure)")
  },
  "decreasedrom-left-hand": {
    code: createCodingCode("70733008", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("85151006", "Structure of left hand (body structure)")
  },
  "decreasedrom-right-hand": {
    code: createCodingCode("70733008", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("78791008", "Structure of right hand (body structure)")
  },
  "decreasedrom-left-foot": {
    code: createCodingCode("304330008", "Decreased range of foot movement (finding)"),
    bodySite: createCodingCode("239919000", "Entire left foot (body structure)")
  },
  "decreasedrom-right-foot": {
    code: createCodingCode("304330008", "Decreased range of foot movement (finding)"),
    bodySite: createCodingCode("239830003", "Entire right foot (body structure)")
  },
  "decreasedrom-left-toe-great": {
    code: createCodingCode("70733010", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("723724004", "Structure of left great toe (body structure)")
  },
  "decreasedrom-right-toe-great": {
    code: createCodingCode("70733011", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("723730004", "Structure of right great toe (body structure)")
  },
  "decreasedrom-left-toe-second": {
    code: createCodingCode("70733012", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("1285624003", "Structure of left second toe (body structure)")
  },
  "decreasedrom-right-toe-second": {
    code: createCodingCode("70733013", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("1285623009", "Structure of right second toe (body structure)")
  },
  "decreasedrom-left-toe-third": {
    code: createCodingCode("70733014", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("1285627005", "Structure of left third toe (body structure)")
  },
  "decreasedrom-right-toe-third": {
    code: createCodingCode("70733015", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("1285628000", "Structure of right third toe (body structure)")
  },
  "decreasedrom-left-toe-fourth": {
    code: createCodingCode("70733016", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("1285632006", "Structure of left fourth toe (body structure)")
  },
  "decreasedrom-right-toe-fourth": {
    code: createCodingCode("70733017", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("1285633001", "Structure of right fourth toe (body structure)")
  },
  "decreasedrom-left-toe-fifth": {
    code: createCodingCode("70733018", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("895650002", "Structure of fifth toe of left foot (body structure)")
  },
  "decreasedrom-right-toe-fifth": {
    code: createCodingCode("70733019", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("895651003", "Structure of fifth toe of right foot (body structure)")
  },
  "decreasedrom-left-wrist": {
    code: createCodingCode("304305005", "Decreased range of wrist movement (finding)"),
    bodySite: createCodingCode("5951000", "Structure of left wrist region (body structure)")
  },
  "decreasedrom-right-wrist": {
    code: createCodingCode("304305005", "Decreased range of wrist movement (finding)"),
    bodySite: createCodingCode("9736006", "Structure of right wrist region (body structure)")
  },
  "decreasedrom-left-forearm": {
    code: createCodingCode("70733008", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("66480008", "Structure of left forearm (body structure)")
  },
  "decreasedrom-right-forearm": {
    code: createCodingCode("70733008", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("64262003", "Structure of right forearm (body structure)")
  },
  "decreasedrom-left-elbow": {
    code: createCodingCode("304301001", "Decreased range of elbow movement (finding)"),
    bodySite: createCodingCode("368148009", "Left elbow region structure (body structure)")
  },
  "decreasedrom-right-elbow": {
    code: createCodingCode("304301001", "Decreased range of elbow movement (finding)"),
    bodySite: createCodingCode("368149001", "Right elbow region structure (body structure)")
  },
  "decreasedrom-left-upperarm": {
    code: createCodingCode("70733008", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("368208006", "Left upper arm structure (body structure)")
  },
  "decreasedrom-right-upperarm": {
    code: createCodingCode("70733009", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("368209003", "Right upper arm structure (body structure)")
  },
  "decreasedrom-left-shoulder": {
    code: createCodingCode("70733010", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("91775009", "Structure of left shoulder region (body structure)")
  },
  "decreasedrom-right-shoulder": {
    code: createCodingCode("70733011", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("91774008", "Structure of right shoulder region (body structure)")
  },
  "decreasedrom-left-knee": {
    code: createCodingCode("70733012", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("82169009", "Structure of left knee region (body structure)")
  },
  "decreasedrom-right-knee": {
    code: createCodingCode("70733013", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("6757004", "Structure of right knee region (body structure)")
  },
  "decreasedrom-left-lowerleg": {
    code: createCodingCode("70733014", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("48979004", "Structure of left lower leg (body structure)")
  },
  "decreasedrom-right-lowerleg": {
    code: createCodingCode("70733015", "Limitation of joint movement (finding)"),
    bodySite: createCodingCode("32696007", "Structure of right lower leg (body structure)")
  },
  "decreasedrom-left-ankle": {
    code: createCodingCode("304326005", "Decreased range of ankle movement (finding)"),
    bodySite: createCodingCode("51636004", "Structure of left ankle (body structure)")
  },
  "decreasedrom-right-ankle": {
    code: createCodingCode("304326005", "Decreased range of ankle movement (finding)"),
    bodySite: createCodingCode("6685009", "Structure of right ankle (body structure)")
  },
  // >>> CARD = neurological
  // >> GROUP = normal
  "normal-mental-status": {
    code: createCodingCode("17326005", "Well in self (finding)")
  },
  // >>> CARD = psych
  // >> GROUP = normal
  "normal-affect": {
    code: createCodingCode("134417007", "Level of mood - normal (finding)")
  },
  "good-eye-contact": {
    code: createCodingCode("400968009", "Maintains good eye contact (finding)")
  },
  // >> GROUP = abnormal
  "depressed-affect": {
    code: createCodingCode("366979004", "Depressed mood (finding)")
  },
  "poor-eye-contact": {
    code: createCodingCode("412786000", "Poor eye contact (finding)")
  }
};
var inPersonExamFieldsMap = {
  // >>> CARD = general
  "well-appearing": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "well-nourished": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "in-no-distress": {
    code: createCodingCode("69328002", "Distress (finding)")
  },
  "oriented-general": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "general-normal-mood-and-affect": {
    code: createCodingCode("134417007", "Level of mood - normal (finding)")
  },
  "ambulating-without-difficulty": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-general": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = skin
  "good-turgor": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "no-rash-unusual-bruising-or-prominent-lesions": {
    code: createCodingCode("225544001", "Skin appearance normal (finding)"),
    bodySite: createCodingCode("39937001", "Skin structure (body structure)")
  },
  "abnormal-skin": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = hair
  "normal-texture-and-distribution": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-hair": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = nails
  "normal-color-no-deformities": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-nails": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = head
  normocephalic: {
    code: createCodingCode("17621005", "Normal (qualifier value)"),
    bodySite: createCodingCode("302548004", "Entire head (body structure)")
  },
  atraumatic: {
    code: createCodingCode("1149217004", "No traumatic injury (situation)"),
    bodySite: createCodingCode("302548004", "Entire head (body structure)")
  },
  "no-visible-or-palpable-masses-depressions-or-scaring": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-head": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = eyes
  "visual-acuity-intact": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "conjunctiva-clear": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "sclera-non-icteric": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "eom-intact": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  perrl: {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "fundi-have-normal-optic-discs-and-vessels": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "no-exudates-or-hemorrhages": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-eyes": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = ears
  "eacs-clear": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "tms-translucent-mobile": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "ossicles-nl-appearance": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "hearing-intact": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-ears": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = nose
  "no-external-lesions": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "nose-mucosa-non-inflamed": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "septum-and-turbinates-normal": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-nose": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = mouth
  "mucous-membranes-moist": {
    code: createCodingCode("276398005", "Moist oral mucosa (finding)"),
    bodySite: createCodingCode("123851003", "Mouth region structure (body structure)")
  },
  "no-mucosal-lesions": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-mouth": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = teeth
  "no-obvious-caries-or-periodontal-disease": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "no-gingival-inflammation-or-significant-resorption": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-teeth": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = pharynx
  "pharynx-mucosa-non-inflamed": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "no-tonsillar-hypertrophy-or-exudate": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-pharynx": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = neck
  supple: {
    code: createCodingCode("48162006", "Supple (qualifier value)"),
    bodySite: createCodingCode("45048000", "Neck structure (body structure)")
  },
  "without-lesions-bruits-or-adenopathy": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "thyroid-non-enlarged-and-non-tender": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-neck": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = heart
  "no-cardiomegaly-or-thrills": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "regular-rate-and-rhythm": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "no-murmur-or-gallop": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-heart": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = lungs
  "clear-to-auscultation-and-percussion": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "pulmonary-effort-is-normal": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "no-respiratory-distress": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "there-are-no-wheezing": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "there-are-no-rales": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-lungs": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = abdomen
  "no-bloating": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "bowel-sounds-normal": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "no-tenderness-organomegaly-masses-or-hernia": {
    code: createCodingCode("297125009", "Abdominal tenderness absent (situation)"),
    bodySite: createCodingCode(
      "818983003",
      "Structure of abdominopelvic cavity and/or content of abdominopelvic cavity and/or anterior abdominal wall (body structure)"
    )
  },
  "abnormal-abdomen": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = back
  "spine-normal-without-deformity-or-tenderness": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "no-cva-tenderness": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-back": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = rectal
  "normal-sphincter-tone": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "no-hemorrhoids-or-masses-palpable": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-rectal": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = extremities
  "no-amputations-or-deformities-cyanosis-edema-or-varicosities": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "peripheral-pulses-intact": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-extremities": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = musculoskeletal
  "normal-gait-and-station": {
    code: createCodingCode("8117002", "Gait normal (finding)"),
    bodySite: createCodingCode("71616004", "Skeletal and/or smooth muscle structure (body structure)")
  },
  "no-misalignment": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-musculoskeletal": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = neurologic
  "mental-status:-the-patient-is-alert": {
    code: createCodingCode("17326005", "Well in self (finding)")
  },
  "cn-2-12-normal": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "sensation-to-pain-touch-and-proprioception-normal": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "dtrs-normal-in-upper-and-lower-extremities": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "no-pathologic-reflexes": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "abnormal-neurologic": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  // >>> CARD = psychiatric
  "oriented-psychiatric": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "intact-recent-and-remote-memory-judgment-and-insight": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  },
  "psychiatric-normal-mood-and-affect": {
    code: createCodingCode("134417007", "Level of mood - normal (finding)")
  },
  "abnormal-psychiatric": {
    code: createCodingCode("000000001", "Dummy SNOMED code")
  }
};

// ../../utils/lib/types/api/insurances.constants.ts
var ENABLE_ELIGIBILITY_CHECK_KEY = "enabledEligibilityCheck";
var INSURANCE_SETTINGS_MAP = {
  requiresSubscriberId: "Requires Subscriber Id",
  requiresSubscriberName: "Requires Subscriber Name",
  requiresSubscriberDOB: "Requires Subscriber Date Of Birth",
  requiresRelationshipToSubscriber: "Requires Relationship To Subscriber",
  requiresInsuranceName: "Requires Insurance Name",
  requiresInsuranceCardImage: "Requires Insurance Card Images (Telemed Only)",
  requiresFacilityNPI: "Requires Facility NPI",
  requiresStateUID: "Requires State UID",
  [ENABLE_ELIGIBILITY_CHECK_KEY]: "Insurance eligibility check"
};

// ../../utils/lib/types/api/practitioner.types.ts
var PractitionerQualificationCodesLabels = {
  "CSW-PIP": "Clinical Social Worker-Private Independent Practice",
  "FITNESS-PROFESSI": "Fitness Professional (not a standardized code)",
  "LISW-CP": "Licensed Independent Social Worker-Clinical Practice",
  "PHARMACY-ASSISTA": "Pharmacy Assistant (not a standardized code)",
  "PODIATRIC-ASSIST": "Podiatric Assistant (may vary by state)",
  CISW: "Certified Independent Social Worker",
  CMSW: "Clinical Master Social Worker",
  COUNSELOR: "Counselor",
  ISW: "Independent Social Worker",
  MLSW: "Master of Social Work",
  ORTH: "",
  RHMCI: "",
  DO: "Doctor of Osteopathic Medicine",
  MD: "Doctor of Medicine",
  PA: "Physician Assistant",
  RN: "Registered Nurse",
  NP: "Nurse Practitioner",
  CNM: "Certified Nurse Midwife",
  PMHNP: "Psychiatric Mental Health Nurse Practitioner",
  RNFA: "Registered Nurse First Assistant",
  ACSW: "Master's level Clinical Social Worker",
  APCC: "Advanced Practice Clinical Counselor",
  BCBA: "Board Certified Behavior Analyst",
  BCaBA: "Board Certified Assistant Behavior Analyst",
  BHA: "Bachelor of Health Administration",
  BHARI: "Behavioral Health Associate in Recovery",
  OD: "Doctor of Optometry",
  DPM: "Doctor of Podiatric Medicine",
  DA: "Dental Assistant",
  DDS: "Doctor of Dental Surgery",
  DEH: "Dental Hygienist",
  DMD: "Doctor of Dental Medicine",
  DPT: "Doctor of Physical Therapy",
  PT: "Physical Therapist",
  PTA: "Physical Therapist Assistant",
  PBT: "Physical Therapist Aide",
  LCADC: "Licensed Clinical Alcohol and Drug Counselor",
  LCAT: "Licensed Marriage and Family Therapist",
  LCMHC: "Licensed Clinical Mental Health Counselor",
  "LCMHC-S": "Licensed Clinical Mental Health Counselor Supervisor",
  LCMHCA: "Licensed Clinical Mental Health Counselor Associate",
  LCPC: "Licensed Clinical Professional Counselor",
  LCSW: "Licensed Clinical Social Worker",
  LSW: "Licensed Social Worker",
  LCSWA: "Licensed Certified Social Worker Assistant",
  LICSW: "Licensed Independent Clinical Social Worker",
  "LIMHP-CSW": "Licensed Independent Mental Health Professional-Clinical Social Worker",
  "LIMHP-CMSW": "Licensed Independent Mental Health Professional-Clinical Master Social Worker",
  LIMHP: "Licensed Independent Mental Health Professional (followed by specific area)",
  LISW: "Licensed Independent Social Worker",
  LMFT: "Licensed Marriage and Family Therapist",
  "LMFT-S": "Licensed Marriage and Family Therapist Supervisor",
  LMFTA: "Licensed Marriage and Family Therapist Associate",
  LMHC: "Licensed Mental Health Counselor (may vary by state)",
  LMSW: "Licensed Master Social Worker",
  LPC: "Licensed Professional Counselor",
  "LPC-C": "Licensed Professional Counselor-Candidate/Provisional",
  LPCA: "Licensed Professional Counselor Associate",
  LPCC: "Licensed Professional Clinical Counselor",
  LPCI: "Licensed Professional Counselor Intern",
  LSCSW: "Licensed Specialist Clinical Social Worker",
  MFTA: "Marriage and Family Therapist Assistant",
  MHCA: "Mental Health Counselor Aide",
  MHT: "Mental Health Technician",
  OMS: "Oral and Maxillofacial Surgeon",
  OT: "Occupational Therapist",
  OTA: "Occupational Therapist Assistant",
  OTHER: "Other Healthcare Professional (specify)",
  RD: "Registered Dietitian",
  RPh: "Registered Pharmacist",
  PhT: "Pharmacy Technician",
  PhD: "Doctor of Philosophy (in a healthcare field)",
  PsyD: "Doctor of Psychology",
  RBT: "Registered Behavior Technician",
  RCSWI: "Registered Clinical Social Work Intern",
  SLP: "Speech-Language Pathologist",
  LPN: "Licensed Practical Nurse",
  LAc: "Licensed Acupuncturist",
  LMT: "Licensed Massage Therapist",
  DC: "Doctor of Chiropractic",
  ND: "Doctor of Naturopathic Medicine",
  MA: "Medical Assistant",
  LPCMH: "Licensed Professional Counselor in Mental Health",
  "LIMHP-CPC": "Licensed Independent Mental Health Professional-Clinical Pastoral Counselor",
  "LPC-MH": "Licensed Professional Counselor-Mental Health",
  "LPC/MHSP": "Licensed Professional Counselor/Mental Health Service Provider",
  CMHC: "Certified Mental Health Counselor",
  ALC: "Addictions Counselor",
  LAC: "Licensed Addiction Counselor",
  LACMH: "Licensed Addiction Counselor-Mental Health",
  LAPC: "Licensed Associate Professional Counselor",
  ACMHC: "Associate Certified Mental Health Counselor",
  LMHCA: "Licensed Master Mental Health Counselor",
  LGPC: "Licensed Graduate Professional Counselor",
  CSW: "Clinical Social Worker",
  "LCSW-C": "Licensed Clinical Social",
  LGSW: "Licensed Graduate Social Worker",
  LASW: "Licensed Addiction Specialist Social Worker (may vary by state)",
  APSW: "Academy of Certified Social Workers (not a specific license)",
  RT: "Respiratory Therapist",
  AUD: "Audiologist",
  CRNA: "Certified Registered Nurse Anesthetist",
  OPTHAMOLOGIST: "Ophthalmologist (M.D. specializing in the eye)",
  OPA: "Ophthalmic Technician/Assistant",
  "CP-A": "Unknown meaning** (not a recognized code in standard healthcare classification systems)",
  AT: "Athletic Trainer",
  EMR: "Electronic Medical Records (not a profession)",
  EMT: "Emergency Medical Technician (basic level)",
  "EMT-A": "Emergency Medical Technician-Advanced",
  LVN: "Licensed Vocational Nurse",
  MLT: "Medical Laboratory Technician",
  NMT: "Nuclear Medicine Technologist",
  LN: "Licensed Dietitian/Nutritionist (may vary by state)",
  OPT: "Ophthalmic Technician (may vary from OPA)",
  "OTHER-ALLIED-HEA": "Other Allied Health Professional (specify)",
  PAR: "Physician Assistant (PA is more common)",
  PI: "Physician Assistant (PA is more common)",
  "RADIOLOGY-TECH": "Radiologic Technologist (general term)",
  ACU: "Acupuncturist (may differ from LAc)",
  DT: "Dance Therapist",
  MOT: "Occupational Therapist (OT is more common)",
  MPT: "Master of Physical Therapy (not a profession)",
  MT: "Massage Therapist (may differ from LMT)",
  OTD: "Doctor of Occupational Therapy (OT is more common)",
  "OTR/L": "Occupational Therapist Registered/Licensed",
  RDN: "Registered Dietitian Nutritionist",
  "SLP-CF": "Speech-Language Pathologist-Clinical Fellow (student)",
  SLPD: "Speech-Language Pathologist (general term)",
  ATC: "Athletic Trainer (already mentioned)",
  COTA: "Certified Occupational Therapist Assistant",
  LMPC: "Licensed Marriage and Family Therapist (already mentioned)",
  ORT: "Orthotist (may differ from CPO)",
  SLPA: "Speech-Language Pathology Assistant",
  "MT-BC": "Music Therapist-Board Certified"
};
var PractitionerQualificationCodesDisplay = Object.keys(PractitionerQualificationCodesLabels).map((key) => ({
  value: key,
  label: `${key} (${PractitionerQualificationCodesLabels[key]})`
}));
var PHOTON_PRACTITIONER_ENROLLED = "http://api.zapehr.com/photon-practitioner-enrolled";

// ../../utils/lib/types/constants.ts
var PATIENT_INDIVIDUAL_PRONOUNS_URL = "http://hl7.org/fhir/StructureDefinition/individual-pronouns";
var PATIENT_INDIVIDUAL_PRONOUNS_CUSTOM_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/individual-pronouns-custom";
var PATIENT_FILLING_OUT_AS_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/form-user";
var PATIENT_RACE_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/race";
var PATIENT_ETHNICITY_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/ethnicity";
var PATIENT_SEXUAL_ORIENTATION_URL = "http://hl7.org/fhir/us/cdmh/StructureDefinition/cdmh-patient-sexualOrientation";
var PATIENT_POINT_OF_DISCOVERY_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/point-of-discovery";
var PATIENT_SEND_MARKETING_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/send-marketing";
var PATIENT_HEARING_IMPAIRED_RELAY_SERVICE_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/hearing-impaired-relay-service";
var PATIENT_COMMON_WELL_CONSENT_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/common-well-consent";
var PATIENT_GENDER_IDENTITY_URL = "http://hl7.org/fhir/StructureDefinition/individual-genderIdentity";
var PATIENT_GENDER_IDENTITY_DETAILS_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/individual-genderIdentity";
var PATIENT_RELEASE_OF_INFO_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/release-of-info";
var PATIENT_RX_HISTORY_CONSENT_STATUS_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/rx-history-consent-status";
var PATIENT_DECEASED_NOTE_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/deceased-note";
var COVERAGE_ADDITIONAL_INFORMATION_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/additional-information";
var RELATED_PERSON_SAME_AS_PATIENT_ADDRESS_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/related-person-same-as-patient-address";
var PRACTICE_NAME_URL = "https://fhir.zapehr.com/r4/StructureDefinitions/practice-name";

// ../../utils/lib/fhir/constants.ts
var PRIVATE_EXTENSION_BASE_URL = "https://fhir.zapehr.com/r4/StructureDefinitions";
var PUBLIC_EXTENSION_BASE_URL = "https://extensions.fhir.zapehr.com";
var FHIR_ZAPEHR_URL = "https://fhir.zapehr.com";
var TERMINOLOGY_BASE_URL = "http://terminology.hl7.org/CodeSystem";
var RCM_TERMINOLOGY_BASE_URL = "https://terminology.zapehr.com/rcm/cms1500";
var OTTEHR_BASE_URL = "https://fhir.ottehr.com";
var FHIR_EXTENSION = {
  Appointment: {
    additionalInfo: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/additional-information`
    },
    unconfirmedDateOfBirth: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/date-of-birth-not-confirmed`
    },
    bookedBy: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/visit-booked-by`
    }
  },
  Encounter: {
    otherParticipants: {
      url: `${PUBLIC_EXTENSION_BASE_URL}/encounter-other-participants`,
      extension: {
        otherParticipant: {
          url: `${PUBLIC_EXTENSION_BASE_URL}/encounter-other-participant`
        }
      }
    }
  },
  Location: {
    locationFormPreRelease: {
      url: `${PUBLIC_EXTENSION_BASE_URL}/location-form-pre-release`
    }
  },
  Patient: {
    weight: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/weight`
    },
    weightLastUpdated: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/weight-last-updated`
    },
    chosenName: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/chosen-name`
    }
  },
  Paperwork: {
    formListValues: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/form-list-values`,
      extension: {
        formListValue: {
          url: `${PRIVATE_EXTENSION_BASE_URL}/form-list-value`
        }
      }
    },
    legalTimezone: {
      url: `${PUBLIC_EXTENSION_BASE_URL}/legal-timezone`
    },
    submitterIP: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/ip-address`
    }
  },
  ContactPoint: {
    erxTelecom: {
      url: "https://extensions.fhir.oystehr.com/contact-point/telecom-phone-erx"
    }
  },
  Practitioner: {
    isEnrolledInPhoton: {
      url: PHOTON_PRACTITIONER_ENROLLED
    }
  },
  InsurancePlan: {
    insuranceRequirements: {
      url: `${PUBLIC_EXTENSION_BASE_URL}/insurance-requirements`
    }
  },
  QuestionnaireResponse: {
    ipAddress: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/ip-address`
    }
  },
  Coverage: {
    subscriberRelationship: {
      url: `${TERMINOLOGY_BASE_URL}/subscriber-relationship`
    },
    coverageClass: {
      url: `${TERMINOLOGY_BASE_URL}/coverage-class`
    }
  },
  Organization: {
    v2_0203: {
      url: `${TERMINOLOGY_BASE_URL}/v2-0203`
    },
    organizationType: {
      url: `${TERMINOLOGY_BASE_URL}/organization-type`
    }
  },
  Claim: {
    v3_ActCode: {
      url: `${TERMINOLOGY_BASE_URL}/v3-ActCode`
    },
    claimConditionCode: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/claim-condition-code`
    },
    claimInformationCategory: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/claiminformationcategory`
    },
    resubmissionRelationship: {
      url: `${RCM_TERMINOLOGY_BASE_URL}/resubmission-relationship`
    },
    claimDiagnosesComment: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/claim-diagnoses-comment`
    },
    revenueCode: {
      url: `${RCM_TERMINOLOGY_BASE_URL}/revenue-code`
    },
    procedureModifier: {
      url: `${RCM_TERMINOLOGY_BASE_URL}/procedure-modifier`
    },
    patientPaid: {
      url: `${PRIVATE_EXTENSION_BASE_URL}/patient-paid`
    }
  },
  AllergyIntolerance: {
    allergyIntoleranceClinical: {
      url: `${TERMINOLOGY_BASE_URL}/allergyintolerance-clinical`
    }
  },
  Condition: {
    conditionClinical: {
      url: `${TERMINOLOGY_BASE_URL}/condition-clinical`
    }
  }
};
var SLUG_SYSTEM = `${OTTEHR_BASE_URL}/r4/slug`;
var SERVICE_EXTENSION = "http://extensions.ottehr.com";
var AppointmentInsuranceRelatedResourcesExtension = {
  extensionUrl: `${SERVICE_EXTENSION}/insurance-related-resources`,
  primaryCoverage: {
    coverage: { url: `${SERVICE_EXTENSION}/coverage-reference` },
    eligibilityRequest: { url: `${SERVICE_EXTENSION}/coverage-eligibility-request-reference` },
    eligibilityResponse: { url: `${SERVICE_EXTENSION}/coverage-eligibility-response-reference` }
  },
  secondaryCoverage: {
    coverage: { url: `${SERVICE_EXTENSION}/secondary-coverage-reference` },
    eligibilityRequest: { url: `${SERVICE_EXTENSION}/secondary-coverage-eligibility-request-reference` },
    eligibilityResponse: { url: `${SERVICE_EXTENSION}/secondary-coverage-eligibility-response-reference` }
  }
};
var SERVICE_MODE_SYSTEM = "http://hl7.org/fhir/service-mode";
var SCHEDULE_STRATEGY_SYSTEM = `${PRIVATE_EXTENSION_BASE_URL}/healthcare-service-schedule-strategy`;
var ServiceModeCoding = {
  inPerson: {
    system: SERVICE_MODE_SYSTEM,
    code: "in-person",
    display: "In Person",
    fullParam: `${SERVICE_MODE_SYSTEM}|in-person`
  },
  telephone: {
    system: SERVICE_MODE_SYSTEM,
    code: "telephone",
    display: "Telephone",
    fullParam: `${SERVICE_MODE_SYSTEM}|telephone`
  },
  videoconference: {
    system: SERVICE_MODE_SYSTEM,
    code: "videoconference",
    display: "Video Conference",
    fullParam: `${SERVICE_MODE_SYSTEM}|videoconference`
  },
  chat: {
    system: SERVICE_MODE_SYSTEM,
    code: "chat",
    display: "Chat/Messaging",
    fullParam: `${SERVICE_MODE_SYSTEM}|chat`
  }
};
var ScheduleStrategyCoding = {
  owns: {
    system: SCHEDULE_STRATEGY_SYSTEM,
    code: "owns",
    display: "Owns",
    fullParam: `${SCHEDULE_STRATEGY_SYSTEM}|owns`
  },
  poolsLocations: {
    system: SCHEDULE_STRATEGY_SYSTEM,
    code: "pools-locations",
    display: "Pools Locations",
    fullParam: `${SCHEDULE_STRATEGY_SYSTEM}|pools-locations`
  },
  poolsProviders: {
    system: SCHEDULE_STRATEGY_SYSTEM,
    code: "pools-providers",
    display: "Pools Providers",
    fullParam: `${SCHEDULE_STRATEGY_SYSTEM}|pools-providers`
  },
  poolsAll: {
    system: SCHEDULE_STRATEGY_SYSTEM,
    code: "pools-all",
    display: "Pools All",
    fullParam: `${SCHEDULE_STRATEGY_SYSTEM}|pools-all`
  }
};
var OTTEHR_QUESTIONNAIRE_EXTENSION_KEYS = {
  acceptsMultipleAnswers: `${PRIVATE_EXTENSION_BASE_URL}/accepts-multiple-answers`,
  alwaysFilter: `${PRIVATE_EXTENSION_BASE_URL}/always-filter`,
  attachmentText: `${PRIVATE_EXTENSION_BASE_URL}/attachment-text`,
  autofillFromWhenDisabled: `${PRIVATE_EXTENSION_BASE_URL}/fill-from-when-disabled`,
  categoryTag: `${PRIVATE_EXTENSION_BASE_URL}/category-tag`,
  dataType: `${PRIVATE_EXTENSION_BASE_URL}/data-type`,
  disabledDisplay: `${PRIVATE_EXTENSION_BASE_URL}/disabled-display`,
  groupType: `${PRIVATE_EXTENSION_BASE_URL}/group-type`,
  infoText: `${PRIVATE_EXTENSION_BASE_URL}/information-text`,
  inputWidth: `${PRIVATE_EXTENSION_BASE_URL}/input-width`,
  minRows: `${PRIVATE_EXTENSION_BASE_URL}/text-min-rows`,
  preferredElement: `${PRIVATE_EXTENSION_BASE_URL}/preferred-element`,
  secondaryInfoText: `${PRIVATE_EXTENSION_BASE_URL}/information-text-secondary`,
  validateAgeOver: `${PRIVATE_EXTENSION_BASE_URL}/validate-age-over`,
  // complex extensions
  answerLoadingOptions: {
    extension: `${PRIVATE_EXTENSION_BASE_URL}/answer-loading-options`,
    strategy: `${PRIVATE_EXTENSION_BASE_URL}/strategy`,
    source: `${PRIVATE_EXTENSION_BASE_URL}/source`
  },
  complexValidation: {
    extension: `${PRIVATE_EXTENSION_BASE_URL}/complex-validation`,
    type: `${PRIVATE_EXTENSION_BASE_URL}/complex-validation-type`,
    triggerWhen: {
      extension: `${PRIVATE_EXTENSION_BASE_URL}/complex-validation-triggerWhen`,
      question: `${PRIVATE_EXTENSION_BASE_URL}/complex-validation-triggerQuestion`,
      operator: `${PRIVATE_EXTENSION_BASE_URL}/complex-validation-triggerOperator`,
      answer: `${PRIVATE_EXTENSION_BASE_URL}/complex-validation-triggerAnswer`
    }
  },
  filterWhen: {
    extension: `${PRIVATE_EXTENSION_BASE_URL}/filter-when`,
    question: `${PRIVATE_EXTENSION_BASE_URL}/filter-when-question`,
    operator: `${PRIVATE_EXTENSION_BASE_URL}/filter-when-operator`,
    answer: `${PRIVATE_EXTENSION_BASE_URL}/filter-when-answer`
  },
  requireWhen: {
    extension: `${PRIVATE_EXTENSION_BASE_URL}/require-when`,
    question: `${PRIVATE_EXTENSION_BASE_URL}/require-when-question`,
    operator: `${PRIVATE_EXTENSION_BASE_URL}/require-when-operator`,
    answer: `${PRIVATE_EXTENSION_BASE_URL}/require-when-answer`
  },
  textWhen: {
    extension: `${PRIVATE_EXTENSION_BASE_URL}/text-when`,
    question: `${PRIVATE_EXTENSION_BASE_URL}/text-when-question`,
    operator: `${PRIVATE_EXTENSION_BASE_URL}/text-when-operator`,
    answer: `${PRIVATE_EXTENSION_BASE_URL}/text-when-answer`,
    substituteText: `${PRIVATE_EXTENSION_BASE_URL}/text-when-substitute-text`
  }
};

// ../../utils/lib/fhir/helpers.ts
function isFHIRError(error) {
  return !(error instanceof Error) && typeof error === "object" && error.resourceType === "OperationOutcome";
}
function handleUnknownError(error) {
  let errorToThrow = error;
  if (isFHIRError(error)) {
    const fhirError = error;
    const firstIssue = fhirError.issue[0];
    const fhirMessage = "FHIR Error: " + firstIssue.details?.text;
    errorToThrow = new Error(fhirMessage);
  }
  return errorToThrow;
}
var isPostTelemedAppointment = (appointment) => {
  const typeCoding = appointment.appointmentType?.text;
  return typeCoding === "posttelemed" /* PostTelemed */;
};
var CRITICAL_CHANGE_SYSTEM = "critical-update-by";
var getCriticalUpdateTagOp = (resource, updateBy) => {
  const recordUpdateByTag = {
    system: CRITICAL_CHANGE_SYSTEM,
    display: updateBy,
    version: DateTime.now().toISO() || ""
  };
  if (!resource.meta?.tag) {
    return {
      op: "add",
      path: "/meta/tag",
      value: [recordUpdateByTag]
    };
  } else {
    const currentTags = resource.meta?.tag ?? [];
    const existingTagIdx = currentTags.findIndex((coding) => {
      return coding.system === CRITICAL_CHANGE_SYSTEM;
    });
    if (existingTagIdx >= 0) {
      return {
        op: "replace",
        path: `/meta/tag/${existingTagIdx}`,
        value: recordUpdateByTag
      };
    } else {
      return {
        op: "add",
        path: `/meta/tag/-`,
        value: recordUpdateByTag
      };
    }
  }
};

// ../../utils/lib/fhir/resourcePatch.ts
function getPatchBinary(input) {
  const { resourceId, resourceType, patchOperations } = input;
  return {
    method: "PATCH",
    url: `/${resourceType}/${resourceId}`,
    resource: {
      resourceType: "Binary",
      // data is handled due to bug with non latin1 characters
      data: btoa(unescape(encodeURIComponent(JSON.stringify(patchOperations)))),
      contentType: "application/json-patch+json"
    }
  };
}

// ../../utils/lib/fhir/appointments.ts
async function getAppointmentResourceById(appointmentID, oystehr) {
  let response = null;
  try {
    response = await oystehr.fhir.get({
      resourceType: "Appointment",
      id: appointmentID
    });
  } catch (error) {
    if (error?.issue?.[0]?.code === "not-found") {
      return void 0;
    } else {
      throw error;
    }
  }
  return response;
}

// ../../../node_modules/@oystehr/sdk/dist/esm/errors/index.js
var OystehrSdkError = class _OystehrSdkError extends Error {
  constructor({ message, code, cause }) {
    super(message, { cause });
    Object.setPrototypeOf(this, _OystehrSdkError.prototype);
    this.code = code;
    this.name = "OystehrSdkError";
  }
  toString() {
    return `${this.name}: ${this.message} (code: ${this.code})`;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      cause: this.cause
    };
  }
};
function transformOperationOutcomeToErrorMessage(cause) {
  var _a;
  const causes = [];
  for (const issue of (_a = cause.issue) !== null && _a !== void 0 ? _a : []) {
    if (issue.details && issue.details.text) {
      causes.push(issue.details.text);
    }
  }
  if (!causes.length) {
    causes.push("Unknown FHIR error");
  }
  return causes.join(",");
}
var OystehrFHIRError = class _OystehrFHIRError extends OystehrSdkError {
  constructor({ error, code }) {
    super({
      message: transformOperationOutcomeToErrorMessage(error),
      code
    });
    Object.setPrototypeOf(this, _OystehrFHIRError.prototype);
    this.cause = error;
    this.name = "OystehrFHIRError";
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      cause: this.cause
    };
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// ../../../node_modules/@oystehr/sdk/node_modules/uuid/dist/esm/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr2, offset2 = 0) {
  return (byteToHex[arr2[offset2 + 0]] + byteToHex[arr2[offset2 + 1]] + byteToHex[arr2[offset2 + 2]] + byteToHex[arr2[offset2 + 3]] + "-" + byteToHex[arr2[offset2 + 4]] + byteToHex[arr2[offset2 + 5]] + "-" + byteToHex[arr2[offset2 + 6]] + byteToHex[arr2[offset2 + 7]] + "-" + byteToHex[arr2[offset2 + 8]] + byteToHex[arr2[offset2 + 9]] + "-" + byteToHex[arr2[offset2 + 10]] + byteToHex[arr2[offset2 + 11]] + byteToHex[arr2[offset2 + 12]] + byteToHex[arr2[offset2 + 13]] + byteToHex[arr2[offset2 + 14]] + byteToHex[arr2[offset2 + 15]]).toLowerCase();
}

// ../../../node_modules/@oystehr/sdk/node_modules/uuid/dist/esm/rng.js
var import_crypto = require("crypto");
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    (0, import_crypto.randomFillSync)(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// ../../../node_modules/@oystehr/sdk/node_modules/uuid/dist/esm/native.js
var import_crypto2 = require("crypto");
var native_default = { randomUUID: import_crypto2.randomUUID };

// ../../../node_modules/@oystehr/sdk/node_modules/uuid/dist/esm/v4.js
function v4(options, buf, offset2) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset2 + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../../../node_modules/@oystehr/sdk/dist/esm/client/client.js
var defaultProjectApiUrl = "https://project-api.zapehr.com/v1";
var defaultFhirApiUrl = "https://fhir-api.zapehr.com";
var STATUS_CODES_TO_RETRY = [408, 429, 500, 502, 503, 504];
var ERROR_CODES_TO_RETRY = [
  "ECONNRESET",
  "ECONNREFUSED",
  "EPIPE",
  "ETIMEDOUT",
  "UND_ERR_CONNECT_TIMEOUT",
  "UND_ERR_HEADERS_TIMEOUT",
  "UND_ERR_HEADERS_TIMEOUT",
  "UND_ERR_SOCKET"
];
var SDKResource = class {
  constructor(config) {
    this.config = config;
  }
  request(path2, method, baseUrlThunk3) {
    return (params, request) => __awaiter(this, void 0, void 0, function* () {
      const configThunk = () => this.config;
      try {
        return yield fetcher(baseUrlThunk3, configThunk, path2, method)(params, request);
      } catch (err) {
        const error = err;
        throw new OystehrSdkError({ message: error.message, code: error.code, cause: error.cause });
      }
    });
  }
  fhirRequest(path2, method) {
    return (params, request) => __awaiter(this, void 0, void 0, function* () {
      try {
        const baseUrlThunk3 = () => {
          var _a, _b;
          return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a.fhirApiUrl) !== null && _b !== void 0 ? _b : defaultFhirApiUrl;
        };
        const configThunk = () => this.config;
        return yield fetcher(baseUrlThunk3, configThunk, path2, method)(params, request);
      } catch (err) {
        const fullError = err;
        if (typeof fullError.message === "string") {
          throw new OystehrSdkError({
            message: fullError.message,
            code: fullError.code,
            cause: fullError.cause
          });
        }
        throw new OystehrFHIRError({
          error: fullError.message,
          code: fullError.code
        });
      }
    });
  }
};
function isInternalClientRequest(request) {
  return "accessToken" in request;
}
function fetcher(baseUrlThunk3, configThunk, path2, methodParam) {
  return (params, request) => __awaiter(this, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    const providedParams = !!params && !request && !Array.isArray(params) && isInternalClientRequest(params) ? {} : (_a = params) !== null && _a !== void 0 ? _a : {};
    const requestCtx = !!params && !request && !Array.isArray(params) && isInternalClientRequest(params) ? params : request;
    const method = methodParam.toLowerCase();
    const config = configThunk();
    const fetchImpl = (_b = config.fetch) !== null && _b !== void 0 ? _b : fetch;
    const accessToken = (_c = requestCtx === null || requestCtx === void 0 ? void 0 : requestCtx.accessToken) !== null && _c !== void 0 ? _c : config.accessToken;
    const projectId = (_d = requestCtx === null || requestCtx === void 0 ? void 0 : requestCtx.projectId) !== null && _d !== void 0 ? _d : configThunk().projectId;
    let finalPath = path2;
    let finalParams = providedParams;
    if (!Array.isArray(providedParams)) {
      const [subbedPath, addlParams] = subParamsInPath(path2, providedParams);
      finalPath = subbedPath;
      finalParams = addlParams;
    }
    finalPath = finalPath.replace(/^\//, "");
    const baseUrlEvaluated = baseUrlThunk3();
    const fullBaseUrl = baseUrlEvaluated.endsWith("/") ? baseUrlEvaluated : baseUrlEvaluated + "/";
    const url = new URL(finalPath, fullBaseUrl);
    let body;
    if (Array.isArray(finalParams)) {
      body = JSON.stringify(finalParams);
    } else if (Object.keys(finalParams).length) {
      if (method === "get") {
        addParamsToSearch(finalParams, url.searchParams);
      } else if ((requestCtx === null || requestCtx === void 0 ? void 0 : requestCtx.contentType) === "application/x-www-form-urlencoded") {
        const search2 = new URLSearchParams();
        addParamsToSearch(finalParams, search2);
        body = search2.toString();
      } else {
        body = JSON.stringify(finalParams);
      }
    } else {
      if ((requestCtx === null || requestCtx === void 0 ? void 0 : requestCtx.contentType) !== "application/x-www-form-urlencoded" && method === "post") {
        body = "{}";
      }
    }
    const headers = Object.assign(projectId ? {
      "x-zapehr-project-id": projectId,
      "x-oystehr-project-id": projectId
    } : {}, {
      "content-type": (_e = requestCtx === null || requestCtx === void 0 ? void 0 : requestCtx.contentType) !== null && _e !== void 0 ? _e : "application/json"
    }, accessToken ? { Authorization: `Bearer ${accessToken}` } : {}, (requestCtx === null || requestCtx === void 0 ? void 0 : requestCtx.ifMatch) ? { "If-Match": requestCtx.ifMatch } : {}, { "x-oystehr-request-id": (_f = requestCtx === null || requestCtx === void 0 ? void 0 : requestCtx.requestId) !== null && _f !== void 0 ? _f : v4_default() });
    const retryConfig = {
      retries: (_h = (_g = config.retry) === null || _g === void 0 ? void 0 : _g.retries) !== null && _h !== void 0 ? _h : 3,
      jitter: (_k = (_j = config.retry) === null || _j === void 0 ? void 0 : _j.jitter) !== null && _k !== void 0 ? _k : 20,
      delay: (_m = (_l = config.retry) === null || _l === void 0 ? void 0 : _l.delay) !== null && _m !== void 0 ? _m : 100,
      onRetry: (_o = config.retry) === null || _o === void 0 ? void 0 : _o.onRetry,
      // Using array instead of set because the length is too short for uniqueness to be important
      retryOn: [...(_q = (_p = config.retry) === null || _p === void 0 ? void 0 : _p.retryOn) !== null && _q !== void 0 ? _q : [], ...STATUS_CODES_TO_RETRY]
    };
    retryConfig.retryOn.push(...STATUS_CODES_TO_RETRY);
    return retry(() => __awaiter(this, void 0, void 0, function* () {
      var _r, _s, _t, _u, _v, _w;
      const response = yield fetchImpl(new Request(url, {
        method: method.toUpperCase(),
        body,
        headers
      }));
      const responseBody = response.body ? yield response.text() : null;
      let responseJson;
      try {
        responseJson = responseBody && (((_r = response.headers.get("content-type")) === null || _r === void 0 ? void 0 : _r.includes("application/json")) || ((_s = response.headers.get("content-type")) === null || _s === void 0 ? void 0 : _s.includes("application/fhir+json"))) ? JSON.parse(responseBody) : null;
      } catch (_err) {
        responseJson = null;
      }
      const isError2 = !response.ok || response.status >= 400;
      if (isError2) {
        const errObj = {
          message: (_v = (_u = (_t = responseJson === null || responseJson === void 0 ? void 0 : responseJson.message) !== null && _t !== void 0 ? _t : responseJson) !== null && _u !== void 0 ? _u : responseBody) !== null && _v !== void 0 ? _v : response.statusText,
          code: (_w = responseJson === null || responseJson === void 0 ? void 0 : responseJson.code) !== null && _w !== void 0 ? _w : response.status,
          response
        };
        throw errObj;
      }
      return responseJson;
    }), retryConfig);
  });
}
function retry(work, config) {
  var _a, _b;
  return __awaiter(this, void 0, void 0, function* () {
    let lastErr;
    for (const attempt of Array.from({ length: ((_a = config.retries) !== null && _a !== void 0 ? _a : 0) + 1 }, (_, index2) => index2)) {
      try {
        return yield work(attempt);
      } catch (e) {
        let isRetryable = false;
        if ("response" in e) {
          const err = e;
          isRetryable = config.retryOn.includes(err.code);
          lastErr = { message: e.message, code: e.code };
        } else {
          lastErr = e;
          if ("code" in e && typeof e.code === "string") {
            const err = e;
            isRetryable = ERROR_CODES_TO_RETRY.includes(err.code);
          }
        }
        if (!isRetryable) {
          break;
        }
        const jitter = Math.floor(Math.random() * (config.jitter + 1));
        yield new Promise((resolve) => setTimeout(resolve, config.delay + jitter));
        if (config.onRetry && attempt !== ((_b = config.retries) !== null && _b !== void 0 ? _b : 0)) {
          config.onRetry(attempt + 1);
        }
      }
    }
    throw lastErr;
  });
}
function subParamsInPath(path2, params) {
  const unusedParams = Object.assign({}, params);
  const subbedPath = path2.replace(/\{([^}]+)\}/g, (_, paramName) => {
    delete unusedParams[paramName];
    if (paramName.match(/^.*\+$/)) {
      return params[paramName] + "";
    }
    if (!params[paramName] || params[paramName] === "") {
      throw new OystehrSdkError({ message: `Required path parameter is an empty string: ${paramName}`, code: 400 });
    }
    if (params[paramName]) {
      return encodeURIComponent(params[paramName] + "");
    }
    return "";
  });
  const unusedKeys = Object.keys(unusedParams);
  const addlParams = unusedKeys.length ? unusedKeys.reduce((acc, key) => Object.assign(Object.assign({}, acc), { [key]: unusedParams[key] }), {}) : {};
  return [subbedPath, addlParams];
}
function addParamsToSearch(params, search2) {
  for (const [key, value] of Object.entries(params)) {
    if (Array.isArray(value)) {
      value.forEach((v) => search2.append(key, v));
      continue;
    }
    search2.append(key, value);
  }
}

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/application.js
var Application = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Get a list of Applications. [Applications](https://docs.oystehr.com/services/app/applications/) provide authentication in front of the web and mobile apps you build on Oystehr.
   *
   * Access Policy Action: `App:ListAllApplications`
   * Access Policy Resource: `App:Application`
   */
  list(request) {
    return this.request("/application", "get", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Create a new Application. [Applications](https://docs.oystehr.com/services/app/applications/) provide authentication in front of the web and mobile apps you build on Oystehr.
   *
   * Access Policy Action: `App:CreateApplication`
   * Access Policy Resource: `App:Application`
   */
  create(params, request) {
    return this.request("/application", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Get the Application with the provided ID. [Applications](https://docs.oystehr.com/services/app/applications/) provide authentication in front of the web and mobile apps you build on Oystehr.
   *
   * Access Policy Action: `App:GetApplication`
   * Access Policy Resource: `App:Application`
   */
  get(params, request) {
    return this.request("/application/{id}", "get", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Update the Application with the provided ID. [Applications](https://docs.oystehr.com/services/app/applications/) provide authentication in front of the web and mobile apps you build on Oystehr.
   *
   * Access Policy Action: `App:UpdateApplication`
   * Access Policy Resource: `App:Application`
   */
  update(params, request) {
    return this.request("/application/{id}", "patch", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Delete the Application with the provided ID. [Applications](https://docs.oystehr.com/services/app/applications/) provide authentication in front of the web and mobile apps you build on Oystehr.
   *
   * Access Policy Action: `App:DeleteApplication`
   * Access Policy Resource: `App:Application`
   */
  delete(params, request) {
    return this.request("/application/{id}", "delete", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Rotate client's secrete associated with an application.
   *
   * Access Policy Action: `App:RotateApplicationSecret`
   * Access Policy Resource: `App:Application`
   */
  rotateSecret(params, request) {
    return this.request("/application/{id}/rotate-secret", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Revokes user's refresh token issued for the application.
   *
   * Access Policy Action: `App:RevokeRefreshToken`
   * Access Policy Resource: `App:Application`
   */
  revokeRefreshToken(params, request) {
    return this.request("/application/{id}/revoke-refresh-token", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Revokes user's access token issued for the application.
   *
   * Access Policy Action: `App:RevokeAccessToken`
   * Access Policy Resource: `App:Application`
   */
  revokeAccessToken(params, request) {
    return this.request("/application/{id}/revoke-access-token", "post", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/charge.js
var Charge = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Charge patient's default payment method for a specified encounter or charge item.
   *
   * Access Policy Requirements:
   * Action: `Payment:Issue`
   * Access Policy Resource: `Payment:Charge`
   * Actions: `FHIR:Read,FHIR:Create,FHIR:Update`
   * Access Policy Resource: `FHIR:ChargeItem:*,`FHIR:PaymentReconciliation:*`
   * Action: `FHIR:Read`
   * Access Policy Resources: `FHIR:Patient:*,FHIR:Encounter:*,FHIR:Coverage:*`
   */
  issue(params, request) {
    return this.request("/payment/charge/issue", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Retrieve charge status for a specified encounter or charge item.
   *
   * Access Policy Requirements:
   * Action: `Payment:Status`
   * Access Policy Resource: `Payment:Charge`
   * Actions: `FHIR:Read,FHIR:Create,FHIR:Update`
   * Access Policy Resource: `FHIR:ChargeItem:*,`FHIR:PaymentReconciliation:*`
   * Action: `FHIR:Read`
   * Access Policy Resources: `FHIR:Patient:*,FHIR:Encounter:*,FHIR:Coverage:*`
   */
  status(params, request) {
    return this.request("/payment/charge/status", "post", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/conversation-ext.js
var ENCOUNTER_VS_EXTENSION_URL = "https://extensions.fhir.zapehr.com/encounter-virtual-service-pre-release";
var ENCOUNTER_VS_EXTENSION_RELATIVE_URL = "addressString";
var ENCOUNTER_VS_CODING_SYSTEM = "https://fhir.zapehr.com/virtual-service-type";
function isR5Encounter(encounter) {
  return Object.hasOwn(encounter, "virtualService");
}
function getConversationIdFromEncounter(encounter) {
  var _a, _b, _c;
  if (isR5Encounter(encounter)) {
    const virtualService = (_a = encounter.virtualService) === null || _a === void 0 ? void 0 : _a.find((vs) => {
      var _a2;
      return ((_a2 = vs.channelType) === null || _a2 === void 0 ? void 0 : _a2.system) === ENCOUNTER_VS_CODING_SYSTEM;
    });
    return virtualService === null || virtualService === void 0 ? void 0 : virtualService.addressString;
  }
  if (!encounter.extension)
    return;
  const virtualServiceExtension = encounter.extension.find((extension) => extension.url === ENCOUNTER_VS_EXTENSION_URL);
  if (!(virtualServiceExtension === null || virtualServiceExtension === void 0 ? void 0 : virtualServiceExtension.extension))
    return;
  const conversationId = (_c = (_b = virtualServiceExtension.extension) === null || _b === void 0 ? void 0 : _b.find((extension) => extension.url === ENCOUNTER_VS_EXTENSION_RELATIVE_URL)) === null || _c === void 0 ? void 0 : _c.valueString;
  return conversationId;
}

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/conversation.js
var Conversation = class extends SDKResource {
  constructor(config) {
    super(config);
    this.ENCOUNTER_VS_EXTENSION_URL = ENCOUNTER_VS_EXTENSION_URL;
    this.ENCOUNTER_VS_EXTENSION_RELATIVE_URL = ENCOUNTER_VS_EXTENSION_RELATIVE_URL;
    this.getConversationIdFromEncounter = getConversationIdFromEncounter;
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Create a new Conversation. [Conversations](https://docs.oystehr.com/services/messaging/conversations/) allow you to build multi-channel bi-directional messaging workflows. For example, you might create a Conversation where a provider messages with a patient through a web app, and the patient receives and responds to messages via SMS on their phone.
   *
   * Access Policy Requirements:
   * Action: `Messaging:CreateConversation`
   * Access Policy Resource: `Messaging:Conversation`
   * Action: `FHIR:Create`
   * Access Policy Resource: `FHIR:Encounter`
   * Action: `FHIR:Update`
   * Access Policy Resource: `FHIR:Encounter`
   */
  create(params, request) {
    return this.request("/messaging/conversation", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Get a Conversation Token. Conversation Tokens are used to join the Conversation with the Twilio Conversations SDKs. [Conversations](https://docs.oystehr.com/services/messaging/conversations/) allow you to build multi-channel bi-directional messaging workflows. For example, you might create a Conversation where a provider messages with a patient through a web app, and the patient receives and responds to messages via SMS on their phone.
   *
   * Access Policy Action: `Messaging:GetConversationToken`
   * Access Policy Resource: `Messaging:Conversation`.
   */
  getToken(request) {
    return this.request("/messaging/conversation/token", "get", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Add a participant to a Conversation. [Conversations](https://docs.oystehr.com/services/messaging/conversations/) allow you to build multi-channel bi-directional messaging workflows. For example, you might create a Conversation where a provider messages with a patient through a web app, and the patient receives and responds to messages via SMS on their phone.
   *
   * Access Policy Requirements:
   * Action: `Messaging:ConversationAddParticipant`
   * Access Policy Resource: `Messaging:Conversation`
   * Action: `FHIR:Read`
   * Access Policy Resource: `FHIR:Encounter`
   * Action: `FHIR:Update`
   * Access Policy Resource: `FHIR:Encounter`
   */
  addParticipant(params, request) {
    return this.request("/messaging/conversation/{conversationId}/participant", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Remove a participant from a Conversation. [Conversations](https://docs.oystehr.com/services/messaging/conversations/) allow you to build multi-channel bi-directional messaging workflows. For example, you might create a Conversation where a provider messages with a patient through a web app, and the patient receives and responds to messages via SMS on their phone.
   *
   * Access Policy Requirements:
   * Action: `Messaging:ConversationRemoveParticipant`
   * Access Policy Resource: `Messaging:Conversation`
   * Action: `FHIR:Read`
   * Access Policy Resource: `FHIR:Patient`, `FHIR:Practitioner`, or `FHIR:RelatedPerson`
   */
  removeParticipant(params, request) {
    return this.request("/messaging/conversation/{conversationId}/participant", "delete", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Send a message to a Conversation. [Conversations](https://docs.oystehr.com/services/messaging/conversations/) allow you to build multi-channel bi-directional messaging workflows. For example, you might create a Conversation where a provider messages with a patient through a web app, and the patient receives and responds to messages via SMS on their phone.
   *
   * Access Policy Requirements:
   * Action: `Messaging:ConversationSendMessage`
   * Access Policy Resource: `Messaging:Conversation`
   */
  message(params, request) {
    return this.request("/messaging/conversation/{conversationId}/message", "post", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/developer.js
var Developer = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Get the Developer with the provided ID. Developer accounts are used to log into the [Developer Console](https://console.oystehr.com/) and administrate [Projects](https://docs.oystehr.com/services/project/). [Developers](https://docs.oystehr.com/services/iam/developers/) are the only people who can belong to and act across multiple Projects, because they exist above the Project level.
   *
   * Access Policy Action: `IAM:GetDeveloper`
   * Access Policy Resource: `IAM:Developer`
   */
  get(params, request) {
    return this.request("/developer/{id}", "get", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Update the Developer with the provided ID. Developer accounts are used to log into the [Developer Console](https://console.oystehr.com/) and administrate [Projects](https://docs.oystehr.com/services/project/). [Developers](https://docs.oystehr.com/services/iam/developers/) are the only people who can belong to and act across multiple Projects, because they exist above the Project level.
   *
   * Access Policy Action: `IAM:UpdateDeveloper`
   * Access Policy Resource: `IAM:Developer`
   */
  update(params, request) {
    return this.request("/developer/{id}", "patch", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Remove the Developer with the provided ID from the project. Developer accounts are used to log into the [Developer Console](https://console.oystehr.com/) and administrate [Projects](https://docs.oystehr.com/services/project/). [Developers](https://docs.oystehr.com/services/iam/developers/) are the only people who can belong to and act across multiple Projects, because they exist above the Project level.
   *
   * Access Policy Action: `IAM:RemoveDeveloper`
   * Access Policy Resource: `IAM:Developer`
   */
  delete(params, request) {
    return this.request("/developer/{id}", "delete", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Invite a new Developer to the Project. Developer accounts are used to log into the [Developer Console](https://console.oystehr.com/) and administrate [Projects](https://docs.oystehr.com/services/project/). [Developers](https://docs.oystehr.com/services/iam/developers/) are the only people who can belong to and act across multiple Projects, because they exist above the Project level.
   *
   * Access Policy Action: `IAM:InviteDeveloper`
   * Access Policy Resource: `IAM:Developer`
   */
  invite(params, request) {
    return this.request("/developer/invite", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * DEPRECATED. Please use [v2/list](https://api-reference.oystehr.com/reference/get_developer-v2-list) instead.
   *
   * Get a list of all Developers who are part of the Project. Developer accounts are used to log into the [Developer Console](https://console.oystehr.com/) and administrate [Projects](https://docs.oystehr.com/services/project/). [Developers](https://docs.oystehr.com/services/iam/developers/) are the only people who can belong to and act across multiple Projects, because they exist above the Project level.
   *
   * Access Policy Action: `IAM:ListAllDevelopers`
   * Access Policy Resource: `IAM:Developer`
   */
  list(request) {
    return this.request("/developer", "get", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Get Developers in the Project with pagination, sort, sort Order and filtering. [Users](https://docs.oystehr.com/services/app/users/) are the people who log into the [Applications](https://docs.oystehr.com/services/app/applications/) you configure for securing the apps you build on top of Oystehr.
   *
   * Access Policy Action: `Project:ListAllUsers`
   * Access Policy Resource: `Project:Settings`
   */
  listV2(params, request) {
    return this.request("/developer/v2/list", "get", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/erx.js
var Erx = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Retrieve patient properties from FHIR service and sync them with eRx service
   */
  syncPatient(params, request) {
    return this.request("/erx/sync-patient/{patientId}", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Search for allergies
   */
  allergySearch(params, request) {
    return this.request("/erx/allergy/search", "get", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Cancel photon order
   */
  cancelOrder(params, request) {
    return this.request("/erx/cancel-order", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Cancel photon prescription
   */
  cancelPrescription(params, request) {
    return this.request("/erx/cancel-prescription", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Search for medications. Provide at least one of code or name filters
   */
  medicationSearch(params, request) {
    return this.request("/erx/medication/search", "get", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Search for medications. Provide at least one of code or name filters
   */
  medicationSearchV2(params, request) {
    return this.request("/erx/v2/medication/search", "get", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/fax.js
var Fax = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["faxApiUrl"]) !== null && _b !== void 0 ? _b : "https://fax-api.zapehr.com/v1";
  }
  /**
   * Offboard a fax number. Oystehr's [offboard](https://docs.oystehr.com/services/fax/number/) feature makes it easy to stop using the fax service and release the project's assigned fax number with a single API call. Please note there is no way to guarantee getting the same number back again, so if you think this can break your project in any way we recommend not offboarding and avoid sending faxes until you're sure.
   *
   * Access Policy Requirements:
   * Action: `Fax:Offboard`
   * Access Policy Resource: `Fax:Number`
   */
  offboard(request) {
    return this.request("/offboard", "post", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Onboard a fax number. Oystehr's [onboard](https://docs.oystehr.com/services/fax/number/) feature makes it easy to start using the fax service and purchase a new fax number for your project with a single API call.
   *
   * Access Policy Requirements:
   * Action: `Fax:Onboard`
   * Access Policy Resource: `Fax:Number`
   */
  onboard(request) {
    return this.request("/onboard", "post", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Send a fax. Oystehr's [fax sending](https://docs.oystehr.com/services/fax/send/) feature makes it easy to send a fax to a chosen recipient with a single API call. You can use this feature to send referrals, medical records, prescriptions, and other documents that require fax transmission e.g. for HIPAA compliance.
   *
   * Access Policy Requirements:
   * Action: `Fax:Send`
   * Access Policy Resource: `Fax:Fax`
   */
  send(params, request) {
    return this.request("/send", "post", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/fhir-ext.js
function search(params, request) {
  return __awaiter(this, void 0, void 0, function* () {
    const { resourceType, params: searchParams } = params;
    let paramMap;
    if (searchParams) {
      paramMap = Object.entries(searchParams).reduce((acc, [_, param]) => {
        if (!acc[param.name]) {
          acc[param.name] = [];
        }
        acc[param.name].push(param.value);
        return acc;
      }, {});
    }
    const requestBundle = yield this.fhirRequest(`/${resourceType}/_search`, "POST")(paramMap, Object.assign(Object.assign({}, request), { contentType: "application/x-www-form-urlencoded" }));
    const bundle = Object.assign(Object.assign({}, requestBundle), { entry: requestBundle.entry, unbundle: function() {
      var _a, _b;
      return (_b = (_a = this.entry) === null || _a === void 0 ? void 0 : _a.map((entry) => entry.resource).filter((entry) => entry !== void 0)) !== null && _b !== void 0 ? _b : [];
    } });
    return bundle;
  });
}
function create(params, request) {
  return __awaiter(this, void 0, void 0, function* () {
    const { resourceType } = params;
    return this.fhirRequest(`/${resourceType}`, "POST")(params, request);
  });
}
function get({ resourceType, id }, request) {
  return __awaiter(this, void 0, void 0, function* () {
    return this.fhirRequest(`/${resourceType}/${id}`, "GET")({}, request);
  });
}
function update(params, request) {
  return __awaiter(this, void 0, void 0, function* () {
    const { id, resourceType } = params;
    return this.fhirRequest(`/${resourceType}/${id}`, "PUT")(params, Object.assign(Object.assign({}, request), { ifMatch: (request === null || request === void 0 ? void 0 : request.optimisticLockingVersionId) ? `W/"${request.optimisticLockingVersionId}"` : void 0 }));
  });
}
function patch({ resourceType, id, operations }, request) {
  return __awaiter(this, void 0, void 0, function* () {
    return this.fhirRequest(`/${resourceType}/${id}`, "PATCH")(operations, Object.assign(Object.assign({}, request), { contentType: "application/json-patch+json", ifMatch: (request === null || request === void 0 ? void 0 : request.optimisticLockingVersionId) ? `W/"${request.optimisticLockingVersionId}"` : void 0 }));
  });
}
function del({ resourceType, id }, request) {
  return __awaiter(this, void 0, void 0, function* () {
    return this.fhirRequest(`/${resourceType}/${id}`, "DELETE")({}, request);
  });
}
function history({ resourceType, id, versionId }, request) {
  return __awaiter(this, void 0, void 0, function* () {
    return this.fhirRequest(`/${resourceType}/${id}/_history${versionId ? `/${versionId}` : ""}`, "GET")({}, request);
  });
}
function batchInputRequestToBundleEntryItem(request) {
  const { method, url } = request;
  const baseRequest = {
    request: {
      method,
      url
    }
  };
  if (url.split("?").length > 1) {
    const [resource, query] = url.split("?");
    const params = query.split("&").map((param) => {
      const [name, value] = param.split("=");
      return { name, value };
    }).reduce((acc, { name, value }) => {
      if (!name) {
        return acc;
      }
      if (!acc[name]) {
        acc[name] = [];
      }
      acc[name].push(value);
      return acc;
    }, {});
    const search2 = new URLSearchParams();
    addParamsToSearch(params, search2);
    baseRequest.request.url = `${resource}?${search2.toString()}`;
  }
  if (["GET", "DELETE", "HEAD"].includes(method)) {
    return baseRequest;
  }
  if (method === "PUT") {
    const { resource } = request;
    return Object.assign(Object.assign({}, baseRequest), { resource });
  }
  if (method === "PATCH") {
    if ("resource" in request) {
      return Object.assign(Object.assign({}, baseRequest), { resource: request.resource });
    }
    return Object.assign(Object.assign({}, baseRequest), { resource: {
      resourceType: "Binary",
      contentType: "application/json-patch+json",
      data: Buffer.from(JSON.stringify(request.operations), "utf8").toString("base64")
    } });
  }
  if (method === "POST") {
    const { resource, fullUrl } = request;
    return Object.assign(Object.assign({}, baseRequest), { resource, fullUrl });
  }
  throw new Error("Unrecognized method");
}
function bundleRequest(type) {
  return function(input, request) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.fhirRequest("/", "POST")({
        resourceType: "Bundle",
        type,
        entry: input.requests.map(batchInputRequestToBundleEntryItem)
      }, request);
    });
  };
}
var batch = bundleRequest("batch");
var transaction = bundleRequest("transaction");
function formatAddress(address, options) {
  const builder = [];
  if (address.line) {
    builder.push(...address.line);
  }
  if (address.city || address.state || address.postalCode) {
    const cityStateZip = [];
    if (address.city) {
      cityStateZip.push(address.city);
    }
    if (address.state) {
      cityStateZip.push(address.state);
    }
    if (address.postalCode) {
      cityStateZip.push(address.postalCode);
    }
    builder.push(cityStateZip.join(", "));
  }
  if (address.use && ((options === null || options === void 0 ? void 0 : options.all) || (options === null || options === void 0 ? void 0 : options.use))) {
    builder.push("[" + address.use + "]");
  }
  return builder.join((options === null || options === void 0 ? void 0 : options.lineSeparator) || ", ").trim();
}
function formatHumanName(name, options) {
  const builder = [];
  if (name.prefix && (options === null || options === void 0 ? void 0 : options.prefix) !== false) {
    builder.push(...name.prefix);
  }
  if (name.given) {
    builder.push(...name.given);
  }
  if (name.family) {
    builder.push(name.family);
  }
  if (name.suffix && (options === null || options === void 0 ? void 0 : options.suffix) !== false) {
    builder.push(...name.suffix);
  }
  if (name.use && ((options === null || options === void 0 ? void 0 : options.all) || (options === null || options === void 0 ? void 0 : options.use))) {
    builder.push("[" + name.use + "]");
  }
  return builder.join(" ").trim();
}

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/fhir.js
var Fhir = class extends SDKResource {
  constructor(config) {
    super(config);
    this.search = search;
    this.create = create;
    this.get = get;
    this.update = update;
    this.patch = patch;
    this.delete = del;
    this.history = history;
    this.batch = batch;
    this.transaction = transaction;
    this.formatAddress = formatAddress;
    this.formatHumanName = formatHumanName;
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["fhirApiUrl"]) !== null && _b !== void 0 ? _b : "https://fhir-api.zapehr.com";
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/m2m.js
var M2m = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * DEPRECATED. Please use [v2/list](https://api-reference.oystehr.com/reference/get_m2m-v2-list) instead.
   *
   * Get a list of all M2M Clients. [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients) are used to access Oystehr APIs from scripts and server-side code like [Zambda Functions](https://docs.oystehr.com/services/zambda).
   *
   * Access Policy Action: `App:ListAllM2MClients`
   * Access Policy Resource: `IAM:M2MClient`
   */
  list(request) {
    return this.request("/m2m", "get", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Create a new M2M Client. [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients) are used to access Oystehr APIs from scripts and server-side code like [Zambda Functions](https://docs.oystehr.com/services/zambda).
   *
   * Access Policy Action: `App:CreateM2MClient`
   * Access Policy Resource: `IAM:M2MClient`
   */
  create(params, request) {
    return this.request("/m2m", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Get the M2M Client with the provided ID. [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients) are used to access Oystehr APIs from scripts and server-side code like [Zambda Functions](https://docs.oystehr.com/services/zambda).
   *
   * Access Policy Action: `App:GetM2MClient`
   * Access Policy Resource: `IAM:M2MClient`
   */
  get(params, request) {
    return this.request("/m2m/{id}", "get", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Update the M2M Client with the provided ID. [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients) are used to access Oystehr APIs from scripts and server-side code like [Zambda Functions](https://docs.oystehr.com/services/zambda).
   *
   * Access Policy Action: `App:UpdateM2MClient`
   * Access Policy Resource: `IAM:M2MClient`
   */
  update(params, request) {
    return this.request("/m2m/{id}", "patch", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Delete the M2M Client with the provided ID. [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients) are used to access Oystehr APIs from scripts and server-side code like [Zambda Functions](https://docs.oystehr.com/services/zambda).
   *
   * Access Policy Action: `App:DeleteM2MClient`
   * Access Policy Resource: `IAM:M2MClient`
   */
  delete(params, request) {
    return this.request("/m2m/{id}", "delete", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Rotate the client secret for the M2M Client with the provided ID. [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients) are used to access Oystehr APIs from scripts and server-side code like [Zambda Functions](https://docs.oystehr.com/services/zambda).
   *
   * Access Policy Action: `App:RotateM2MClientSecret`
   * Access Policy Resource: `IAM:M2MClient`
   */
  rotateSecret(params, request) {
    return this.request("/m2m/{id}/rotate-secret", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Get M2M clients in the Project with pagination, sort, sort Order and filtering. [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients) are used to access Oystehr APIs from scripts and server-side code like [Zambda Functions](https://docs.oystehr.com/services/zambda).
   *
   * Access Policy Action: `App:ListAllM2MClients`
   * Access Policy Resource: `IAM:M2MClient`
   */
  listV2(params, request) {
    return this.request("/m2m/v2/list", "get", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/messaging.js
var Messaging = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Get an information about the Messaging services configuration. This information includes phone number, phone number type and also rate limits of each service.
   */
  getMessagingConfig(request) {
    return this.request("/messaging/config", "get", this.baseUrlThunk.bind(this))(request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/paymentMethod.js
var PaymentMethod = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Enter a new credit card or other payment method for the user.
   *
   * Access Policy Requirements:
   * Action: `Payment:Setup`
   * Access Policy Resource: `Payment:PaymentMethod`
   * Actions: `FHIR:Read,FHIR:Create,FHIR:Update`
   * Access Policy Resource: `FHIR:Coverage:*`
   * Action: `FHIR:Read,FHIR:Create,FHIR:Update`
   * Access Policy Resource: `FHIR:Account:*`
   *
   * Also need to be able to read the patients' details. For example:
   * Action: `FHIR:Read`
   * Access Policy Resource: `FHIR:Patient`
   */
  setUp(params, request) {
    return this.request("/payment/payment-method/setup", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Set a specified payment method for the user as default.
   *
   * Access Policy Requirements:
   * Action: `Payment:SetDefault`
   * Access Policy Resource: `Payment:PaymentMethod`
   * Actions: `FHIR:Read,FHIR:Create,FHIR:Update`
   * Access Policy Resource: `FHIR:Coverage:*`
   * Action: `FHIR:Read,FHIR:Create,FHIR:Update`
   * Access Policy Resource: `FHIR:Account:*`
   *
   * Also need to be able to read the patients' details. For example:
   * Action: `FHIR:Read`
   * Access Policy Resource: `FHIR:Patient`
   */
  setDefault(params, request) {
    return this.request("/payment/payment-method/set-default", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Delete a specified payment method for the beneficiary.
   *
   * Access Policy Requirements:
   * Action: `Payment:Delete`
   * Access Policy Resource: `Payment:PaymentMethod`
   * Actions: `FHIR:Read,FHIR:Create,FHIR:Update`
   * Access Policy Resource: `FHIR:Coverage:*`
   * Action: `FHIR:Read,FHIR:Create,FHIR:Update`
   * Access Policy Resource: `FHIR:Account:*`
   *
   * Also need to be able to read the patients' details. For example:
   * Action: `FHIR:Read`
   * Access Policy Resource: `FHIR:Patient`
   */
  delete(params, request) {
    return this.request("/payment/payment-method", "delete", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * List all payment methods for the patient.
   *
   * Access Policy Requirements:
   * Action: `Payment:Setup`
   * Access Policy Resource: `Payment:PaymentMethod`
   * Actions: `FHIR:Read,FHIR:Create,FHIR:Update`
   * Access Policy Resource: `FHIR:Coverage:*`
   * Action: `FHIR:Read,FHIR:Create,FHIR:Update`
   * Access Policy Resource: `FHIR:Account:*`
   *
   * Also need to be able to read the patients' details. For example:
   * Action: `FHIR:Read`
   * Access Policy Resource: `FHIR:Patient`
   */
  list(params, request) {
    return this.request("/payment/payment-method/list", "post", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/project.js
var Project = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Get the Project settings for a Project. Developers must specify a [project ID](https://docs.oystehr.com/core-documentation/authenticating-api-requests/#x-zapehr-project-id-header) in the header. A Project is the logically-isolated instance of Oystehr that segments your data from other Projects. [Projects](https://docs.oystehr.com/services/project/) are completely independent from each other, having their own separate [FHIR store](https://docs.oystehr.com/services/fhir/basics/), [Applications](https://docs.oystehr.com/services/app/applications/), [Users](https://docs.oystehr.com/services/app/users/), etc .
   *
   * Access Policy Action: `Project:GetProjectInfo`
   * Access Policy Resource: `Project:Settings`
   */
  get(request) {
    return this.request("/project", "get", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Update the Project settings for the Project that corresponds to the project-id in the request header. A [Project](https://docs.oystehr.com/services/project/) is the logically-isolated instance of Oystehr that segments your data from other Projects. Projects are completely independent from each other, having their own separate [FHIR store](https://docs.oystehr.com/services/fhir/basics/), [Applications](https://docs.oystehr.com/services/app/applications/), [Users](https://docs.oystehr.com/services/app/users/), etc .
   *
   * Access Policy Action: `Project:UpdateProjectInfo`
   * Access Policy Resource: `Project:Settings`
   */
  update(params, request) {
    return this.request("/project", "patch", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/rcm.js
var Rcm = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Check [Insurance Eligibility](https://docs.oystehr.com/services/rcm/eligibility/).
   *
   * Access Policy Action: `RCM:CheckInsuranceEligibility`
   * Access Policy Resource: `RCM:InsuranceEligibility`
   *
   * Access Policy Action: `FHIR:Create`
   * Access Policy Resource: `FHIR:CoverageEligibilityResponse`
   */
  eligibilityCheck(params, request) {
    return this.request("/rcm/eligibility-check", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Check [Validate Professional Claim](https://docs.oystehr.com/services/rcm/professional-claim-submission/).
   *
   * Access Policy Action: `RCM:ValidateProfessionalClaim`
   * Access Policy Resource: `RCM:Claim`
   *
   * Access Policy Action: `FHIR:Create`
   * Access Policy Resource: `FHIR:AuditEvent`
   */
  validateProfessionalClaim(params, request) {
    return this.request("/rcm/professional-claim/validate", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Check [Submit Professional Claim](https://docs.oystehr.com/services/rcm/professional-claim-submission/).
   *
   * Access Policy Action: `RCM:SubmitProfessionalClaim`
   * Access Policy Resource: `RCM:Claim`
   *
   * Access Policy Action: `FHIR:Create`
   * Access Policy Resource: `FHIR:AuditEvent`
   *
   * Access Policy Actions: `FHIR:Create, FHIR:Update`
   * Access Policy Resource: `FHIR:Claim`
   */
  submitProfessionalClaim(params, request) {
    return this.request("/rcm/professional-claim/submit", "post", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/role.js
var Role = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Get a list of all Roles. A [Role](https://docs.oystehr.com/services/iam/roles/) defines an access policy that can be assigned to any number of [Developers](https://docs.oystehr.com/services/iam/developers/), [Users](https://docs.oystehr.com/services/app/users/), and [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients/).
   *
   * Access Policy Action: `IAM:ListAllRoles`
   * Access Policy Resource: `IAM:Role`
   */
  list(request) {
    return this.request("/iam/role", "get", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Create a new Role. A [Role](https://docs.oystehr.com/services/iam/roles/) defines an access policy that can be assigned to any number of [Developers](https://docs.oystehr.com/services/iam/developers/), [Users](https://docs.oystehr.com/services/app/users/), and [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients/).
   *
   * Access Policy Action: `IAM:CreateRole`
   * Access Policy Resource: `IAM:Role`
   */
  create(params, request) {
    return this.request("/iam/role", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Get the Role with the provided ID. A [Role](https://docs.oystehr.com/services/iam/roles/) defines an access policy that can be assigned to any number of [Developers](https://docs.oystehr.com/services/iam/developers/), [Users](https://docs.oystehr.com/services/app/users/), and [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients/).
   *
   * Access Policy Action: `IAM:GetRole`
   * Access Policy Resource: `IAM:Role`
   */
  get(params, request) {
    return this.request("/iam/role/{roleId}", "get", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Update the Role with the provided ID. A [Role](https://docs.oystehr.com/services/iam/roles/) defines an access policy that can be assigned to any number of [Developers](https://docs.oystehr.com/services/iam/developers/), [Users](https://docs.oystehr.com/services/app/users/), and [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients/).
   *
   * Access Policy Action: `IAM:UpdateRole`
   * Access Policy Resource: `IAM:Role`
   */
  update(params, request) {
    return this.request("/iam/role/{roleId}", "patch", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Delete the Role with the provided ID. A [Role](https://docs.oystehr.com/services/iam/roles/) defines an access policy that can be assigned to any number of [Developers](https://docs.oystehr.com/services/iam/developers/), [Users](https://docs.oystehr.com/services/app/users/), and [M2M Clients](https://docs.oystehr.com/services/iam/m2m-clients/).
   *
   * Access Policy Action: `IAM:DeleteRole`
   * Access Policy Resource: `IAM:Role`
   * Will fail if any entities hold the Role or if Role is assigned as the default patient role for the project
   */
  delete(params, request) {
    return this.request("/iam/role/{roleId}", "delete", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/secret.js
var Secret = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Get a list of all secrets in the Project.
   *
   * Access Policy Action: `Zambda:ListAllSecrets`
   * Access Policy Resource: `Zambda:Secret`
   */
  list(request) {
    return this.request("/secret", "get", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Create a secret for a project. If the secret is already defined, update it.
   *
   * Access Policy Action: `Zambda:CreateSecret`
   * Access Policy Resource: `Zambda:Secret`
   */
  set(params, request) {
    return this.request("/secret", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Get the secret with the provided name.
   *
   * Access Policy Action: `Zambda:GetSecret`
   * Access Policy Resource: `Zambda:Secret`
   */
  get(params, request) {
    return this.request("/secret/{name}", "get", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Delete the secret with the provided name.
   *
   * Access Policy Action: `Zambda:DeleteSecret`
   * Access Policy Resource: `Zambda:Secret`
   */
  delete(params, request) {
    return this.request("/secret/{name}", "delete", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/telemed.js
var Telemed = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Create a [telemedicine video meeting](https://docs.oystehr.com/services/telemed/).
   *
   * Access Policy Requirements:
   * Action: `Telemed:CreateMeeting`
   * Access Policy Resource: `Telemed:Meeting`
   * Action: `FHIR:Create`
   * Access Policy Resource: `FHIR:Encounter`
   * Action: `FHIR:Update`
   * Access Policy Resource: `FHIR:Encounter`
   */
  createMeeting(params, request) {
    return this.request("/telemed/v2/meeting", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Get Meeting and Attendee objects necessary to join a telemedicine video meeting.
   *
   * Access Policy Requirements:
   * Action: `Telemed:JoinMeeting`
   * Access Policy Resource: `Telemed:Meeting`
   * To use M2M token to join as anonymous user:
   * Action: `Telemed:AddAnonymousToMeeting`
   * Access Policy Resource: `Telemed:Meeting`
   */
  joinMeeting(params, request) {
    return this.request("/telemed/v2/meeting/{encounterId}/join", "get", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/transactionalSMS.js
var TransactionalSMS = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Send an SMS to any phone number. Oystehr's [Transactional SMS](https://docs.oystehr.com/services/messaging/transactional-sms/) feature makes it easy to send a text message to your [Users](https://docs.oystehr.com/services/app/users/) with a single API call. You can use this feature to send appointment reminders, prescription refill reminders, discharge information, and more.
   *
   * Access Policy Requirements:
   * Action: `Messaging:SendTransactionalSMS`
   * Access Policy Resource: `Messaging:TransactionalSMS`
   * Action: `FHIR:Create`
   * Access Policy Resource: `FHIR:Communication`
   * Action: `FHIR:Update`
   * Access Policy Resource: `FHIR:Communication`
   *
   * You also need Read access for the resource to which you are sending a message. For example:
   * Action: `FHIR:Read`
   * Access Policy Resource: `FHIR:Patient`
   */
  send(params, request) {
    return this.request("/messaging/transactional-sms/send", "post", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/user.js
var User = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Get your own User details. [Users](https://docs.oystehr.com/services/app/users/) are the people who log into the [Applications](https://docs.oystehr.com/services/app/applications/) you configure for securing the apps you build on top of Oystehr.
   *
   * Fetch details about the calling User. This endpoint has no access policy requirements, it is available to all authenticated Users.
   */
  me(request) {
    return this.request("/user/me", "get", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Get the User with the provided ID. [Users](https://docs.oystehr.com/services/app/users/) are the people who log into the [Applications](https://docs.oystehr.com/services/app/applications/) you configure for securing the apps you build on top of Oystehr.
   *
   * Access Policy Action: `App:GetUser`
   * Access Policy Resource: `App:User`
   */
  get(params, request) {
    return this.request("/user/{id}", "get", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Update the User with the provided ID. [Users](https://docs.oystehr.com/services/app/users/) are the people who log into the [Applications](https://docs.oystehr.com/services/app/applications/) you configure for securing the apps you build on top of Oystehr.
   *
   * Access Policy Action: `App:UpdateUser`
   * Access Policy Resource: `App:User`
   */
  update(params, request) {
    return this.request("/user/{id}", "patch", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Delete the User with the provided ID. [Users](https://docs.oystehr.com/services/app/users/) are the people who log into the [Applications](https://docs.oystehr.com/services/app/applications/) you configure for securing the apps you build on top of Oystehr.
   *
   * Access Policy Action: `App:DeleteUser`
   * Access Policy Resource: `App:User`
   */
  delete(params, request) {
    return this.request("/user/{id}", "delete", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Invite a User to the Project. [Users](https://docs.oystehr.com/services/app/users/) are the people who log into the [Applications](https://docs.oystehr.com/services/app/applications/) you configure for securing the apps you build on top of Oystehr.
   *
   * Access Policy Action: `App:CreateUser`
   * Access Policy Resource: `App:User`
   */
  invite(params, request) {
    return this.request("/user/invite", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * DEPRECATED. Please use [v2/list](https://api-reference.oystehr.com/reference/get_user-v2-list) instead.
   *
   * Get all Users in the Project. [Users](https://docs.oystehr.com/services/app/users/) are the people who log into the [Applications](https://docs.oystehr.com/services/app/applications/) you configure for securing the apps you build on top of Oystehr.
   *
   * Access Policy Action: `App:ListAllUsers`
   * Access Policy Resource: `App:User`
   */
  list(request) {
    return this.request("/user", "get", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Get Users in the Project with pagination, sort, sort Order and filtering. [Users](https://docs.oystehr.com/services/app/users/) are the people who log into the [Applications](https://docs.oystehr.com/services/app/applications/) you configure for securing the apps you build on top of Oystehr.
   *
   * Access Policy Action: `Project:ListAllUsers`
   * Access Policy Resource: `Project:Settings`
   */
  listV2(params, request) {
    return this.request("/user/v2/list", "get", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/version.js
var Version = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Get project API version. This endpoint is public so there are no access policy requirements.
   */
  get(request) {
    return this.request("/version", "get", this.baseUrlThunk.bind(this))(request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/z3-ext.js
function baseUrlThunk() {
  var _a, _b;
  return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
}
function uploadFile({ bucketName, "objectPath+": key, file }) {
  return __awaiter(this, void 0, void 0, function* () {
    const uploadUrl = yield this.request("/z3/{bucketName}/{objectPath+}", "post", baseUrlThunk.bind(this))({
      action: "upload",
      bucketName,
      "objectPath+": key
    });
    yield fetch(uploadUrl.signedUrl, {
      method: "PUT",
      body: file
    });
  });
}
function downloadFile({ bucketName, "objectPath+": key }) {
  return __awaiter(this, void 0, void 0, function* () {
    const uploadUrl = yield this.request("/z3/{bucketName}/{objectPath+}", "post", baseUrlThunk.bind(this))({
      action: "download",
      bucketName,
      "objectPath+": key
    });
    const resp = yield fetch(uploadUrl.signedUrl, {
      method: "GET"
    });
    if (!resp.ok) {
      throw new Error("Failed to download file");
    }
    return resp.arrayBuffer();
  });
}
function getPresignedUrlForZ3Url(params) {
  var _a, _b;
  return __awaiter(this, void 0, void 0, function* () {
    let bucket;
    let key;
    const url = new URL(params.url);
    if (url.protocol === "z3:") {
      const z3PathParts = url.pathname.split("/").slice(1);
      bucket = url.hostname;
      key = z3PathParts.join("/");
    } else if (url.href.startsWith((_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : defaultProjectApiUrl)) {
      const httpsPathParts = url.pathname.split("/").slice(3);
      bucket = httpsPathParts[0];
      key = httpsPathParts.slice(1).join("/");
    } else {
      throw new OystehrSdkError({ message: "Invalid Z3 URL", code: 400 });
    }
    const requestParams = {
      action: "upload",
      bucketName: bucket,
      "objectPath+": key
    };
    return this.request("/z3/{bucketName}/{objectPath+}", "post", baseUrlThunk.bind(this))(requestParams);
  });
}

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/z3.js
var Z3 = class extends SDKResource {
  constructor(config) {
    super(config);
    this.uploadFile = uploadFile;
    this.downloadFile = downloadFile;
    this.getPresignedUrlForZ3Url = getPresignedUrlForZ3Url;
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * List all Z3 Buckets. [Z3](https://docs.oystehr.com/services/z3/) is Oystehr's built-in and fully integrated solution for file storage.
   *
   * Access Policy Action: `Z3:ListBuckets`
   * Access Policy Resource: `Z3:BucketName`
   */
  listBuckets(request) {
    return this.request("/z3", "get", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Create a Z3 Bucket with the provided name. [Z3](https://docs.oystehr.com/services/z3/) is Oystehr's built-in and fully integrated solution for file storage.
   *
   * Access Policy Action: `Z3:CreateBucket`
   * Access Policy Resource: `Z3:BucketName`
   */
  createBucket(params, request) {
    return this.request("/z3/{bucketName}", "put", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Delete the Z3 Bucket with the provided name. [Z3](https://docs.oystehr.com/services/z3/) is Oystehr's built-in and fully integrated solution for file storage.
   *
   * Access Policy Action: `Z3:DeleteBucket`
   * Access Policy Resource: `Z3:BucketName`
   */
  deleteBucket(params, request) {
    return this.request("/z3/{bucketName}", "delete", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * List all Z3 Objects at the provided path in the Bucket with the provided name [Z3](https://docs.oystehr.com/services/z3/) is Oystehr's built-in and fully integrated solution for file storage.
   *
   * Access Policy Action: `Z3:ListObjects`
   * Access Policy Resource: `Z3:BucketName:ObjectPath`
   */
  listObjects(params, request) {
    return this.request("/z3/{bucketName}/{objectPath+}", "get", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Get a link for downloading or uploading a Z3 Object to the provided path in the Bucket with the provided name. [Z3](https://docs.oystehr.com/services/z3/) is Oystehr's built-in and fully integrated solution for file storage.
   *
   * Access Policy Action: `Z3:PutObject` or `Z3:GetObject`
   * Access Policy Resource: `Z3:BucketName:ObjectPath`
   */
  getPresignedUrl(params, request) {
    return this.request("/z3/{bucketName}/{objectPath+}", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Delete the Z3 Object at the provided path in the Bucket with the provided name. [Z3](https://docs.oystehr.com/services/z3/) is Oystehr's built-in and fully integrated solution for file storage.
   *
   * Access Policy Action: `Z3:DeleteObject`
   * Access Policy Resource: `Z3:BucketName:ObjectPath`
   */
  deleteObject(params, request) {
    return this.request("/z3/{bucketName}/{objectPath+}", "delete", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/zambda-ext.js
function baseUrlThunk2() {
  var _a, _b;
  return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
}
function uploadFile2({ id, file, filename }) {
  return __awaiter(this, void 0, void 0, function* () {
    const uploadUrl = yield this.request("/zambda/{id}/s3-upload", "post", baseUrlThunk2.bind(this))({ id, filename });
    yield fetch(uploadUrl.signedUrl, {
      method: "PUT",
      body: file
    });
  });
}

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/zambda.js
var Zambda = class extends SDKResource {
  constructor(config) {
    super(config);
    this.uploadFile = uploadFile2;
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Get a list of all Zambda Functions in the Project. [Zambdas](https://docs.oystehr.com/services/zambda/) are functions that can be used to execute your code. They can be used to process data received from Oystehr's APIs or to perform operations on third-party services.
   *
   * Access Policy Action: `Zambda:ListAllFunctions`
   * Access Policy Resource: `Zambda:Function`
   */
  list(request) {
    return this.request("/zambda", "get", this.baseUrlThunk.bind(this))(request);
  }
  /**
   * Create a new Zambda Function. [Zambdas](https://docs.oystehr.com/services/zambda/) are functions that can be used to execute your code. They can be used to process data received from Oystehr's APIs or to perform operations on third-party services.
   *
   * Access Policy Action: `Zambda:CreateFunction`
   * Access Policy Resource: `Zambda:Function`
   */
  create(params, request) {
    return this.request("/zambda", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Get the Zambda Function with the provided ID or name. [Zambdas](https://docs.oystehr.com/services/zambda/) are functions that can be used to execute your code. They can be used to process data received from Oystehr's APIs or to perform operations on third-party services.
   *
   * Access Policy Action: `Zambda:GetFunction`
   * Access Policy Resource: `Zambda:Function`
   */
  get(params, request) {
    return this.request("/zambda/{id}", "get", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Update the Zambda Function with the provided ID or name. [Zambdas](https://docs.oystehr.com/services/zambda/) are functions that can be used to execute your code. They can be used to process data received from Oystehr's APIs or to perform operations on third-party services.
   *
   * Access Policy Action: `Zambda:UpdateFunction`
   * Access Policy Resource: `Zambda:Function`
   */
  update(params, request) {
    return this.request("/zambda/{id}", "patch", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Delete the Zambda Function with the provided ID or name. [Zambdas](https://docs.oystehr.com/services/zambda/) are functions that can be used to execute your code. They can be used to process data received from Oystehr's APIs or to perform operations on third-party services.
   *
   * Access Policy Action: `Zambda:DeleteFunction`
   * Access Policy Resource: `Zambda:Function`
   */
  delete(params, request) {
    return this.request("/zambda/{id}", "delete", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Execute the [Authenticated Zambda Function](https://docs.oystehr.com/services/zambda/types/authenticated/) with the provided ID. [Zambdas](https://docs.oystehr.com/services/zambda/) are functions that can be used to execute your code. They can be used to process data received from Oystehr's APIs or to perform operations on third-party services.
   *
   * Access Policy Action: `Zambda:InvokeFunction`
   * Access Policy Resource: `Zambda:Function`
   */
  execute(params, request) {
    return this.request("/zambda/{id}/execute", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Execute the [Public Zambda Function](https://docs.oystehr.com/services/zambda/types/public/) with the provided ID. [Zambdas](https://docs.oystehr.com/services/zambda/) are functions that can be used to execute your code. They can be used to process data received from Oystehr's APIs or to perform operations on third-party services.
   *
   * Execute a zambda that has method http_open. This endpoint is public so there are no access policy requirements.
   */
  executePublic(params, request) {
    return this.request("/zambda/{id}/execute-public", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Returns a URL that is used to deploy code to the Zambda Function with the provided ID. [Zambdas](https://docs.oystehr.com/services/zambda/) are functions that can be used to execute your code. They can be used to process data received from Oystehr's APIs or to perform operations on third-party services.
   *
   * Access Policy Action: `Zambda:UpdateFunction`
   * Access Policy Resource: `Zambda:Function`
   */
  s3Upload(params, request) {
    return this.request("/zambda/{id}/s3-upload", "post", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/zambdaLogStream.js
var ZambdaLogStream = class extends SDKResource {
  constructor(config) {
    super(config);
  }
  baseUrlThunk() {
    var _a, _b;
    return (_b = (_a = this.config.services) === null || _a === void 0 ? void 0 : _a["projectApiUrl"]) !== null && _b !== void 0 ? _b : "https://project-api.zapehr.com/v1";
  }
  /**
   * Get the log streams for the Zambda Function with the provided ID. [Zambdas](https://docs.oystehr.com/services/zambda/) are functions that can be used to execute your code. They can be used to process data received from Oystehr's APIs or to perform operations on third-party services.
   *
   * Access Policy Action: `Zambda:ReadLogs`
   * Access Policy Resource: `Zambda:Function`
   */
  list(params, request) {
    return this.request("/zambda/{id}/logStream", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Get all logs for the Zambda Function with the provided ID, filtered by any of: text in messages, minimum start date, and/or maximum end date. [Zambdas](https://docs.oystehr.com/services/zambda/) are functions that can be used to execute your code. They can be used to process data received from Oystehr's APIs or to perform operations on third-party services.
   *
   * Access Policy Action: `Zambda:ReadLogs`
   * Access Policy Resource: `Zambda:Function`
   */
  search(params, request) {
    return this.request("/zambda/{id}/logStream/search", "post", this.baseUrlThunk.bind(this))(params, request);
  }
  /**
   * Get the logs from the specified log stream for the Zambda Function with the provided ID. [Zambdas](https://docs.oystehr.com/services/zambda/) are functions that can be used to execute your code. They can be used to process data received from Oystehr's APIs or to perform operations on third-party services.
   *
   * Access Policy Action: `Zambda:ReadLogs`
   * Access Policy Resource: `Zambda:Function`
   */
  get(params, request) {
    return this.request("/zambda/{id}/logStream/{logStreamName}", "post", this.baseUrlThunk.bind(this))(params, request);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/resources/classes/index.js
var Oystehr$1 = class Oystehr {
  constructor(config) {
    var _a, _b, _c;
    var _d, _e, _f;
    this.config = config;
    (_a = (_d = this.config).services) !== null && _a !== void 0 ? _a : _d.services = {};
    (_b = (_e = this.config.services).projectApiUrl) !== null && _b !== void 0 ? _b : _e.projectApiUrl = config.projectApiUrl;
    (_c = (_f = this.config.services).fhirApiUrl) !== null && _c !== void 0 ? _c : _f.fhirApiUrl = config.fhirApiUrl;
    this.application = new Application(config);
    this.developer = new Developer(config);
    this.m2m = new M2m(config);
    this.messaging = new Messaging(config);
    this.conversation = new Conversation(config);
    this.transactionalSMS = new TransactionalSMS(config);
    this.paymentMethod = new PaymentMethod(config);
    this.charge = new Charge(config);
    this.project = new Project(config);
    this.rcm = new Rcm(config);
    this.erx = new Erx(config);
    this.role = new Role(config);
    this.secret = new Secret(config);
    this.telemed = new Telemed(config);
    this.user = new User(config);
    this.version = new Version(config);
    this.z3 = new Z3(config);
    this.zambda = new Zambda(config);
    this.zambdaLogStream = new ZambdaLogStream(config);
    this.fax = new Fax(config);
    this.fhir = new Fhir(config);
  }
};

// ../../../node_modules/@oystehr/sdk/dist/esm/index.js
var Oystehr2 = class extends Oystehr$1 {
};
Oystehr2.OystehrFHIRError = OystehrFHIRError;
Oystehr2.OystehrSdkError = OystehrSdkError;

// ../../utils/lib/validation/constants.ts
var DATETIME_FULL_NO_YEAR = "MMMM d, h:mm a ZZZZ";

// ../../utils/lib/helpers/helpers.ts
function formatPhoneNumberDisplay(phoneNumber) {
  const cleaned = ("" + phoneNumber).replace(/\D/g, "");
  const match2 = cleaned.match(/^(\d{3})(\d{3})(\d{4})$/);
  if (match2) {
    return `(${match2[1]}) ${match2[2]}-${match2[3]}`;
  }
  return phoneNumber;
}

// ../../../node_modules/i18next/dist/esm/i18next.js
var consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    if (console && console[type])
      console[type].apply(console, args);
  }
};
var Logger = class _Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug)
      return null;
    if (typeof args[0] === "string")
      args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new _Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new _Logger(this.logger, options);
  }
};
var baseLogger = new Logger();
var EventEmitter = class {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event])
        this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event])
      return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
};
function defer() {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object2) {
  if (object2 == null)
    return "";
  return "" + object2;
}
function copy(a, s2, t2) {
  a.forEach((m) => {
    if (s2[m])
      t2[m] = s2[m];
  });
}
var lastOfPathSeparatorRegExp = /###/g;
function getLastOfPath(object2, path2, Empty) {
  function cleanKey(key) {
    return key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
  }
  function canNotTraverseDeeper() {
    return !object2 || typeof object2 === "string";
  }
  const stack = typeof path2 !== "string" ? path2 : path2.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper())
      return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object2[key] && Empty)
      object2[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object2, key)) {
      object2 = object2[key];
    } else {
      object2 = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object2,
    k: cleanKey(stack[stackIndex])
  };
}
function setPath(object2, path2, newValue) {
  const {
    obj,
    k
  } = getLastOfPath(object2, path2, Object);
  if (obj !== void 0 || path2.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e = path2[path2.length - 1];
  let p = path2.slice(0, path2.length - 1);
  let last = getLastOfPath(object2, p, Object);
  while (last.obj === void 0 && p.length) {
    e = `${p[p.length - 1]}.${e}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object2, p, Object);
    if (last && last.obj && typeof last.obj[`${last.k}.${e}`] !== "undefined") {
      last.obj = void 0;
    }
  }
  last.obj[`${last.k}.${e}`] = newValue;
}
function pushPath(object2, path2, newValue, concat) {
  const {
    obj,
    k
  } = getLastOfPath(object2, path2, Object);
  obj[k] = obj[k] || [];
  if (concat)
    obj[k] = obj[k].concat(newValue);
  if (!concat)
    obj[k].push(newValue);
}
function getPath(object2, path2) {
  const {
    obj,
    k
  } = getLastOfPath(object2, path2);
  if (!obj)
    return void 0;
  return obj[k];
}
function getPathWithDefaults(data, defaultData, key) {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, (s2) => _entityMap[s2]);
  }
  return data;
}
var RegExpCache = class {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
};
var chars = [" ", ",", "?", "!", ";"];
var looksLikeObjectPathRegExpCache = new RegExpCache(20);
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0)
    return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function deepFind(obj, path2) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path2])
    return obj[path2];
  const tokens = path2.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next;
  }
  return current;
}
function getCleanedCode(code) {
  if (code && code.indexOf("_") > 0)
    return code.replace("_", "-");
  return code;
}
var ResourceStore = class extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index2 = this.options.ns.indexOf(ns);
    if (index2 > -1) {
      this.options.ns.splice(index2, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2;
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
    } else {
      path2 = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path2.push(...key);
        } else if (typeof key === "string" && keySeparator) {
          path2.push(...key.split(keySeparator));
        } else {
          path2.push(key);
        }
      }
    }
    const result = getPath(this.data, path2);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path2[0];
      ns = path2[1];
      key = path2.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || typeof key !== "string")
      return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    if (key)
      path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      value = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path2, value);
    if (!options.silent)
      this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m in resources) {
      if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]")
        this.addResource(lng, ns, m, resources[m], {
          silent: true
        });
    }
    if (!options.silent)
      this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path2 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path2) || {};
    if (!options.skipCopy)
      resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path2, pack);
    if (!options.silent)
      this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns)
      ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1")
      return {
        ...{},
        ...this.getResource(lng, ns)
      };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
var postProcessor = {
  processors: {},
  addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor])
        value = this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};
var Translator = class _Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng)
      this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0)
      nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
        namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    if (typeof namespaces === "string")
      namespaces = [namespaces];
    return {
      key,
      namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object")
      options = {
        ...options
      };
    if (!options)
      options = {};
    if (keys === void 0 || keys === null)
      return "";
    if (!Array.isArray(keys))
      keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = resType === "[object Array]";
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            copy2[m] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m] === deepKey)
              copy2[m] = res[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
      res = res.join(joinArrays);
      if (res)
        res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const hasDefaultValue = _Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res)
            this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l2, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l2, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l2, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l2, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
        res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation)
        this.interpolator.init({
          ...options,
          ...{
            interpolation: {
              ...this.options.interpolation,
              ...options.interpolation
            }
          }
        });
      const skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && typeof options.replace !== "string" ? options.replace : options;
      if (this.options.interpolation.defaultVariables)
        data = {
          ...this.options.interpolation.defaultVariables,
          ...data
        };
      res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft)
          options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res)
        options.lng = resolved.usedLng;
      if (options.nest !== false)
        res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (lastKey && lastKey[0] === args[0] && !options.context) {
            _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
            return null;
          }
          return _this.translate(...args, key);
        }, options);
      if (options.interpolation)
        this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (typeof keys === "string")
      keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found))
        return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS)
        namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found))
          return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found))
            return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling)
              pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource)
      return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && typeof options.replace !== "string";
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
};
function capitalize(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
var LanguageUtil = class {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0)
      return null;
    const p = code.split("-");
    if (p.length === 2)
      return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x")
      return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0)
      return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (typeof code === "string" && code.indexOf("-") > -1) {
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p = code.split("-");
      if (this.options.lowerCaseLng) {
        p = p.map((part) => part.toLowerCase());
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1)
          p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();
        if (p[1].length === 2)
          p[1] = p[1].toUpperCase();
        if (p[0] !== "sgn" && p[2].length === 2)
          p[2] = p[2].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1)
          p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1)
          p[2] = capitalize(p[2].toLowerCase());
      }
      return p.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes)
      return null;
    let found;
    codes.forEach((code) => {
      if (found)
        return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng))
        found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found)
          return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly))
          return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly)
            return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0)
            return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly)
            return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1)
            return supportedLng;
        });
      });
    }
    if (!found)
      found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks)
      return [];
    if (typeof fallbacks === "function")
      fallbacks = fallbacks(code);
    if (typeof fallbacks === "string")
      fallbacks = [fallbacks];
    if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
      return fallbacks;
    if (!code)
      return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found)
      found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found)
      found = fallbacks[this.formatLanguageCode(code)];
    if (!found)
      found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found)
      found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c) => {
      if (!c)
        return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (typeof code === "string" && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly")
        addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
        addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly")
        addCode(this.getLanguagePartFromCode(code));
    } else if (typeof code === "string") {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0)
        addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
};
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function(n2) {
    return Number(n2 > 1);
  },
  2: function(n2) {
    return Number(n2 != 1);
  },
  3: function(n2) {
    return 0;
  },
  4: function(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function(n2) {
    return Number(n2 >= 2);
  },
  10: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function(n2) {
    return Number(n2 !== 0);
  },
  14: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
var nonIntlVersions = ["v1", "v2", "v3"];
var intlVersions = ["v4"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  const rules = {};
  sets.forEach((set) => {
    set.lngs.forEach((l2) => {
      rules[l2] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = class {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      try {
        return new Intl.PluralRules(getCleanedCode(code === "dev" ? "en" : code), {
          type: options.ordinal ? "ordinal" : "cardinal"
        });
      } catch (err) {
        return;
      }
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number) => this.getSuffix(code, number, options));
  }
  getSuffix(code, count) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
      }
      return this.getSuffixRetroCompatible(rule, count);
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count) {
    const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1)
        return "";
      if (typeof suffix === "number")
        return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
};
function deepFindWithDefaults(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path2 = getPathWithDefaults(data, defaultData, key);
  if (!path2 && ignoreJSONStructure && typeof key === "string") {
    path2 = deepFind(data, key, keySeparator);
    if (path2 === void 0)
      path2 = deepFind(defaultData, key, keySeparator);
  }
  return path2;
}
var Interpolator = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation)
      options.interpolation = {
        escapeValue: true
      };
    const iOpts = options.interpolation;
    this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
    this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
    this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
    this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
    this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
    this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
    this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options)
      this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp && existingRegExp.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match2;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function regexSafe(val) {
      return val.replace(/\$/g, "$$$$");
    }
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path2;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match2 = todo.regex.exec(str)) {
        const matchedVar = match2[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match2, options);
            value = typeof temp === "string" ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match2[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (typeof value !== "string" && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match2[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match2[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match2;
    let value;
    let clonedOptions;
    function handleHasOptions(key, inheritedOptions) {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0)
        return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions)
          clonedOptions = {
            ...inheritedOptions,
            ...clonedOptions
          };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      delete clonedOptions.defaultValue;
      return key;
    }
    while (match2 = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
        const r = match2[1].split(this.formatSeparator).map((elem) => elem.trim());
        match2[1] = r.shift();
        formatters = r;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions);
      if (value && match2[0] === str && typeof value !== "string")
        return value;
      if (typeof value !== "string")
        value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match2[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match2[1].trim()
        }), value.trim());
      }
      str = str.replace(match2[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
};
function parseFormatStr(formatStr) {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (!opt)
          return;
        const [key, ...rest] = opt.split(":");
        const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val;
        if (val === "false")
          formatOptions[key.trim()] = false;
        if (val === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val))
          formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn) {
  const cache = {};
  return function invokeFormatter(val, lng, options) {
    const key = lng + JSON.stringify(options);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
}
var Formatter2 = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    const iOpts = options.interpolation;
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l2, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
};
function removePending(q, name) {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
}
var Connector = class extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0)
          ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0)
            pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0)
            pending[name] = true;
          if (toLoad[name] === void 0)
            toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0)
            toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces)
        toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    if (err)
      this.emit("failedLoading", lng, ns, err);
    if (data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err)
        q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l2) => {
          if (!loaded[l2])
            loaded[l2] = {};
          const loadedKeys = q.loaded[l2];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded[l2][n2] === void 0)
                loaded[l2][n2] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length)
      return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === "function") {
          r.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (typeof languages === "string")
      languages = this.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === "string")
      namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length)
        callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err)
        this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data)
        this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "")
      return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0])
      return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
};
function get2() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: false,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      let ret = {};
      if (typeof args[1] === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (typeof args[2] === "object" || typeof args[3] === "object") {
        const options = args[3] || args[2];
        Object.keys(options).forEach((key) => {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: (value) => value,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function noop() {
}
function bindMemberFunctions(inst) {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = class _I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (typeof options.ns === "string") {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get2();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    function createClassOnDemand(ClassOrObject) {
      if (!ClassOrObject)
        return null;
      if (typeof ClassOrObject === "function")
        return new ClassOrObject();
      return ClassOrObject;
    }
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter2;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s2 = this.services;
      s2.logger = baseLogger;
      s2.resourceStore = this.store;
      s2.languageUtils = lu;
      s2.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s2.formatter = createClassOnDemand(formatter);
        s2.formatter.init(s2, this.options);
        this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
      }
      s2.interpolator = new Interpolator(this.options);
      s2.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
      s2.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s2.languageDetector.init)
          s2.languageDetector.init(s2, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s2.i18nFormat.init)
          s2.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init)
          m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback)
      callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev")
        this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce)
          this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone)
          this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
        return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = typeof language === "string" ? language : this.language;
    if (typeof language === "function")
      usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
        return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng)
          return;
        if (lng === "cimode")
          return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l2) => {
          if (l2 === "cimode")
            return;
          if (toLoad.indexOf(l2) < 0)
            toLoad.push(l2);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l2) => append(l2));
      } else {
        append(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l2) => append(l2));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
        if (!e && !this.resolvedLanguage && this.language)
          this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (!lngs)
      lngs = this.languages;
    if (!ns)
      ns = this.options.ns;
    if (!callback)
      callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module2) {
    if (!module2)
      throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module2.type)
      throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module2.type === "backend") {
      this.modules.backend = module2;
    }
    if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
      this.modules.logger = module2;
    }
    if (module2.type === "languageDetector") {
      this.modules.languageDetector = module2;
    }
    if (module2.type === "i18nFormat") {
      this.modules.i18nFormat = module2;
    }
    if (module2.type === "postProcessor") {
      postProcessor.addPostProcessor(module2);
    }
    if (module2.type === "formatter") {
      this.modules.formatter = module2;
    }
    if (module2.type === "3rdParty") {
      this.modules.external.push(module2);
    }
    return this;
  }
  setResolvedLanguage(l2) {
    if (!l2 || !this.languages)
      return;
    if (["cimode", "dev"].indexOf(l2) > -1)
      return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1)
        continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l2) => {
      this.language = l2;
      this.languages = this.services.languageUtils.toResolveHierarchy(l2);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l2);
    };
    const done = (err, l2) => {
      if (l2) {
        setLngProps(l2);
        this.translator.changeLanguage(l2);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l2);
        this.logger.log("languageChanged", l2);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback)
        callback(err, function() {
          return _this2.t(...arguments);
        });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector)
        lngs = [];
      const l2 = typeof lngs === "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l2) {
        if (!this.language) {
          setLngProps(l2);
        }
        if (!this.translator.language)
          this.translator.changeLanguage(l2);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage)
          this.services.languageDetector.cacheUserLanguage(l2);
      }
      this.loadResources(l2, (err) => {
        done(err, l2);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (typeof lng === "string") {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode")
      return true;
    const loadNotPending = (l2, n2) => {
      const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
      return loadState === -1 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0)
        return preResult;
    }
    if (this.hasResourceBundle(lng, ns))
      return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
      return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
      return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    if (typeof ns === "string")
      ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0)
        this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (typeof lngs === "string")
      lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0);
    if (!newLngs.length) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng)
      lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng)
      return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get2());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new _I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore)
      delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone3 = new _I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone3.logger = clone3.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone3[m] = this[m];
    });
    clone3.services = {
      ...this.services
    };
    clone3.services.utils = {
      hasLoadedNamespace: clone3.hasLoadedNamespace.bind(clone3)
    };
    if (forkResourceStore) {
      clone3.store = new ResourceStore(this.store.data, mergedOptions);
      clone3.services.resourceStore = clone3.store;
    }
    clone3.translator = new Translator(clone3.services, mergedOptions);
    clone3.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone3.emit(event, ...args);
    });
    clone3.init(mergedOptions, callback);
    clone3.translator.options = mergedOptions;
    clone3.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone3.hasLoadedNamespace.bind(clone3)
    };
    return clone3;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
var createInstance = instance.createInstance;
var dir = instance.dir;
var init2 = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace = instance.hasLoadedNamespace;
var loadNamespaces = instance.loadNamespaces;
var loadLanguages = instance.loadLanguages;

// ../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n2) {
  if (!(a instanceof n2))
    throw new TypeError("Cannot call a class as a function");
}

// ../../../node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// ../../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t2, r) {
  if ("object" != _typeof(t2) || !t2)
    return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t2, r || "default");
    if ("object" != _typeof(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}

// ../../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

// ../../../node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e, r) {
  for (var t2 = 0; t2 < r.length; t2++) {
    var o = r[t2];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t2) {
  return r && _defineProperties(e.prototype, r), t2 && _defineProperties(e, t2), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}

// ../../../node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js
var arr = [];
var each = arr.forEach;
var slice = arr.slice;
function defaults(obj) {
  each.call(slice.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0)
          obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var serializeCookie = function serializeCookie2(name, val, options) {
  var opt = options || {};
  opt.path = opt.path || "/";
  var value = encodeURIComponent(val);
  var str = "".concat(name, "=").concat(value);
  if (opt.maxAge > 0) {
    var maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge))
      throw new Error("maxAge should be a Number");
    str += "; Max-Age=".concat(Math.floor(maxAge));
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=".concat(opt.domain);
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=".concat(opt.path);
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=".concat(opt.expires.toUTCString());
  }
  if (opt.httpOnly)
    str += "; HttpOnly";
  if (opt.secure)
    str += "; Secure";
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
var cookie = {
  create: function create2(name, value, minutes, domain) {
    var cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = /* @__PURE__ */ new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain)
      cookieOptions.domain = domain;
    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);
  },
  read: function read(name) {
    var nameEQ = "".concat(name, "=");
    var ca = document.cookie.split(";");
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEQ) === 0)
        return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  remove: function remove(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  lookup: function lookup(options) {
    var found;
    if (options.lookupCookie && typeof document !== "undefined") {
      var c = cookie.read(options.lookupCookie);
      if (c)
        found = c;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupCookie && typeof document !== "undefined") {
      cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  lookup: function lookup2(options) {
    var found;
    if (typeof window !== "undefined") {
      var search2 = window.location.search;
      if (!window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1) {
        search2 = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      var query = search2.substring(1);
      var params = query.split("&");
      for (var i = 0; i < params.length; i++) {
        var pos = params[i].indexOf("=");
        if (pos > 0) {
          var key = params[i].substring(0, pos);
          if (key === options.lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
var hasLocalStorageSupport = null;
var localStorageAvailable = function localStorageAvailable2() {
  if (hasLocalStorageSupport !== null)
    return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
    var testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage2 = {
  name: "localStorage",
  lookup: function lookup3(options) {
    var found;
    if (options.lookupLocalStorage && localStorageAvailable()) {
      var lng = window.localStorage.getItem(options.lookupLocalStorage);
      if (lng)
        found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage2(lng, options) {
    if (options.lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(options.lookupLocalStorage, lng);
    }
  }
};
var hasSessionStorageSupport = null;
var sessionStorageAvailable = function sessionStorageAvailable2() {
  if (hasSessionStorageSupport !== null)
    return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
    var testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage = {
  name: "sessionStorage",
  lookup: function lookup4(options) {
    var found;
    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      var lng = window.sessionStorage.getItem(options.lookupSessionStorage);
      if (lng)
        found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage3(lng, options) {
    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(options.lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup: function lookup5(options) {
    var found = [];
    if (typeof navigator !== "undefined") {
      if (navigator.languages) {
        for (var i = 0; i < navigator.languages.length; i++) {
          found.push(navigator.languages[i]);
        }
      }
      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }
      if (navigator.language) {
        found.push(navigator.language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  lookup: function lookup6(options) {
    var found;
    var htmlTag2 = options.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
    if (htmlTag2 && typeof htmlTag2.getAttribute === "function") {
      found = htmlTag2.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  lookup: function lookup7(options) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (language instanceof Array) {
        if (typeof options.lookupFromPathIndex === "number") {
          if (typeof language[options.lookupFromPathIndex] !== "string") {
            return void 0;
          }
          found = language[options.lookupFromPathIndex].replace("/", "");
        } else {
          found = language[0].replace("/", "");
        }
      }
    }
    return found;
  }
};
var subdomain = {
  name: "subdomain",
  lookup: function lookup8(options) {
    var lookupFromSubdomainIndex = typeof options.lookupFromSubdomainIndex === "number" ? options.lookupFromSubdomainIndex + 1 : 1;
    var language = typeof window !== "undefined" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
    if (!language)
      return void 0;
    return language[lookupFromSubdomainIndex];
  }
};
function getDefaults() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"]
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
  };
}
var Browser = /* @__PURE__ */ function() {
  function Browser2(services) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Browser2);
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options);
  }
  _createClass(Browser2, [{
    key: "init",
    value: function init3(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services || {
        languageUtils: {}
      };
      this.options = defaults(options, this.options || {}, getDefaults());
      if (this.options.lookupFromUrlIndex)
        this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
      this.i18nOptions = i18nOptions;
      this.addDetector(cookie$1);
      this.addDetector(querystring);
      this.addDetector(localStorage2);
      this.addDetector(sessionStorage);
      this.addDetector(navigator$1);
      this.addDetector(htmlTag);
      this.addDetector(path);
      this.addDetector(subdomain);
    }
  }, {
    key: "addDetector",
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: "detect",
    value: function detect(detectionOrder) {
      var _this = this;
      if (!detectionOrder)
        detectionOrder = this.options.order;
      var detected = [];
      detectionOrder.forEach(function(detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup9 = _this.detectors[detectorName].lookup(_this.options);
          if (lookup9 && typeof lookup9 === "string")
            lookup9 = [lookup9];
          if (lookup9)
            detected = detected.concat(lookup9);
        }
      });
      if (this.services.languageUtils.getBestMatchFromCodes)
        return detected;
      return detected.length > 0 ? detected[0] : null;
    }
  }, {
    key: "cacheUserLanguage",
    value: function cacheUserLanguage4(lng, caches) {
      var _this2 = this;
      if (!caches)
        caches = this.options.caches;
      if (!caches)
        return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1)
        return;
      caches.forEach(function(cacheName) {
        if (_this2.detectors[cacheName])
          _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }]);
  return Browser2;
}();
Browser.type = "languageDetector";

// ../../../node_modules/react-i18next/dist/es/Trans.js
var import_defineProperty4 = __toESM(require_defineProperty(), 1);
var import_objectWithoutProperties2 = __toESM(require_objectWithoutProperties(), 1);
var import_react3 = __toESM(require_react(), 1);

// ../../../node_modules/react-i18next/dist/es/TransWithoutContext.js
var import_objectWithoutProperties = __toESM(require_objectWithoutProperties(), 1);
var import_typeof3 = __toESM(require_typeof(), 1);
var import_defineProperty2 = __toESM(require_defineProperty(), 1);
var import_react = __toESM(require_react(), 1);
var import_html_parse_stringify = __toESM(require_html_parse_stringify(), 1);

// ../../../node_modules/react-i18next/dist/es/defaults.js
var import_defineProperty = __toESM(require_defineProperty(), 1);

// ../../../node_modules/react-i18next/dist/es/context.js
var import_defineProperty3 = __toESM(require_defineProperty(), 1);
var import_classCallCheck2 = __toESM(require_classCallCheck(), 1);
var import_createClass2 = __toESM(require_createClass(), 1);
var import_react2 = __toESM(require_react(), 1);
var I18nContext = (0, import_react2.createContext)();
var ReportNamespaces = function() {
  function ReportNamespaces2() {
    (0, import_classCallCheck2.default)(this, ReportNamespaces2);
    this.usedNamespaces = {};
  }
  (0, import_createClass2.default)(ReportNamespaces2, [{
    key: "addUsedNamespaces",
    value: function addUsedNamespaces(namespaces) {
      var _this = this;
      namespaces.forEach(function(ns) {
        if (!_this.usedNamespaces[ns])
          _this.usedNamespaces[ns] = true;
      });
    }
  }, {
    key: "getUsedNamespaces",
    value: function getUsedNamespaces() {
      return Object.keys(this.usedNamespaces);
    }
  }]);
  return ReportNamespaces2;
}();

// ../../../node_modules/react-i18next/dist/es/useTranslation.js
var import_slicedToArray = __toESM(require_slicedToArray(), 1);
var import_defineProperty5 = __toESM(require_defineProperty(), 1);
var import_typeof4 = __toESM(require_typeof(), 1);
var import_react4 = __toESM(require_react(), 1);

// ../../../node_modules/react-i18next/dist/es/withTranslation.js
var import_defineProperty6 = __toESM(require_defineProperty(), 1);
var import_slicedToArray2 = __toESM(require_slicedToArray(), 1);
var import_objectWithoutProperties3 = __toESM(require_objectWithoutProperties(), 1);
var import_react5 = __toESM(require_react(), 1);

// ../../../node_modules/react-i18next/dist/es/Translation.js
var import_slicedToArray3 = __toESM(require_slicedToArray(), 1);
var import_objectWithoutProperties4 = __toESM(require_objectWithoutProperties(), 1);

// ../../../node_modules/react-i18next/dist/es/I18nextProvider.js
var import_react6 = __toESM(require_react(), 1);

// ../../../node_modules/react-i18next/dist/es/withSSR.js
var import_defineProperty7 = __toESM(require_defineProperty(), 1);
var import_objectWithoutProperties5 = __toESM(require_objectWithoutProperties(), 1);
var import_react8 = __toESM(require_react(), 1);

// ../../../node_modules/react-i18next/dist/es/useSSR.js
var import_react7 = __toESM(require_react(), 1);

// ../../utils/lib/helpers/paperwork/validation.ts
var Yup = __toESM(require_yup(), 1);

// ../../utils/lib/helpers/states.ts
var AllStatesValues = AllStates.map(({ value }) => value);

// ../../utils/lib/helpers/visit-note/create-vitals-search-config.helper.ts
var createVitalsSearchConfig = (vitalFieldName, searchBy) => {
  return {
    fieldName: "vitalsObservations",
    vitalFiledName: vitalFieldName,
    searchParams: {
      _search_by: searchBy,
      _include: "Observation:performer",
      _sort: "-_lastUpdated",
      _count: 100,
      _tag: {
        type: "token",
        value: `${PRIVATE_EXTENSION_BASE_URL}/${PATIENT_VITALS_META_SYSTEM}|${vitalFieldName}`
      }
    }
  };
};

// ../../utils/lib/helpers/visit-note/progress-note-chart-data-requested-fields.helper.ts
var progressNoteChartDataRequestedFields = {
  episodeOfCare: {},
  prescribedMedications: {},
  notes: {
    _sort: "-_lastUpdated",
    _count: 1e3,
    _tag: {
      type: "token",
      value: `${PRIVATE_EXTENSION_BASE_URL}/${"screening" /* SCREENING */}|${CSS_NOTE_ID},${PRIVATE_EXTENSION_BASE_URL}/${"vitals" /* VITALS */}|${CSS_NOTE_ID},${PRIVATE_EXTENSION_BASE_URL}/${"intake" /* INTAKE */}|${CSS_NOTE_ID}`
    }
  },
  vitalsObservations: {
    _search_by: "encounter",
    _sort: "-_lastUpdated",
    _count: 100,
    _tag: {
      type: "token",
      value: Object.values(VitalFieldNames).map(
        (name) => createVitalsSearchConfig(name, "encounter").searchParams._tag.value
      ).join(",")
    }
  }
};

// ../../utils/lib/utils/pdf.ts
var import_pdf_lib = __toESM(require_cjs(), 1);

// ../../utils/lib/utils/scheduleUtils.ts
function getScheduleDetails(scheduleResource) {
  console.log(
    `extracting schedule and possible overrides from extention on ${scheduleResource.resourceType}`,
    scheduleResource.id
  );
  const scheduleExtension = scheduleResource?.extension?.find(function(extensionTemp) {
    return extensionTemp.url === "https://fhir.zapehr.com/r4/StructureDefinitions/schedule";
  })?.valueString;
  if (!scheduleExtension)
    return void 0;
  const { schedule, scheduleOverrides, closures } = JSON.parse(scheduleExtension);
  return { schedule, scheduleOverrides, closures };
}

// ../../utils/lib/fhir/patient.ts
function getPatientFirstName(patient) {
  return getFirstName(patient);
}
function getFirstName(individual) {
  return individual.name?.[0]?.given?.[0];
}
function getPatientContactEmail(patient) {
  const formUser = patient.extension?.find((ext) => ext.url === `${PRIVATE_EXTENSION_BASE_URL}/form-user`)?.valueString;
  if (formUser === "Parent/Guardian") {
    return patient.contact?.find(
      (contactTemp) => contactTemp.relationship?.find(
        (relationshipTemp) => relationshipTemp.coding?.find(
          (codingTemp) => codingTemp.system === `${PRIVATE_EXTENSION_BASE_URL}/relationship`
        )
      )
    )?.telecom?.find((telecomTemp) => telecomTemp.system === "email")?.value;
  } else {
    return patient.telecom?.find((telecomTemp) => telecomTemp.system === "email")?.value;
  }
}

// ../../utils/lib/fhir/exam-observations.ts
var ExamObservationFieldsDetails = {
  // >>> CARD = general
  // >> GROUP = normal
  alert: { field: "alert", defaultValue: true, abnormal: false, group: "normal", card: "general", label: "Alert" },
  awake: { field: "awake", defaultValue: true, abnormal: false, group: "normal", card: "general", label: "Awake" },
  calm: { field: "calm", defaultValue: true, abnormal: false, group: "normal", card: "general", label: "Calm" },
  "well-hydrated": {
    field: "well-hydrated",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "general",
    label: "Well hydrated"
  },
  "moist-mucous-membrane": {
    field: "moist-mucous-membrane",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "general",
    label: "MMM (Moist Mucous Membrane)"
  },
  "distress-none": {
    field: "distress-none",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "general",
    label: "No distress"
  },
  "playful-and-active": {
    field: "playful-and-active",
    defaultValue: false,
    abnormal: false,
    group: "normal",
    card: "general",
    label: "Playful and active"
  },
  // >> GROUP = abnormal
  "tired-appearing": {
    field: "tired-appearing",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "general",
    label: "Tired-appearing"
  },
  "ill-appearing": {
    field: "ill-appearing",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "general",
    label: "Ill-appearing"
  },
  fussy: { field: "fussy", defaultValue: false, abnormal: true, group: "abnormal", card: "general", label: "Fussy" },
  "dry-mucous-membranes": {
    field: "dry-mucous-membranes",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "general",
    label: "Dry mucous membranes"
  },
  "sunken-eye": {
    field: "sunken-eye",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "general",
    label: "Sunken eyes"
  },
  "mild-distress": {
    field: "mild-distress",
    defaultValue: false,
    abnormal: true,
    group: "dropdown",
    card: "general",
    label: "Mild"
  },
  "moderate-distress": {
    field: "moderate-distress",
    defaultValue: false,
    abnormal: true,
    group: "dropdown",
    card: "general",
    label: "Moderate"
  },
  "severe-distress": {
    field: "severe-distress",
    defaultValue: false,
    abnormal: true,
    group: "dropdown",
    card: "general",
    label: "Severe"
  },
  // >>> CARD = head
  // >> GROUP = normal
  normocephaly: {
    field: "normocephaly",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "head",
    label: "Normocephaly"
  },
  atraumatic: {
    field: "atraumatic",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "head",
    label: "Atraumatic"
  },
  // >>> CARD = eyes
  // >> GROUP = normal
  "pupils-symmetric": {
    field: "pupils-symmetric",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "eyes",
    label: "Pupils symmetric"
  },
  eomi: {
    field: "eomi",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "eyes",
    label: "EOMI (Extra Ocular Movements Intact)"
  },
  // >> GROUP = abnormal
  "pupils-asymmetric": {
    field: "pupils-asymmetric",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "eyes",
    label: "Pupils asymmetric"
  },
  // >> GROUP = rightEye
  "right-eye-normal": {
    field: "right-eye-normal",
    defaultValue: true,
    abnormal: false,
    group: "rightEye",
    card: "eyes",
    label: "Normal"
  },
  "right-eye-injected": {
    field: "right-eye-injected",
    defaultValue: false,
    abnormal: true,
    group: "rightEye",
    card: "eyes",
    label: "Injected"
  },
  "right-eye-discharge": {
    field: "right-eye-discharge",
    defaultValue: false,
    abnormal: true,
    group: "rightEye",
    card: "eyes",
    label: "Discharge"
  },
  "right-eye-watering": {
    field: "right-eye-watering",
    defaultValue: false,
    abnormal: true,
    group: "rightEye",
    card: "eyes",
    label: "Watering"
  },
  "right-eye-puffy-eyelids": {
    field: "right-eye-puffy-eyelids",
    defaultValue: false,
    abnormal: true,
    group: "rightEye",
    card: "eyes",
    label: "Puffy eyelids"
  },
  "right-eye-small-round-mass-in-eyelid": {
    field: "right-eye-small-round-mass-in-eyelid",
    defaultValue: false,
    abnormal: true,
    group: "rightEye",
    card: "eyes",
    label: "Small round mass in eyelid"
  },
  // >> GROUP = leftEye
  "left-eye-normal": {
    field: "left-eye-normal",
    defaultValue: true,
    abnormal: false,
    group: "leftEye",
    card: "eyes",
    label: "Normal"
  },
  "left-eye-injected": {
    field: "left-eye-injected",
    defaultValue: false,
    abnormal: true,
    group: "leftEye",
    card: "eyes",
    label: "Injected"
  },
  "left-eye-discharge": {
    field: "left-eye-discharge",
    defaultValue: false,
    abnormal: true,
    group: "leftEye",
    card: "eyes",
    label: "Discharge"
  },
  "left-eye-watering": {
    field: "left-eye-watering",
    defaultValue: false,
    abnormal: true,
    group: "leftEye",
    card: "eyes",
    label: "Watering"
  },
  "left-eye-puffy-eyelids": {
    field: "left-eye-puffy-eyelids",
    defaultValue: false,
    abnormal: true,
    group: "leftEye",
    card: "eyes",
    label: "Puffy eyelids"
  },
  "left-eye-small-round-mass-in-eyelid": {
    field: "left-eye-small-round-mass-in-eyelid",
    defaultValue: false,
    abnormal: true,
    group: "leftEye",
    card: "eyes",
    label: "Small round mass in eyelid"
  },
  // >>> CARD = nose
  // >> GROUP = normal
  "no-drainage": {
    field: "no-drainage",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "nose",
    label: "No drainage"
  },
  // >> GROUP = abnormal
  "clear-rhinorrhea": {
    field: "clear-rhinorrhea",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "nose",
    label: "Clear rhinorrhea"
  },
  "purulent-discharge": {
    field: "purulent-discharge",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "nose",
    label: "Purulent discharge"
  },
  // >>> CARD = ears
  // >> GROUP = rightEar
  "normal-ear-right": {
    field: "normal-ear-right",
    defaultValue: true,
    abnormal: false,
    group: "rightEar",
    card: "ears",
    label: "Normal"
  },
  "erythema-ear-right": {
    field: "erythema-ear-right",
    defaultValue: false,
    abnormal: true,
    group: "rightEar",
    card: "ears",
    label: "Erythema"
  },
  "swelling-ear-right": {
    field: "swelling-ear-right",
    defaultValue: false,
    abnormal: true,
    group: "rightEar",
    card: "ears",
    label: "Swelling"
  },
  "pain-with-movement-of-pinna-ear-right": {
    field: "pain-with-movement-of-pinna-ear-right",
    defaultValue: false,
    abnormal: true,
    group: "rightEar",
    card: "ears",
    label: "Pain with movement of pinna"
  },
  "drainage-from-ear-canal-right": {
    field: "drainage-from-ear-canal-right",
    defaultValue: false,
    abnormal: true,
    group: "rightEar",
    card: "ears",
    label: "Drainage from ear canal"
  },
  "clear-discharge-ear-right": {
    field: "clear-discharge-ear-right",
    defaultValue: false,
    abnormal: true,
    group: "rightEar",
    card: "ears",
    label: "Clear discharge"
  },
  // >> GROUP = leftEar
  "normal-ear-left": {
    field: "normal-ear-left",
    defaultValue: true,
    abnormal: false,
    group: "leftEar",
    card: "ears",
    label: "Normal"
  },
  "erythema-ear-left": {
    field: "erythema-ear-left",
    defaultValue: false,
    abnormal: true,
    group: "leftEar",
    card: "ears",
    label: "Erythema"
  },
  "swelling-ear-left": {
    field: "swelling-ear-left",
    defaultValue: false,
    abnormal: true,
    group: "leftEar",
    card: "ears",
    label: "Swelling"
  },
  "pain-with-movement-of-pinna-ear-left": {
    field: "pain-with-movement-of-pinna-ear-left",
    defaultValue: false,
    abnormal: true,
    group: "leftEar",
    card: "ears",
    label: "Pain with movement of pinna"
  },
  "drainage-from-ear-canal-left": {
    field: "drainage-from-ear-canal-left",
    defaultValue: false,
    abnormal: true,
    group: "leftEar",
    card: "ears",
    label: "Drainage from ear canal"
  },
  "clear-discharge-ear-left": {
    field: "clear-discharge-ear-left",
    defaultValue: false,
    abnormal: true,
    group: "leftEar",
    card: "ears",
    label: "Clear discharge"
  },
  // >>> CARD = mouth
  // >> GROUP = normal
  "mouth-normal": {
    field: "mouth-normal",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "mouth",
    label: "No visible abnormalities"
  },
  "mouth-moist-mucous-membrane": {
    field: "mouth-moist-mucous-membrane",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "mouth",
    label: "MMM (Moist Mucous Membrane)"
  },
  "oropharynx-clear": {
    field: "oropharynx-clear",
    defaultValue: false,
    abnormal: false,
    group: "normal",
    card: "mouth",
    label: "Oropharynx clear with no erythema, no lesions or exudate"
  },
  "uvula-midline": {
    field: "uvula-midline",
    defaultValue: false,
    abnormal: false,
    group: "normal",
    card: "mouth",
    label: "Uvula midline"
  },
  "tonsils-symmetric-and-not-enlarged": {
    field: "tonsils-symmetric-and-not-enlarged",
    defaultValue: false,
    abnormal: false,
    group: "normal",
    card: "mouth",
    label: "Tonsils symmetric and not enlarged"
  },
  "normal-voice": {
    field: "normal-voice",
    defaultValue: false,
    abnormal: false,
    group: "normal",
    card: "mouth",
    label: "Normal voice"
  },
  // >> GROUP = abnormal
  "mouth-dry-mucous-membranes": {
    field: "mouth-dry-mucous-membranes",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "mouth",
    label: "Dry mucous membranes"
  },
  "erythema-of-pharynx": {
    field: "erythema-of-pharynx",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "mouth",
    label: "Erythema of pharynx"
  },
  "white-patches-on-tongue-andor-buccal-mucosa-that-do-not-wipe-off": {
    field: "white-patches-on-tongue-andor-buccal-mucosa-that-do-not-wipe-off",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "mouth",
    label: "White patches on tongue and/or buccal mucosa that do not wipe off"
  },
  "strawberry-tongue": {
    field: "strawberry-tongue",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "mouth",
    label: "Strawberry tongue"
  },
  "uvula-deviated": {
    field: "uvula-deviated",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "mouth",
    label: "Uvula deviated"
  },
  "tonsils-erythematous": {
    field: "tonsils-erythematous",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "mouth",
    label: "Tonsils erythematous"
  },
  "exudate-on-tonsils": {
    field: "exudate-on-tonsils",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "mouth",
    label: "Exudate on tonsils"
  },
  "hoarse-voice": {
    field: "hoarse-voice",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "mouth",
    label: "Hoarse voice"
  },
  "hot-potato-voice": {
    field: "hot-potato-voice",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "mouth",
    label: "Hot potato voice"
  },
  // >>> CARD = neck
  // >> GROUP = normal
  "supple-neck": {
    field: "supple-neck",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "neck",
    label: "Supple"
  },
  "moves-in-all-directions": {
    field: "moves-in-all-directions",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "neck",
    label: "Moves in all directions"
  },
  // >>> CARD = chest
  // >> GROUP = normal
  "normal-respiratory-effort": {
    field: "normal-respiratory-effort",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "chest",
    label: "Normal respiratory effort"
  },
  "no-tachypnea": {
    field: "no-tachypnea",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "chest",
    label: "No tachypnea"
  },
  "no-retractions": {
    field: "no-retractions",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "chest",
    label: "No retractions"
  },
  "no-conversational-dyspnea": {
    field: "no-conversational-dyspnea",
    defaultValue: false,
    abnormal: false,
    group: "normal",
    card: "chest",
    label: "No conversational dyspnea"
  },
  // >> GROUP = abnormal
  tachypnea: {
    field: "tachypnea",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "chest",
    label: "Tachypnea"
  },
  "suprasternal-retractions": {
    field: "suprasternal-retractions",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "chest",
    label: "Suprasternal retractions"
  },
  "intercostal-retractions": {
    field: "intercostal-retractions",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "chest",
    label: "Intercostal retractions"
  },
  "subcostal-retractions": {
    field: "subcostal-retractions",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "chest",
    label: "Subcostal retractions"
  },
  "abdominal-breathing": {
    field: "abdominal-breathing",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "chest",
    label: "Abdominal breathing"
  },
  grunting: {
    field: "grunting",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "chest",
    label: "Grunting"
  },
  "nasal-flaring": {
    field: "nasal-flaring",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "chest",
    label: "Nasal flaring"
  },
  wheeze: {
    field: "wheeze",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "chest",
    label: "Audible wheeze"
  },
  "barky-cough": {
    field: "barky-cough",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "chest",
    label: "Barky cough"
  },
  "stridor-with-each-breath": {
    field: "stridor-with-each-breath",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "chest",
    label: "Stridor with each breath"
  },
  // >>> CARD = back
  // >> GROUP = normal
  "back-normal": {
    field: "back-normal",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "back",
    label: "Normal"
  },
  "able-to-flex-and-extend-back-and-move-side-to-side": {
    field: "able-to-flex-and-extend-back-and-move-side-to-side",
    defaultValue: false,
    abnormal: false,
    group: "normal",
    card: "back",
    label: "Able to flex and extend back and twist side to side"
  },
  // >> GROUP = abnormal
  "cva-tenderness": {
    field: "cva-tenderness",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "back",
    label: "CVA tenderness"
  },
  // >>> CARD = skin
  // >> GROUP = normal
  "no-rashes": {
    field: "no-rashes",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "skin",
    label: "No rashes"
  },
  // >> GROUP = form
  "consistent-with-viral-exam": {
    field: "consistent-with-viral-exam",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with viral exam"
  },
  "consistent-with-insect-bites": {
    field: "consistent-with-insect-bites",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with insect bites"
  },
  "consistent-with-urticaria": {
    field: "consistent-with-urticaria",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with urticaria"
  },
  "consistent-with-coxsackievirus": {
    field: "consistent-with-coxsackievirus",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with Coxsackievirus"
  },
  "consistent-with-irritant-diaper-rash": {
    field: "consistent-with-irritant-diaper-rash",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with irritant diaper rash"
  },
  "consistent-with-ringworm": {
    field: "consistent-with-ringworm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with ringworm"
  },
  "consistent-with-impetigo": {
    field: "consistent-with-impetigo",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with impetigo"
  },
  "consistent-with-fifths-disease": {
    field: "consistent-with-fifths-disease",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with Fifth's disease"
  },
  "consistent-with-atopic-dermatitis": {
    field: "consistent-with-atopic-dermatitis",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with atopic dermatitis"
  },
  "consistent-with-paronychia": {
    field: "consistent-with-paronychia",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with paronychia"
  },
  "consistent-with-poison-ivy-contact-dermatitis": {
    field: "consistent-with-poison-ivy-contact-dermatitis",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with poison ivy contact dermatitis"
  },
  "consistent-with-tinea-capitis": {
    field: "consistent-with-tinea-capitis",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with tinea capitis"
  },
  "consistent-with-pityriasis-rosea": {
    field: "consistent-with-pityriasis-rosea",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with pityriasis rosea"
  },
  "consistent-with-lyme-ecm": {
    field: "consistent-with-lyme-ecm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "skin",
    label: "consistent with Lyme ECM"
  },
  // >>> CARD = abdomen
  // >> GROUP = normal
  "normal-appearing-on-parental-exam": {
    field: "normal-appearing-on-parental-exam",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "abdomen",
    label: "Normal appearing on parental exam"
  },
  "non-tender-on-parental-exam": {
    field: "non-tender-on-parental-exam",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "abdomen",
    label: "Non-tender on parental exam"
  },
  "able-to-jump-up-down-without-abdominal-pain": {
    field: "able-to-jump-up-down-without-abdominal-pain",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "abdomen",
    label: "Able to jump up/down without abdominal pain"
  },
  // >> GROUP = abnormal
  "left-lower-quadrant-abdomen": {
    field: "left-lower-quadrant-abdomen",
    defaultValue: false,
    abnormal: true,
    group: "dropdown",
    card: "abdomen",
    label: "Left Lower Quadrant - Abdomen"
  },
  "right-lower-quadrant-abdomen": {
    field: "right-lower-quadrant-abdomen",
    defaultValue: false,
    abnormal: true,
    group: "dropdown",
    card: "abdomen",
    label: "Right Lower Quadrant - Abdomen"
  },
  "right-upper-quadrant-abdomen": {
    field: "right-upper-quadrant-abdomen",
    defaultValue: false,
    abnormal: true,
    group: "dropdown",
    card: "abdomen",
    label: "Right Upper Quadrant - Abdomen"
  },
  "left-upper-quadrant-abdomen": {
    field: "left-upper-quadrant-abdomen",
    defaultValue: false,
    abnormal: true,
    group: "dropdown",
    card: "abdomen",
    label: "Left Upper Quadrant - Abdomen"
  },
  "epigastric-region-abdomen": {
    field: "epigastric-region-abdomen",
    defaultValue: false,
    abnormal: true,
    group: "dropdown",
    card: "abdomen",
    label: "Epigastric Region - Abdomen"
  },
  "left-abdominal-lumbar-region-abdomen": {
    field: "left-abdominal-lumbar-region-abdomen",
    defaultValue: false,
    abnormal: true,
    group: "dropdown",
    card: "abdomen",
    label: "Left Abdominal Lumbar Region - Abdomen"
  },
  "right-abdominal-lumbar-region-abdomen": {
    field: "right-abdominal-lumbar-region-abdomen",
    defaultValue: false,
    abnormal: true,
    group: "dropdown",
    card: "abdomen",
    label: "Right Abdominal Lumbar Region - Abdomen"
  },
  "not-able-to-jump-up-down-due-to-abdominal-pain": {
    field: "not-able-to-jump-up-down-due-to-abdominal-pain",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "abdomen",
    label: "Not able to jump up/down due to abdominal pain"
  },
  // >>> CARD = musculoskeletal
  // >> GROUP = normal
  "moving-extemities-equally": {
    field: "moving-extemities-equally",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "musculoskeletal",
    label: "Moving extemities equally"
  },
  "normal-gait": {
    field: "normal-gait",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "musculoskeletal",
    label: "Normal gait"
  },
  "normal-rom": {
    field: "normal-rom",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "musculoskeletal",
    label: "Normal ROM"
  },
  "no-swelling": {
    field: "no-swelling",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "musculoskeletal",
    label: "No swelling"
  },
  "no-bruising": {
    field: "no-bruising",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "musculoskeletal",
    label: "No bruising"
  },
  "no-deformity": {
    field: "no-deformity",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "musculoskeletal",
    label: "No deformity"
  },
  // >> GROUP = form
  "swelling-left-finger-index": {
    field: "swelling-left-finger-index",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-finger-index": {
    field: "swelling-right-finger-index",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-finger-middle": {
    field: "swelling-left-finger-middle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-finger-middle": {
    field: "swelling-right-finger-middle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-finger-ring": {
    field: "swelling-left-finger-ring",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-finger-ring": {
    field: "swelling-right-finger-ring",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-finger-little": {
    field: "swelling-left-finger-little",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-finger-little": {
    field: "swelling-right-finger-little",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-finger-thumb": {
    field: "swelling-left-finger-thumb",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-finger-thumb": {
    field: "swelling-right-finger-thumb",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-hand": {
    field: "swelling-left-hand",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-hand": {
    field: "swelling-right-hand",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-foot": {
    field: "swelling-left-foot",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-foot": {
    field: "swelling-right-foot",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-toe-great": {
    field: "swelling-left-toe-great",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-toe-great": {
    field: "swelling-right-toe-great",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-toe-second": {
    field: "swelling-left-toe-second",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-toe-second": {
    field: "swelling-right-toe-second",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-toe-third": {
    field: "swelling-left-toe-third",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-toe-third": {
    field: "swelling-right-toe-third",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-toe-fourth": {
    field: "swelling-left-toe-fourth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-toe-fourth": {
    field: "swelling-right-toe-fourth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-toe-fifth": {
    field: "swelling-left-toe-fifth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-toe-fifth": {
    field: "swelling-right-toe-fifth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-wrist": {
    field: "swelling-left-wrist",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-wrist": {
    field: "swelling-right-wrist",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-forearm": {
    field: "swelling-left-forearm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-forearm": {
    field: "swelling-right-forearm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-elbow": {
    field: "swelling-left-elbow",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-elbow": {
    field: "swelling-right-elbow",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-upperarm": {
    field: "swelling-left-upperarm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-upperarm": {
    field: "swelling-right-upperarm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-shoulder": {
    field: "swelling-left-shoulder",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-shoulder": {
    field: "swelling-right-shoulder",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-knee": {
    field: "swelling-left-knee",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-knee": {
    field: "swelling-right-knee",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-lowerleg": {
    field: "swelling-left-lowerleg",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-lowerleg": {
    field: "swelling-right-lowerleg",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-left-ankle": {
    field: "swelling-left-ankle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "swelling-right-ankle": {
    field: "swelling-right-ankle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-finger-index": {
    field: "deformity-left-finger-index",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-finger-index": {
    field: "deformity-right-finger-index",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-finger-middle": {
    field: "deformity-left-finger-middle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-finger-middle": {
    field: "deformity-right-finger-middle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-finger-ring": {
    field: "deformity-left-finger-ring",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-finger-ring": {
    field: "deformity-right-finger-ring",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-finger-little": {
    field: "deformity-left-finger-little",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-finger-little": {
    field: "deformity-right-finger-little",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-finger-thumb": {
    field: "deformity-left-finger-thumb",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-finger-thumb": {
    field: "deformity-right-finger-thumb",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-hand": {
    field: "deformity-left-hand",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-hand": {
    field: "deformity-right-hand",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-foot": {
    field: "deformity-left-foot",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-foot": {
    field: "deformity-right-foot",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-toe-great": {
    field: "deformity-left-toe-great",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-toe-great": {
    field: "deformity-right-toe-great",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-toe-second": {
    field: "deformity-left-toe-second",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-toe-second": {
    field: "deformity-right-toe-second",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-toe-third": {
    field: "deformity-left-toe-third",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-toe-third": {
    field: "deformity-right-toe-third",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-toe-fourth": {
    field: "deformity-left-toe-fourth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-toe-fourth": {
    field: "deformity-right-toe-fourth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-toe-fifth": {
    field: "deformity-left-toe-fifth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-toe-fifth": {
    field: "deformity-right-toe-fifth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-wrist": {
    field: "deformity-left-wrist",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-wrist": {
    field: "deformity-right-wrist",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-forearm": {
    field: "deformity-left-forearm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-forearm": {
    field: "deformity-right-forearm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-elbow": {
    field: "deformity-left-elbow",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-elbow": {
    field: "deformity-right-elbow",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-upperarm": {
    field: "deformity-left-upperarm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-upperarm": {
    field: "deformity-right-upperarm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-shoulder": {
    field: "deformity-left-shoulder",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-shoulder": {
    field: "deformity-right-shoulder",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-knee": {
    field: "deformity-left-knee",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-knee": {
    field: "deformity-right-knee",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-lowerleg": {
    field: "deformity-left-lowerleg",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-lowerleg": {
    field: "deformity-right-lowerleg",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-left-ankle": {
    field: "deformity-left-ankle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "deformity-right-ankle": {
    field: "deformity-right-ankle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-finger-index": {
    field: "bruising-left-finger-index",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-finger-index": {
    field: "bruising-right-finger-index",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-finger-middle": {
    field: "bruising-left-finger-middle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-finger-middle": {
    field: "bruising-right-finger-middle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-finger-ring": {
    field: "bruising-left-finger-ring",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-finger-ring": {
    field: "bruising-right-finger-ring",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-finger-little": {
    field: "bruising-left-finger-little",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-finger-little": {
    field: "bruising-right-finger-little",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-finger-thumb": {
    field: "bruising-left-finger-thumb",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-finger-thumb": {
    field: "bruising-right-finger-thumb",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-hand": {
    field: "bruising-left-hand",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-hand": {
    field: "bruising-right-hand",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-foot": {
    field: "bruising-left-foot",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-foot": {
    field: "bruising-right-foot",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-toe-great": {
    field: "bruising-left-toe-great",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-toe-great": {
    field: "bruising-right-toe-great",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-toe-second": {
    field: "bruising-left-toe-second",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-toe-second": {
    field: "bruising-right-toe-second",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-toe-third": {
    field: "bruising-left-toe-third",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-toe-third": {
    field: "bruising-right-toe-third",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-toe-fourth": {
    field: "bruising-left-toe-fourth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-toe-fourth": {
    field: "bruising-right-toe-fourth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-toe-fifth": {
    field: "bruising-left-toe-fifth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-toe-fifth": {
    field: "bruising-right-toe-fifth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-wrist": {
    field: "bruising-left-wrist",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-wrist": {
    field: "bruising-right-wrist",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-forearm": {
    field: "bruising-left-forearm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-forearm": {
    field: "bruising-right-forearm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-elbow": {
    field: "bruising-left-elbow",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-elbow": {
    field: "bruising-right-elbow",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-upperarm": {
    field: "bruising-left-upperarm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-upperarm": {
    field: "bruising-right-upperarm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-shoulder": {
    field: "bruising-left-shoulder",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-shoulder": {
    field: "bruising-right-shoulder",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-knee": {
    field: "bruising-left-knee",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-knee": {
    field: "bruising-right-knee",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-lowerleg": {
    field: "bruising-left-lowerleg",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-lowerleg": {
    field: "bruising-right-lowerleg",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-left-ankle": {
    field: "bruising-left-ankle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "bruising-right-ankle": {
    field: "bruising-right-ankle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-finger-index": {
    field: "abletobearweight-left-finger-index",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-finger-index": {
    field: "abletobearweight-right-finger-index",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-finger-middle": {
    field: "abletobearweight-left-finger-middle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-finger-middle": {
    field: "abletobearweight-right-finger-middle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-finger-ring": {
    field: "abletobearweight-left-finger-ring",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-finger-ring": {
    field: "abletobearweight-right-finger-ring",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-finger-little": {
    field: "abletobearweight-left-finger-little",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-finger-little": {
    field: "abletobearweight-right-finger-little",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-finger-thumb": {
    field: "abletobearweight-left-finger-thumb",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-finger-thumb": {
    field: "abletobearweight-right-finger-thumb",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-hand": {
    field: "abletobearweight-left-hand",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-hand": {
    field: "abletobearweight-right-hand",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-foot": {
    field: "abletobearweight-left-foot",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-foot": {
    field: "abletobearweight-right-foot",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-toe-great": {
    field: "abletobearweight-left-toe-great",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-toe-great": {
    field: "abletobearweight-right-toe-great",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-toe-second": {
    field: "abletobearweight-left-toe-second",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-toe-second": {
    field: "abletobearweight-right-toe-second",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-toe-third": {
    field: "abletobearweight-left-toe-third",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-toe-third": {
    field: "abletobearweight-right-toe-third",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-toe-fourth": {
    field: "abletobearweight-left-toe-fourth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-toe-fourth": {
    field: "abletobearweight-right-toe-fourth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-toe-fifth": {
    field: "abletobearweight-left-toe-fifth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-toe-fifth": {
    field: "abletobearweight-right-toe-fifth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-wrist": {
    field: "abletobearweight-left-wrist",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-wrist": {
    field: "abletobearweight-right-wrist",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-forearm": {
    field: "abletobearweight-left-forearm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-forearm": {
    field: "abletobearweight-right-forearm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-elbow": {
    field: "abletobearweight-left-elbow",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-elbow": {
    field: "abletobearweight-right-elbow",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-upperarm": {
    field: "abletobearweight-left-upperarm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-upperarm": {
    field: "abletobearweight-right-upperarm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-shoulder": {
    field: "abletobearweight-left-shoulder",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-shoulder": {
    field: "abletobearweight-right-shoulder",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-knee": {
    field: "abletobearweight-left-knee",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-knee": {
    field: "abletobearweight-right-knee",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-lowerleg": {
    field: "abletobearweight-left-lowerleg",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-lowerleg": {
    field: "abletobearweight-right-lowerleg",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-left-ankle": {
    field: "abletobearweight-left-ankle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "abletobearweight-right-ankle": {
    field: "abletobearweight-right-ankle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-finger-index": {
    field: "decreasedrom-left-finger-index",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-finger-index": {
    field: "decreasedrom-right-finger-index",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-finger-middle": {
    field: "decreasedrom-left-finger-middle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-finger-middle": {
    field: "decreasedrom-right-finger-middle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-finger-ring": {
    field: "decreasedrom-left-finger-ring",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-finger-ring": {
    field: "decreasedrom-right-finger-ring",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-finger-little": {
    field: "decreasedrom-left-finger-little",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-finger-little": {
    field: "decreasedrom-right-finger-little",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-finger-thumb": {
    field: "decreasedrom-left-finger-thumb",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-finger-thumb": {
    field: "decreasedrom-right-finger-thumb",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-hand": {
    field: "decreasedrom-left-hand",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-hand": {
    field: "decreasedrom-right-hand",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-foot": {
    field: "decreasedrom-left-foot",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-foot": {
    field: "decreasedrom-right-foot",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-toe-great": {
    field: "decreasedrom-left-toe-great",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-toe-great": {
    field: "decreasedrom-right-toe-great",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-toe-second": {
    field: "decreasedrom-left-toe-second",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-toe-second": {
    field: "decreasedrom-right-toe-second",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-toe-third": {
    field: "decreasedrom-left-toe-third",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-toe-third": {
    field: "decreasedrom-right-toe-third",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-toe-fourth": {
    field: "decreasedrom-left-toe-fourth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-toe-fourth": {
    field: "decreasedrom-right-toe-fourth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-toe-fifth": {
    field: "decreasedrom-left-toe-fifth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-toe-fifth": {
    field: "decreasedrom-right-toe-fifth",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-wrist": {
    field: "decreasedrom-left-wrist",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-wrist": {
    field: "decreasedrom-right-wrist",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-forearm": {
    field: "decreasedrom-left-forearm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-forearm": {
    field: "decreasedrom-right-forearm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-elbow": {
    field: "decreasedrom-left-elbow",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-elbow": {
    field: "decreasedrom-right-elbow",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-upperarm": {
    field: "decreasedrom-left-upperarm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-upperarm": {
    field: "decreasedrom-right-upperarm",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-shoulder": {
    field: "decreasedrom-left-shoulder",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-shoulder": {
    field: "decreasedrom-right-shoulder",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-knee": {
    field: "decreasedrom-left-knee",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-knee": {
    field: "decreasedrom-right-knee",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-lowerleg": {
    field: "decreasedrom-left-lowerleg",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-lowerleg": {
    field: "decreasedrom-right-lowerleg",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-left-ankle": {
    field: "decreasedrom-left-ankle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  "decreasedrom-right-ankle": {
    field: "decreasedrom-right-ankle",
    defaultValue: false,
    abnormal: true,
    group: "form",
    card: "musculoskeletal",
    label: ""
  },
  // >>> CARD = neurological
  // >> GROUP = normal
  "normal-mental-status": {
    field: "normal-mental-status",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "neurological",
    label: "Normal mental status"
  },
  // >>> CARD = psych
  // >> GROUP = normal
  "normal-affect": {
    field: "normal-affect",
    defaultValue: false,
    abnormal: false,
    group: "normal",
    card: "psych",
    label: "Normal affect"
  },
  "good-eye-contact": {
    field: "good-eye-contact",
    defaultValue: false,
    abnormal: false,
    group: "normal",
    card: "psych",
    label: "Good eye contact"
  },
  // >> GROUP = abnormal
  "depressed-affect": {
    field: "depressed-affect",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "psych",
    label: "Depressed affect"
  },
  "poor-eye-contact": {
    field: "poor-eye-contact",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "psych",
    label: "Poor eye contact"
  }
};
var InPersonExamObservationFieldsDetails = {
  // >>> CARD = general
  "well-appearing": {
    field: "well-appearing",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "general",
    label: "Well appearing"
  },
  "well-nourished": {
    field: "well-nourished",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "general",
    label: "Well nourished"
  },
  "in-no-distress": {
    field: "in-no-distress",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "general",
    label: "In no distress"
  },
  "oriented-general": {
    field: "oriented-general",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "general",
    label: "Oriented x 3"
  },
  "general-normal-mood-and-affect": {
    field: "general-normal-mood-and-affect",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "general",
    label: "Normal mood and affect"
  },
  "ambulating-without-difficulty": {
    field: "ambulating-without-difficulty",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "general",
    label: "Ambulating without difficulty"
  },
  "abnormal-general": {
    field: "abnormal-general",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "general",
    label: "Abnormal"
  },
  // >>> CARD = skin
  "good-turgor": {
    field: "good-turgor",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "skin",
    label: "Good turgor"
  },
  "no-rash-unusual-bruising-or-prominent-lesions": {
    field: "no-rash-unusual-bruising-or-prominent-lesions",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "skin",
    label: "No rash, unusual bruising or prominent lesions"
  },
  "abnormal-skin": {
    field: "abnormal-skin",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "skin",
    label: "Abnormal"
  },
  // >>> CARD = hair
  "normal-texture-and-distribution": {
    field: "normal-texture-and-distribution",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "hair",
    label: "Normal texture and distribution"
  },
  "abnormal-hair": {
    field: "abnormal-hair",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "hair",
    label: "Abnormal"
  },
  // >>> CARD = nails
  "normal-color-no-deformities": {
    field: "normal-color-no-deformities",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "nails",
    label: "Normal color, no deformities"
  },
  "abnormal-nails": {
    field: "abnormal-nails",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "nails",
    label: "Abnormal"
  },
  // >>> CARD = head
  normocephalic: {
    field: "normocephalic",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "head",
    label: "Normocephalic"
  },
  atraumatic: {
    field: "atraumatic",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "head",
    label: "Atraumatic"
  },
  "no-visible-or-palpable-masses-depressions-or-scaring": {
    field: "no-visible-or-palpable-masses-depressions-or-scaring",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "head",
    label: "No visible or palpable masses, depressions, or scaring"
  },
  "abnormal-head": {
    field: "abnormal-head",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "head",
    label: "Abnormal"
  },
  // >>> CARD = eyes
  "visual-acuity-intact": {
    field: "visual-acuity-intact",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "eyes",
    label: "Visual acuity intact"
  },
  "conjunctiva-clear": {
    field: "conjunctiva-clear",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "eyes",
    label: "Conjunctiva clear"
  },
  "sclera-non-icteric": {
    field: "sclera-non-icteric",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "eyes",
    label: "Sclera non-icteric"
  },
  "eom-intact": {
    field: "eom-intact",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "eyes",
    label: "EOM intact"
  },
  perrl: {
    field: "perrl",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "eyes",
    label: "PERRL"
  },
  "fundi-have-normal-optic-discs-and-vessels": {
    field: "fundi-have-normal-optic-discs-and-vessels",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "eyes",
    label: "Fundi have normal optic discs and vessels"
  },
  "no-exudates-or-hemorrhages": {
    field: "no-exudates-or-hemorrhages",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "eyes",
    label: "No exudates or hemorrhages"
  },
  "abnormal-eyes": {
    field: "abnormal-eyes",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "eyes",
    label: "Abnormal"
  },
  // >>> CARD = ears
  "eacs-clear": {
    field: "eacs-clear",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "ears",
    label: "EACs clear"
  },
  "tms-translucent-mobile": {
    field: "tms-translucent-mobile",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "ears",
    label: "TMs translucent & mobile"
  },
  "ossicles-nl-appearance": {
    field: "ossicles-nl-appearance",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "ears",
    label: "Ossicles nl appearance"
  },
  "hearing-intact": {
    field: "hearing-intact",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "ears",
    label: "Hearing intact"
  },
  "abnormal-ears": {
    field: "abnormal-ears",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "ears",
    label: "Abnormal"
  },
  // >>> CARD = nose
  "no-external-lesions": {
    field: "no-external-lesions",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "nose",
    label: "No external lesions"
  },
  "nose-mucosa-non-inflamed": {
    field: "nose-mucosa-non-inflamed",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "nose",
    label: "Mucosa non-inflamed"
  },
  "septum-and-turbinates-normal": {
    field: "septum-and-turbinates-normal",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "nose",
    label: "Septum and turbinates normal"
  },
  "abnormal-nose": {
    field: "abnormal-nose",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "nose",
    label: "Abnormal"
  },
  // >>> CARD = mouth
  "mucous-membranes-moist": {
    field: "mucous-membranes-moist",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "mouth",
    label: "Mucous membranes moist"
  },
  "no-mucosal-lesions": {
    field: "no-mucosal-lesions",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "mouth",
    label: "No mucosal lesions"
  },
  "abnormal-mouth": {
    field: "abnormal-mouth",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "mouth",
    label: "Abnormal"
  },
  // >>> CARD = teeth
  "no-obvious-caries-or-periodontal-disease": {
    field: "no-obvious-caries-or-periodontal-disease",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "teeth",
    label: "No obvious caries or periodontal disease"
  },
  "no-gingival-inflammation-or-significant-resorption": {
    field: "no-gingival-inflammation-or-significant-resorption",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "teeth",
    label: "No gingival inflammation or significant resorption"
  },
  "abnormal-teeth": {
    field: "abnormal-teeth",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "teeth",
    label: "Abnormal"
  },
  // >>> CARD = pharynx
  "pharynx-mucosa-non-inflamed": {
    field: "pharynx-mucosa-non-inflamed",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "pharynx",
    label: "Mucosa non-inflamed"
  },
  "no-tonsillar-hypertrophy-or-exudate": {
    field: "no-tonsillar-hypertrophy-or-exudate",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "pharynx",
    label: "No tonsillar hypertrophy or exudate"
  },
  "abnormal-pharynx": {
    field: "abnormal-pharynx",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "pharynx",
    label: "Abnormal"
  },
  // >>> CARD = neck
  supple: {
    field: "supple",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "neck",
    label: "Supple"
  },
  "without-lesions-bruits-or-adenopathy": {
    field: "without-lesions-bruits-or-adenopathy",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "neck",
    label: "Without lesions, bruits, or adenopathy"
  },
  "thyroid-non-enlarged-and-non-tender": {
    field: "thyroid-non-enlarged-and-non-tender",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "neck",
    label: "Thyroid non-enlarged and non-tender"
  },
  "abnormal-neck": {
    field: "abnormal-neck",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "neck",
    label: "Abnormal"
  },
  // >>> CARD = heart
  "no-cardiomegaly-or-thrills": {
    field: "no-cardiomegaly-or-thrills",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "heart",
    label: "No cardiomegaly or thrills"
  },
  "regular-rate-and-rhythm": {
    field: "regular-rate-and-rhythm",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "heart",
    label: "Regular rate and rhythm"
  },
  "no-murmur-or-gallop": {
    field: "no-murmur-or-gallop",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "heart",
    label: "No murmur or gallop"
  },
  "abnormal-heart": {
    field: "abnormal-heart",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "heart",
    label: "Abnormal"
  },
  // >>> CARD = lungs
  "clear-to-auscultation-and-percussion": {
    field: "clear-to-auscultation-and-percussion",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "lungs",
    label: "Clear to auscultation and percussion"
  },
  "pulmonary-effort-is-normal": {
    field: "pulmonary-effort-is-normal",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "lungs",
    label: "Pulmonary effort is normal"
  },
  "no-respiratory-distress": {
    field: "no-respiratory-distress",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "lungs",
    label: "No respiratory distress"
  },
  "there-are-no-wheezing": {
    field: "there-are-no-wheezing",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "lungs",
    label: "There are no wheezing"
  },
  "there-are-no-rales": {
    field: "there-are-no-rales",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "lungs",
    label: "There are no rales"
  },
  "abnormal-lungs": {
    field: "abnormal-lungs",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "lungs",
    label: "Abnormal"
  },
  // >>> CARD = abdomen
  "no-bloating": {
    field: "no-bloating",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "abdomen",
    label: "No bloating"
  },
  "bowel-sounds-normal": {
    field: "bowel-sounds-normal",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "abdomen",
    label: "Bowel sounds normal"
  },
  "no-tenderness-organomegaly-masses-or-hernia": {
    field: "no-tenderness-organomegaly-masses-or-hernia",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "abdomen",
    label: "No tenderness, organomegaly, masses, or hernia"
  },
  "abnormal-abdomen": {
    field: "abnormal-abdomen",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "abdomen",
    label: "Abnormal"
  },
  // >>> CARD = back
  "spine-normal-without-deformity-or-tenderness": {
    field: "spine-normal-without-deformity-or-tenderness",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "back",
    label: "Spine normal without deformity or tenderness"
  },
  "no-cva-tenderness": {
    field: "no-cva-tenderness",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "back",
    label: "No CVA tenderness"
  },
  "abnormal-back": {
    field: "abnormal-back",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "back",
    label: "Abnormal"
  },
  // >>> CARD = rectal
  "normal-sphincter-tone": {
    field: "normal-sphincter-tone",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "rectal",
    label: "Normal sphincter tone"
  },
  "no-hemorrhoids-or-masses-palpable": {
    field: "no-hemorrhoids-or-masses-palpable",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "rectal",
    label: "No hemorrhoids or masses palpable"
  },
  "abnormal-rectal": {
    field: "abnormal-rectal",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "rectal",
    label: "Abnormal"
  },
  // >>> CARD = extremities
  "no-amputations-or-deformities-cyanosis-edema-or-varicosities": {
    field: "no-amputations-or-deformities-cyanosis-edema-or-varicosities",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "extremities",
    label: "No amputations or deformities, cyanosis, edema or varicosities"
  },
  "peripheral-pulses-intact": {
    field: "peripheral-pulses-intact",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "extremities",
    label: "Peripheral pulses intact"
  },
  "abnormal-extremities": {
    field: "abnormal-extremities",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "extremities",
    label: "Abnormal"
  },
  // >>> CARD = musculoskeletal
  "normal-gait-and-station": {
    field: "normal-gait-and-station",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "musculoskeletal",
    label: "Normal gait and station"
  },
  "no-misalignment": {
    field: "no-misalignment",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "musculoskeletal",
    label: "No misalignment, asymmetry, crepitation, defects, tenderness, masses, effusions, decreased range of motion, instability, atrophy or abnormal strength or tone in the head, neck, spine, ribs, pelvis or extremities."
  },
  "abnormal-musculoskeletal": {
    field: "abnormal-musculoskeletal",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "musculoskeletal",
    label: "Abnormal"
  },
  // >>> CARD = neurologic
  "mental-status:-the-patient-is-alert": {
    field: "mental-status:-the-patient-is-alert",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "neurologic",
    label: "Mental Status: The patient is alert"
  },
  "cn-2-12-normal": {
    field: "cn-2-12-normal",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "neurologic",
    label: "CN 2-12 normal"
  },
  "sensation-to-pain-touch-and-proprioception-normal": {
    field: "sensation-to-pain-touch-and-proprioception-normal",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "neurologic",
    label: "Sensation to pain, touch, and proprioception normal"
  },
  "dtrs-normal-in-upper-and-lower-extremities": {
    field: "dtrs-normal-in-upper-and-lower-extremities",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "neurologic",
    label: "DTRs normal in upper and lower extremities"
  },
  "no-pathologic-reflexes": {
    field: "no-pathologic-reflexes",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "neurologic",
    label: "No pathologic reflexes"
  },
  "abnormal-neurologic": {
    field: "abnormal-neurologic",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "neurologic",
    label: "Abnormal"
  },
  // >>> CARD = psychiatric
  "oriented-psychiatric": {
    field: "oriented-psychiatric",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "psychiatric",
    label: "Oriented X3"
  },
  "intact-recent-and-remote-memory-judgment-and-insight": {
    field: "intact-recent-and-remote-memory-judgment-and-insight",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "psychiatric",
    label: "Intact recent and remote memory, judgment and insight"
  },
  "psychiatric-normal-mood-and-affect": {
    field: "psychiatric-normal-mood-and-affect",
    defaultValue: true,
    abnormal: false,
    group: "normal",
    card: "psychiatric",
    label: "Normal mood and affect"
  },
  "abnormal-psychiatric": {
    field: "abnormal-psychiatric",
    defaultValue: false,
    abnormal: true,
    group: "abnormal",
    card: "psychiatric",
    label: "Abnormal"
  }
};
var examObservationFieldsDetailsArray = Object.values(ExamObservationFieldsDetails);
var inPersonExamObservationFieldsDetailsArray = Object.values(InPersonExamObservationFieldsDetails);
var rashesFields = examObservationFieldsDetailsArray.filter((details) => details.card === "skin" && details.group === "form").map((details) => details.field);
var rashesOptions = rashesFields.reduce(
  (previousValue, currentValue) => {
    previousValue[currentValue] = ExamObservationFieldsDetails[currentValue].label;
    return previousValue;
  },
  {}
);
var musculoskeletalFields = examObservationFieldsDetailsArray.filter((details) => details.card === "musculoskeletal" && details.group === "form").map((details) => details.field);

// ../../utils/lib/fhir/location.ts
var isLocationVirtual = (location) => {
  return Boolean(
    location.extension?.find((ext) => ext.url === `${PUBLIC_EXTENSION_BASE_URL}/location-form-pre-release`)?.valueCoding?.code === "vi"
  );
};

// ../../utils/lib/fhir/encounter.ts
var FOLLOWUP_SYSTEMS = {
  callerUrl: `${OTTEHR_BASE_URL}/followup-caller`,
  answeredUrl: `${OTTEHR_BASE_URL}/followup-answered`,
  providerUrl: `${OTTEHR_BASE_URL}/followup-provider`,
  messageUrl: `${OTTEHR_BASE_URL}/followup-message`,
  reasonUrl: `${OTTEHR_BASE_URL}/followup-reason`,
  type: {
    url: "http://snomed.info/sct",
    code: "390906007"
    // Follow-up encounter (procedure)
  }
};
var getEncounterForAppointment = async (appointmentID, oystehr) => {
  const encounterTemp = (await oystehr.fhir.search({
    resourceType: "Encounter",
    params: [
      {
        name: "appointment",
        value: `Appointment/${appointmentID}`
      }
    ]
  })).unbundle();
  const encounter = encounterTemp[0];
  if (encounterTemp.length === 0 || !encounter.id) {
    throw new Error("Error getting appointment encounter");
  }
  return encounter;
};

// ../../utils/lib/fhir/patientMasterRecord.ts
var patientFieldPaths = {
  firstName: "Patient/name/0/given/0",
  middleName: "Patient/name/0/given/1",
  lastName: "Patient/name/0/family",
  suffix: "Patient/name/0/suffix/0",
  preferredName: "Patient/name/1/given/0",
  birthDate: "Patient/birthDate",
  preferredPronouns: `Patient/extension/${PATIENT_INDIVIDUAL_PRONOUNS_URL}`,
  preferredPronounsCustom: `Patient/extension/${PATIENT_INDIVIDUAL_PRONOUNS_CUSTOM_URL}`,
  gender: "Patient/gender",
  phone: "Patient/telecom/0/value",
  email: "Patient/telecom/1/value",
  pcpFirstName: "Patient/contained/0/name/0/given/0",
  pcpLastName: "Patient/contained/0/name/0/family",
  pcpPhone: "Patient/contained/0/telecom/0/value",
  pcpStreetAddress: "Patient/contained/0/address/0/line/0",
  practiceName: `Patient/contained/0/extension/${PRACTICE_NAME_URL}`,
  pcpActive: "Patient/contained/0/active",
  streetAddress: "Patient/address/0/line/0",
  streetAddressLine2: "Patient/address/0/line/1",
  city: "Patient/address/0/city",
  state: "Patient/address/0/state",
  zip: "Patient/address/0/postalCode",
  fillingOutAs: `Patient/extension/${PATIENT_FILLING_OUT_AS_URL}`,
  parentGuardianPhone: "Patient/contact/0/telecom/0/value",
  parentGuardianEmail: "Patient/contact/0/telecom/1/value",
  preferredLanguage: "Patient/communication/0",
  race: `Patient/extension/${PATIENT_RACE_URL}`,
  ethnicity: `Patient/extension/${PATIENT_ETHNICITY_URL}`,
  sexualOrientation: `Patient/extension/${PATIENT_SEXUAL_ORIENTATION_URL}`,
  pointOfDiscovery: `Patient/extension/${PATIENT_POINT_OF_DISCOVERY_URL}`,
  sendMarketing: `Patient/extension/${PATIENT_SEND_MARKETING_URL}`,
  hearingImpairedRelayService: `Patient/extension/${PATIENT_HEARING_IMPAIRED_RELAY_SERVICE_URL}`,
  commonWellConsent: `Patient/extension/${PATIENT_COMMON_WELL_CONSENT_URL}`,
  genderIdentity: `Patient/extension/${PATIENT_GENDER_IDENTITY_URL}`,
  genderIdentityDetails: `Patient/extension/${PATIENT_GENDER_IDENTITY_DETAILS_URL}`,
  responsiblePartyRelationship: "Patient/contact/0/relationship/0/coding/0/display",
  responsiblePartyName: "Patient/contact/0/name",
  responsiblePartyFirstName: "Patient/contact/0/name/given/0",
  responsiblePartyLastName: "Patient/contact/0/name/family",
  responsiblePartyGender: "Patient/contact/0/gender",
  responsiblePartyBirthDate: "Patient/contact/0/extension/0/valueString",
  responsiblePartyPhone: "Patient/contact/0/telecom/0/value",
  releaseOfInfo: `Patient/extension/${PATIENT_RELEASE_OF_INFO_URL}`,
  rxHistoryConsentStatus: `Patient/extension/${PATIENT_RX_HISTORY_CONSENT_STATUS_URL}`,
  active: "Patient/active",
  deceased: "Patient/deceasedBoolean",
  deceasedDate: "Patient/deceasedDateTime",
  deceasedNote: `Patient/extension/${PATIENT_DECEASED_NOTE_URL}`
};
var coverageFieldPaths = {
  memberId: "Coverage/identifier/0/value",
  carrier: "Coverage/class/0/name",
  payerId: "Coverage/class/0/value",
  payor: "Coverage/payor/0",
  order: "Coverage/order",
  additionalInformation: `Coverage/extension/${COVERAGE_ADDITIONAL_INFORMATION_URL}`,
  relationship: "Coverage/relationship/coding/0/display",
  status: "Coverage/status"
};
var relatedPersonFieldPaths = {
  firstName: "RelatedPerson/name/0/given/0",
  middleName: "RelatedPerson/name/0/given/1",
  lastName: "RelatedPerson/name/0/family",
  gender: "RelatedPerson/gender",
  streetAddress: "RelatedPerson/address/0/line/0",
  addressLine2: "RelatedPerson/address/0/line/1",
  city: "RelatedPerson/address/0/city",
  state: "RelatedPerson/address/0/state",
  zip: "RelatedPerson/address/0/postalCode",
  relationship: "RelatedPerson/relationship/0/coding/0/display",
  birthDate: "RelatedPerson/birthDate",
  sameAsPatientAddress: `RelatedPerson/extension/${RELATED_PERSON_SAME_AS_PATIENT_ADDRESS_URL}`
};
var PRONOUNS_MAPPING = {
  "He/him": {
    code: "LA29518-0",
    display: "He/Him/His",
    system: "http://loinc.org"
  },
  "She/her": {
    code: "LA29519-8",
    display: "She/Her/Her",
    system: "http://loinc.org"
  },
  "They/them": {
    code: "LA29520-6",
    display: "They/Them/Their",
    system: "http://loinc.org"
  },
  "He/Him/His": {
    code: "LA29518-0",
    display: "He/Him/His",
    system: "http://loinc.org"
  },
  "She/Her/Her": {
    code: "LA29519-8",
    display: "She/Her/Her",
    system: "http://loinc.org"
  },
  "They/Them/Their": {
    code: "LA29520-6",
    display: "They/Them/Their",
    system: "http://loinc.org"
  },
  "My pronouns are not listed": {
    code: "LA29521-4",
    display: "My pronouns are not listed",
    system: "http://loinc.org"
  }
};
var GENDER_IDENTITY_MAPPING = {
  "Female gender identity": {
    code: "446151000124109",
    display: "Female gender identity",
    system: "http://snomed.info/sct"
  },
  "Male gender identity": {
    code: "446141000124107",
    display: "Male gender identity",
    system: "http://snomed.info/sct"
  },
  "Non-binary gender identity": {
    code: "33791000087105",
    display: "Non-binary gender identity",
    system: "http://snomed.info/sct"
  }
};
var SEXUAL_ORIENTATION_MAPPING = {
  Straight: {
    code: "446191000124102",
    display: "Straight",
    system: "http://snomed.info/sct"
  },
  "Gay or Lesbian": {
    code: "446161000124108",
    display: "Gay or Lesbian",
    system: "http://snomed.info/sct"
  },
  Bisexual: {
    code: "446171000124106",
    display: "Bisexual",
    system: "http://snomed.info/sct"
  },
  "Other sexual orientation": {
    code: "446181000124104",
    display: "Other sexual orientation",
    system: "http://snomed.info/sct"
  }
};
var ETHNICITY_MAPPING = {
  "Hispanic or Latino": {
    code: "2135-2",
    display: "Hispanic or Latino",
    system: "http://terminology.hl7.org/CodeSystem/v3-Ethnicity"
  },
  "Not Hispanic or Latino": {
    code: "2186-5",
    display: "Not Hispanic or Latino",
    system: "http://terminology.hl7.org/CodeSystem/v3-Ethnicity"
  },
  "Decline to Specify": {
    code: "ASKU",
    display: "Decline to Specify",
    system: "http://terminology.hl7.org/CodeSystem/v3-NullFlavor"
  }
};
var RACE_MAPPING = {
  "American Indian or Alaska Native": {
    code: "1002-5",
    display: "American Indian or Alaska Native",
    system: "http://terminology.hl7.org/CodeSystem/v3-Race"
  },
  Asian: {
    code: "2028-9",
    display: "Asian",
    system: "http://terminology.hl7.org/CodeSystem/v3-Race"
  },
  "Black or African American": {
    code: "2054-5",
    display: "Black or African American",
    system: "http://terminology.hl7.org/CodeSystem/v3-Race"
  },
  "Native Hawaiian or Other Pacific Islander": {
    code: "2076-8",
    display: "Native Hawaiian or Other Pacific Islander",
    system: "http://terminology.hl7.org/CodeSystem/v3-Race"
  },
  White: {
    code: "2106-3",
    display: "White",
    system: "http://terminology.hl7.org/CodeSystem/v3-Race"
  },
  "Decline to Specify": {
    code: "ASKU",
    display: "Decline to Specify",
    system: "http://terminology.hl7.org/CodeSystem/v3-NullFlavor"
  }
};
var CODEABLE_CONCEPT_MAPPINGS = {
  [PATIENT_INDIVIDUAL_PRONOUNS_URL]: PRONOUNS_MAPPING,
  [PATIENT_GENDER_IDENTITY_URL]: GENDER_IDENTITY_MAPPING,
  [PATIENT_SEXUAL_ORIENTATION_URL]: SEXUAL_ORIENTATION_MAPPING,
  [PATIENT_RACE_URL]: RACE_MAPPING,
  [PATIENT_ETHNICITY_URL]: ETHNICITY_MAPPING
};
var LANGUAGE_OPTIONS = {
  English: "English",
  Spanish: "Spanish"
};
var LANGUAGE_MAPPING = {
  [LANGUAGE_OPTIONS.English]: {
    code: "en",
    display: "English",
    system: "urn:ietf:bcp:47"
  },
  [LANGUAGE_OPTIONS.Spanish]: {
    code: "es",
    display: "Spanish",
    system: "urn:ietf:bcp:47"
  }
};
var RELATIONSHIP_OPTIONS = {
  Self: "Self",
  "Legal Guardian": "Legal Guardian",
  Father: "Father",
  Mother: "Mother",
  Spouse: "Spouse",
  Parent: "Parent",
  Other: "Other"
};
var RELATIONSHIP_MAPPING = {
  [RELATIONSHIP_OPTIONS.Self]: {
    code: "SELF",
    display: "Self",
    system: "http://hl7.org/fhir/relationship"
  },
  [RELATIONSHIP_OPTIONS["Legal Guardian"]]: {
    code: "GUARD",
    display: "Legal Guardian",
    system: "http://hl7.org/fhir/relationship"
  },
  [RELATIONSHIP_OPTIONS.Father]: {
    code: "FTH",
    display: "Father",
    system: "http://hl7.org/fhir/relationship"
  },
  [RELATIONSHIP_OPTIONS.Mother]: {
    code: "MTH",
    display: "Mother",
    system: "http://hl7.org/fhir/relationship"
  },
  [RELATIONSHIP_OPTIONS.Spouse]: {
    code: "SPO",
    display: "Spouse",
    system: "http://hl7.org/fhir/relationship"
  },
  [RELATIONSHIP_OPTIONS.Parent]: {
    code: "PRN",
    display: "Parent",
    system: "http://hl7.org/fhir/relationship"
  },
  [RELATIONSHIP_OPTIONS.Other]: {
    code: "OTH",
    display: "Other",
    system: "http://hl7.org/fhir/relationship"
  }
};

// ../../utils/lib/frontend/hooks/useCookie.ts
var import_react9 = __toESM(require_react(), 1);

// ../../utils/lib/telemed/constants.ts
var ELIGIBILITY_FAILED_REASON_META_TAG = `${"OTTEHR-TM" /* TM */}-eligibility-failed-reason`;
var ELIGIBILITY_PRACTITIONER_META_TAG_PREFIX = `${"OTTEHR-TM" /* TM */}-eligibility-billing-provider`;
var ELIGIBILITY_RELATED_PERSON_META_TAG = `${"OTTEHR-TM" /* TM */}-eligibility-related-person`;
var QRS_TELEMED_COMMON_FIELDS = [
  "patient-street-address",
  "patient-street-address-2",
  "patient-city",
  "patient-state",
  "patient-zip",
  "patient-filling-out-as",
  "patient-number",
  "patient-email",
  "guardian-email",
  "guardian-number",
  "mobile-opt-in",
  "patient-ethnicity",
  "patient-race",
  "patient-pronouns",
  "patient-pronouns-custom",
  "pcp-first",
  "pcp-last",
  "pcp-number",
  // The strings don't match so have to map it before comparison
  "payment-option",
  "insurance-carrier",
  "insurance-member-id",
  "policy-holder-first-name",
  "policy-holder-middle-name",
  "policy-holder-last-name",
  "policy-holder-birth-sex",
  "policy-holder-address",
  "policy-holder-address-as-patient",
  "policy-holder-city",
  "policy-holder-state",
  "policy-holder-zip",
  "patient-relationship-to-insured",
  "insurance-additional-information",
  "insurance-card-front",
  "insurance-card-back",
  "insurance-carrier-2",
  "insurance-member-id-2",
  "policy-holder-first-name-2",
  "policy-holder-middle-name-2",
  "policy-holder-last-name-2",
  "policy-holder-birth-sex-2",
  "policy-holder-address-2",
  "policy-holder-address-as-patient-2",
  "policy-holder-city-2",
  "policy-holder-state-2",
  "policy-holder-zip-2",
  "patient-relationship-to-insured-2",
  "insurance-additional-information-2",
  "insurance-card-front-2",
  "insurance-card-back-2",
  "responsible-party-relationship",
  "responsible-party-first-name",
  "responsible-party-last-name",
  "responsible-party-birth-sex",
  "responsible-party-number",
  "photo-id-front",
  "photo-id-back",
  "hipaa-acknowledgement",
  "consent-to-treat",
  "signature",
  "full-name",
  "consent-form-signer-relationship"
];
var ALL_TELEMED_PAPERWORK_FIELDS = [
  ...QRS_TELEMED_COMMON_FIELDS,
  "patient-point-of-discovery",
  "preferred-language",
  "relay-phone",
  "pcp-practice",
  "pcp-address",
  "current-medications-yes-no",
  "allergies-yes-no",
  "medical-history-yes-no",
  "surgical-history-yes-no",
  "covid-symptoms",
  "tested-positive-covid",
  "travel-usa",
  "credit-card-id",
  "policy-holder-date-of-birth",
  "policy-holder-date-of-birth-2",
  // QRS uses e.g. 'responsible-party-dob-day' etc, so must create
  "responsible-party-date-of-birth",
  "get-ready-for-the-visit-filling-out-as",
  "person-accompanying-minor-first-name",
  "person-accompanying-minor-last-name",
  "person-accompanying-minor-phone-number",
  "contacts-relationship-to-the-patient",
  "reason-for-visit",
  "additional-information",
  "patient-photos",
  "school-work-note-choice",
  "invite-from-another-device"
];

// ../../zambda-utils/lib/lambda/index.ts
var import_mail = __toESM(require_mail3());

// ../../zambda-utils/lib/secrets/index.ts
var getOptionalSecret = (secretKey, secrets) => {
  return secrets != null ? secrets[secretKey] : process.env[secretKey];
};
var getSecret = (secretKey, secrets) => {
  const value = getOptionalSecret(secretKey, secrets);
  if (value == null) {
    throw new Error(`Secret or Environment Variable with key ${secretKey} was not set.`);
  }
  return value;
};

// ../../zambda-utils/lib/lambda/index.ts
var handleErrorResult = (errorResult) => {
  if (isApiError(errorResult)) {
    const { code, message } = errorResult;
    return {
      statusCode: 400,
      // we have 1 case currently so this is good enough for now
      body: JSON.stringify({ message, code })
    };
  } else {
    return {
      statusCode: 500,
      body: JSON.stringify({ error: "Internal error" })
    };
  }
};
async function topLevelCatch(zambda, error, secrets, captureSentryException2) {
  console.error(`Top level catch block in ${zambda}: 
 ${error} 
 Error stringified: ${JSON.stringify(error)}`);
  if (isApiError(error)) {
    console.error("Top level catch block returning silently");
  } else {
    await sendErrors(zambda, error, secrets, captureSentryException2);
  }
  return handleErrorResult(error);
}
var sendErrors = async (zambda, error, secrets, captureSentryException2) => {
  const ENVIRONMENT = getSecret("ENVIRONMENT" /* ENVIRONMENT */, secrets);
  if (!["testing", "staging", "production"].includes(ENVIRONMENT)) {
    return;
  }
  if (captureSentryException2) {
    captureSentryException2(error);
  } else {
    const message = `Alert in ${ENVIRONMENT} zambda ${zambda}.

${isFHIRError(error) ? "FHIR Error" : `${error}

${JSON.stringify(error)}`}`;
    await triggerSlackAlarm(message, secrets);
  }
  const SENDGRID_API_KEY = getSecret("SENDGRID_API_KEY" /* SENDGRID_API_KEY */, secrets);
  const SENDGRID_ERROR_EMAIL_TEMPLATE_ID = getSecret("IN_PERSON_SENDGRID_ERROR_EMAIL_TEMPLATE_ID" /* IN_PERSON_SENDGRID_ERROR_EMAIL_TEMPLATE_ID */, secrets);
  console.log("Sending error email");
  import_mail.default.setApiKey(SENDGRID_API_KEY);
  const email = "support@ottehr.com";
  const emailConfiguration = {
    to: email,
    from: {
      email,
      name: "Ottehr In Person"
    },
    replyTo: email,
    templateId: SENDGRID_ERROR_EMAIL_TEMPLATE_ID,
    dynamic_template_data: {
      environment: ENVIRONMENT,
      errorMessage: `Error in ${zambda}.
${error}.
Error stringified: ${JSON.stringify(error)}`,
      timestamp: DateTime.now().setZone("UTC").toFormat("EEEE, MMMM d, yyyy 'at' h:mm a ZZZZ")
    }
  };
  try {
    const sendResult = await import_mail.default.send(emailConfiguration);
    console.log(
      `Details of successful sendgrid send: statusCode, ${sendResult[0].statusCode}. body, ${JSON.stringify(
        sendResult[0].body
      )}`
    );
  } catch (error2) {
    console.error(`Error sending email to ${email}: ${JSON.stringify(error2)}`);
  }
};
var triggerSlackAlarm = async (message, secrets) => {
  const ENVIRONMENT = getSecret("ENVIRONMENT" /* ENVIRONMENT */, secrets);
  console.log("Sending error message to Slack");
  const url = ENVIRONMENT === "production" ? "https://hooks.slack.com/services/your_slack_webhook_url" : "https://hooks.slack.com/services/your_slack_webhook_url";
  await fetch(url, {
    method: "POST",
    body: JSON.stringify({
      text: message,
      link_names: true
    })
  });
};

// src/shared/getAuth0Token.ts
var import_node_fetch = __toESM(require_lib3());
async function getAuth0Token(secrets) {
  const AUTH0_ENDPOINT = getSecret("AUTH0_ENDPOINT" /* AUTH0_ENDPOINT */, secrets);
  const AUTH0_CLIENT = getSecret("AUTH0_CLIENT" /* AUTH0_CLIENT */, secrets);
  const AUTH0_SECRET = getSecret("AUTH0_SECRET" /* AUTH0_SECRET */, secrets);
  const AUTH0_AUDIENCE = getSecret("AUTH0_AUDIENCE" /* AUTH0_AUDIENCE */, secrets);
  console.group(`Fetch from ${AUTH0_ENDPOINT}`);
  return await (0, import_node_fetch.default)(AUTH0_ENDPOINT, {
    method: "POST",
    headers: {
      "content-type": "application/json"
    },
    body: JSON.stringify({
      grant_type: "client_credentials",
      client_id: AUTH0_CLIENT,
      client_secret: AUTH0_SECRET,
      audience: AUTH0_AUDIENCE
    })
  }).then((response) => {
    if (!response.ok) {
      console.error("response issue", response);
      throw new Error(response);
    }
    console.log("Got a response from auth0");
    return response.json();
  }).then((response) => {
    console.groupEnd();
    console.debug(`Fetch from ${AUTH0_ENDPOINT} success`);
    return response.access_token;
  }).catch((error) => {
    console.error("error", error);
    throw new Error(error.message);
  });
}

// src/shared/helpers.ts
function createOystehrClient(token, secrets) {
  const FHIR_API = getSecret("FHIR_API" /* FHIR_API */, secrets).replace(/\/r4/g, "");
  const PROJECT_API = getSecret("PROJECT_API" /* PROJECT_API */, secrets);
  const CLIENT_CONFIG = {
    accessToken: token,
    fhirApiUrl: FHIR_API,
    projectApiUrl: PROJECT_API
  };
  console.log("creating oystehr client");
  return new Oystehr2(CLIENT_CONFIG);
}
function getParticipantFromAppointment(appointment, participant) {
  const participantTemp = appointment.participant.find((currentParticipant) => currentParticipant.actor?.reference?.startsWith(participant))?.actor?.reference?.replace(`${participant}/`, "");
  if (!participantTemp) {
    throw new Error("Participant not found in list of appointment participants");
  }
  return participantTemp;
}
function getLocationInformation(oystehr, scheduleResource, currentDate = DateTime.now()) {
  const slug = scheduleResource.identifier?.find((identifierTemp) => identifierTemp.system === SLUG_SYSTEM)?.value;
  const timezone = scheduleResource.extension?.find(
    (extensionTemp) => extensionTemp.url === "http://hl7.org/fhir/StructureDefinition/timezone"
  )?.valueString;
  const schedule = getScheduleDetails(scheduleResource);
  const scheduleOverrides = schedule?.scheduleOverrides || {};
  let scheduleType;
  switch (scheduleResource?.resourceType) {
    case "Location":
      scheduleType = "location" /* location */;
      break;
    case "HealthcareService":
      scheduleType = "group" /* group */;
      break;
    case "Practitioner":
      scheduleType = "provider" /* provider */;
      break;
  }
  let hoursOfOperation = void 0;
  if (scheduleResource.resourceType === "Location") {
    hoursOfOperation = scheduleResource.hoursOfOperation;
    currentDate = currentDate.setZone(timezone);
    const overrideDate = Object.keys(scheduleOverrides).find((date) => {
      return currentDate.toFormat(OVERRIDE_DATE_FORMAT) === date;
    });
    if (overrideDate) {
      const dayOfWeek2 = currentDate.toFormat("EEE").toLowerCase();
      const override = scheduleOverrides[overrideDate];
      const dayIndex = hoursOfOperation?.findIndex((hour) => hour.daysOfWeek?.includes(dayOfWeek2));
      if (hoursOfOperation && typeof dayIndex !== "undefined" && dayIndex >= 0) {
        hoursOfOperation[dayIndex].openingTime = DateTime.fromFormat(override.open.toString(), "h").set({
          year: currentDate.year,
          month: currentDate.month,
          day: currentDate.day
        }).toFormat(HOURS_OF_OPERATION_FORMAT);
        hoursOfOperation[dayIndex].closingTime = DateTime.fromFormat(override.close.toString(), "h").set({
          year: currentDate.year,
          month: currentDate.month,
          day: currentDate.day
        }).toFormat(HOURS_OF_OPERATION_FORMAT);
      }
    }
  }
  return {
    id: scheduleResource.id,
    slug,
    name: getName(oystehr, scheduleResource),
    description: void 0,
    address: void 0,
    telecom: scheduleResource.telecom,
    hoursOfOperation,
    timezone,
    closures: schedule?.closures ?? [],
    otherOffices: [],
    // todo
    scheduleType
  };
}
function getName(oystehrClient, item) {
  if (!item.name) {
    return "Unknown";
  }
  if (item.resourceType === "Location") {
    return item.name;
  }
  if (item.resourceType === "HealthcareService") {
    return item.name;
  }
  return oystehrClient.fhir.formatHumanName(item.name[0]);
}

// src/shared/auth.ts
async function getUser(token, secrets) {
  const oystehr = createOystehrClient(token, secrets);
  const user = await oystehr.user.me();
  return user;
}

// src/shared/communication.ts
var import_mail2 = __toESM(require_mail3());
var sendInPersonCancellationEmail = async (input) => {
  const { email, language, startTime, secrets, scheduleResource, visitType } = input;
  const WEBSITE_URL = getSecret("WEBSITE_URL" /* WEBSITE_URL */, secrets);
  const SENDGRID_CANCELLATION_EMAIL_TEMPLATE_ID = getSecret(
    "IN_PERSON_SENDGRID_CANCELLATION_EMAIL_TEMPLATE_ID" /* IN_PERSON_SENDGRID_CANCELLATION_EMAIL_TEMPLATE_ID */,
    secrets
  );
  const SENDGRID_SPANISH_CANCELLATION_EMAIL_TEMPLATE_ID = getSecret(
    "IN_PERSON_SENDGRID_SPANISH_CANCELLATION_EMAIL_TEMPLATE_ID" /* IN_PERSON_SENDGRID_SPANISH_CANCELLATION_EMAIL_TEMPLATE_ID */,
    secrets
  );
  let subject = "In Person: Your Visit Has Been Canceled";
  let templateId = SENDGRID_CANCELLATION_EMAIL_TEMPLATE_ID;
  let address;
  if (scheduleResource.resourceType === "Location") {
    address = `${scheduleResource?.address?.line?.[0]}${scheduleResource?.address?.line?.[1] ? `, ${scheduleResource.address.line[1]}` : ""}, ${scheduleResource?.address?.city}, ${scheduleResource?.address?.state} ${scheduleResource?.address?.postalCode}`;
  }
  switch (language.split("-")[0]) {
    case "es":
      subject = "In Person: Su consulta ha sido cancelada";
      templateId = SENDGRID_SPANISH_CANCELLATION_EMAIL_TEMPLATE_ID;
      break;
    case "en":
      subject = "In Person: Your Visit Has Been Canceled";
      templateId = SENDGRID_CANCELLATION_EMAIL_TEMPLATE_ID;
      break;
    default:
      subject = "In Person: Your Visit Has Been Canceled";
      templateId = SENDGRID_CANCELLATION_EMAIL_TEMPLATE_ID;
      break;
  }
  const phone = formatPhoneNumberDisplay(scheduleResource.telecom?.find((el) => el.system === "phone")?.value || "");
  const isVirtual = scheduleResource.resourceType === "Location" ? isLocationVirtual(scheduleResource) : false;
  const slug = scheduleResource.identifier?.find((identifierTemp) => identifierTemp.system === SLUG_SYSTEM)?.value || "Unknown";
  const templateInformation = {
    appointmentTime: startTime,
    locationName: scheduleResource.name,
    locationAddress: address,
    locationPhone: phone,
    bookAgainUrl: `${WEBSITE_URL}/location/${slug}/${visitType}/${isVirtual ? "virtual" /* virtual */ : "in-person" /* in-person */}`
  };
  await sendEmail(email, templateId, subject, templateInformation, secrets);
};
async function sendEmail(email, templateID, subject, templateInformation, secrets) {
  console.log(`Sending email confirmation to ${email}`);
  const SENDGRID_API_KEY = getSecret("SENDGRID_API_KEY" /* SENDGRID_API_KEY */, secrets);
  if (!(SENDGRID_API_KEY && templateID)) {
    console.error(
      "Email message can't be sent because either Sendgrid api key or message template ID variable was not set"
    );
    return;
  }
  import_mail2.default.setApiKey(SENDGRID_API_KEY);
  const SENDGRID_EMAIL_BCC = getSecret("SENDGRID_EMAIL_BCC" /* SENDGRID_EMAIL_BCC */, secrets).split(",");
  const ENVIRONMENT = getSecret("ENVIRONMENT" /* ENVIRONMENT */, secrets);
  const environmentSubjectPrepend = ENVIRONMENT === "production" ? "" : `[${ENVIRONMENT}] `;
  subject = `${environmentSubjectPrepend}${subject}`;
  const emailConfiguration = {
    to: email,
    from: {
      email: "no-reply@ottehr.com",
      name: "Ottehr In Person"
    },
    bcc: SENDGRID_EMAIL_BCC,
    replyTo: "no-reply@ottehr.com",
    templateId: templateID,
    dynamic_template_data: {
      subject,
      ...templateInformation
    }
  };
  try {
    const sendResult = await import_mail2.default.send(emailConfiguration);
    console.log(
      `Details of successful sendgrid send: statusCode, ${sendResult[0].statusCode}. body, ${JSON.stringify(
        sendResult[0].body
      )}`
    );
  } catch (error) {
    const errorMessage = `Error sending email confirmation to ${email}`;
    console.error(`${errorMessage}: ${error}`);
    await sendErrors("email", errorMessage, secrets);
  }
}

// src/shared/sentry.ts
function configSentry(zambdaName, secrets) {
  const environment = getSecret("ENVIRONMENT", secrets);
  console.log("Sentry initialized: ", isInitialized());
  setTag("zambda", zambdaName);
  setTag("environment", environment);
}
function captureSentryException(error) {
  const errorToThrow = handleUnknownError(error);
  captureException(errorToThrow);
}

// src/shared/getEncounterDetails.ts
var getEncounterDetails = async (appointmentID, oystehr) => {
  let curStatusHistoryIdx, location, visitType, appointmentStart, patientID, canceledHistoryIdx;
  const encounter = await getEncounterForAppointment(appointmentID, oystehr);
  let appointment = void 0;
  console.log("Got encounter with id", encounter.id);
  if (encounter.statusHistory) {
    curStatusHistoryIdx = encounter.statusHistory.findIndex((history2) => !history2.period.end);
    canceledHistoryIdx = encounter.statusHistory.findIndex(
      (history2) => history2.status === "cancelled" && !history2.period.end
    );
  } else {
    throw new Error("Encounter status history not found");
  }
  try {
    const locationId = encounter.location?.[0]?.location.reference?.replace("Location/", "") || "";
    const fhirLocation = await oystehr.fhir.get({
      resourceType: "Location",
      id: locationId
    });
    location = {
      name: fhirLocation?.name || "Unknown",
      slug: fhirLocation.identifier?.find((identifierTemp) => identifierTemp.system === SLUG_SYSTEM)?.value || "Unknown",
      state: fhirLocation.address?.state || "Unknown",
      timezone: fhirLocation.extension?.find((extTemp) => extTemp.url === "http://hl7.org/fhir/StructureDefinition/timezone")?.valueString || "Unknown",
      address: fhirLocation?.address ?? void 0
    };
  } catch (error) {
    throw new Error("Error getting location details");
  }
  try {
    appointment = await oystehr.fhir.get({
      resourceType: "Appointment",
      id: appointmentID
    });
    if (!appointment) {
      throw new Error("error searching for appointment resource");
    }
    patientID = getParticipantFromAppointment(appointment, "Patient");
    appointmentStart = appointment.start;
    visitType = appointment.appointmentType?.text || "Unknown";
  } catch (error) {
    throw new Error("Error getting appointment details");
  }
  return {
    encounter,
    curStatusHistoryIdx,
    canceledHistoryIdx,
    location,
    visitType,
    appointmentStart,
    appointment,
    patientID
  };
};

// src/shared/userAuditLog.ts
function getEventAction(endpoint) {
  switch (endpoint) {
    case "cancel-appointment" /* appointmentCancel */:
    case "check-in" /* appointmentCheckIn */:
    case "update-appointment" /* appointmentUpdate */:
    case "update-paperwork-in-progress" /* paperworkUpdate */:
    case "patch-paperwork" /* patchPaperwork */:
    case "submit-paperwork" /* submitPaperwork */:
      return "U";
    case "create-appointment" /* appointmentCreate */:
      return "C";
  }
}
async function createAuditEvent(endpointName, oystehr, input, patientID, secrets) {
  const ORGANIZATION_ID = getSecret("ORGANIZATION_ID" /* ORGANIZATION_ID */, secrets);
  console.log("creating audit event");
  const event = await oystehr.fhir.create({
    resourceType: "AuditEvent",
    type: {
      system: "http://hl7.org/fhir/ValueSet/audit-event-type",
      code: "110110"
    },
    action: getEventAction(endpointName),
    outcome: "0",
    agent: [
      {
        who: {
          reference: `Patient/${patientID}`
        },
        requestor: true
      }
    ],
    recorded: DateTime.now().setZone("UTC").toString(),
    source: {
      observer: {
        reference: `Organization/${ORGANIZATION_ID}`
      }
    },
    entity: [
      {
        name: endpointName,
        detail: [
          {
            type: "requestJson",
            valueString: JSON.stringify(input.body)
          }
        ]
      }
    ]
  });
  console.log("created audit event with id", event.id);
}

// src/shared/validateBundleAndExtractAppointment.ts
var validateBundleAndExtractAppointment = (bundle) => {
  const entries = bundle.entry ?? [];
  const searchBundle = entries.find((item) => {
    return item.resource && item.resource.resourceType === "Bundle" && item.resource.type === "searchset";
  })?.resource;
  if (!searchBundle) {
    throw new Error("Transaction could not be completed");
  }
  const entry = searchBundle.entry ?? [];
  const appointment = entry.find((appt) => {
    return appt.resource && appt.resource.resourceType === "Appointment";
  })?.resource;
  if (!appointment) {
    throw new Error("Appointment could not be found");
  }
  const fhirLocation = entry.find((e) => e.resource?.resourceType === "Location");
  const fhirHS = entry.find((e) => e.resource?.resourceType === "HealthcareService");
  const fhirPractitioner = entry.find((e) => e.resource?.resourceType === "Practitioner");
  let scheduleResource;
  if (fhirLocation) {
    scheduleResource = fhirLocation;
  } else if (fhirHS) {
    scheduleResource = fhirHS;
  } else if (fhirPractitioner) {
    scheduleResource = fhirPractitioner;
  }
  if (!scheduleResource) {
    throw SCHEDULE_NOT_FOUND_ERROR;
  }
  const patient = entry.find((appt) => {
    return appt.resource && appt.resource.resourceType === "Patient";
  })?.resource;
  if (!patient) {
    throw new Error("Patient could not be found");
  }
  const questionnaireResponse = entry.find((appt) => {
    return appt.resource && appt.resource.resourceType === "QuestionnaireResponse";
  })?.resource;
  return { appointment, scheduleResource, questionnaireResponse, patient };
};

// src/appointment/prebook-cancel-appointment/validateRequestParameters.ts
function validateRequestParameters(input) {
  if (!input.body) {
    throw new Error("No request body provided");
  }
  const { language, appointmentID, cancellationReason, silent } = JSON.parse(input.body);
  if (appointmentID === void 0 || cancellationReason === void 0) {
    throw new Error('These fields are required: "appointmentID", "cancellationReason"');
  }
  const validReasons = [
    ...Object.values(CancellationReasonOptionsInPerson),
    ...Object.values(CancellationReasonOptionsTelemedEHR)
  ];
  if (!validReasons.includes(cancellationReason)) {
    throw new Error(`"cancellationReason" must be one of the following values: ${JSON.stringify(validReasons)}`);
  }
  return {
    appointmentID,
    cancellationReason,
    silent,
    secrets: input.secrets,
    language
  };
}

// src/appointment/prebook-cancel-appointment/index.ts
var zapehrToken;
var index = wrapHandler(async (input) => {
  configSentry("cancel-appointment", input.secrets);
  console.log(`Cancelation Input: ${JSON.stringify(input)}`);
  try {
    console.group("validateRequestParameters");
    console.log("getting user");
    const userToken = input.headers.Authorization?.replace("Bearer ", "");
    const user = userToken && await getUser(input.headers.Authorization.replace("Bearer ", ""), input.secrets);
    const isEHRUser = userToken && !user.name.startsWith("+");
    const validatedParameters = validateRequestParameters(input);
    const { appointmentID, language: languageInput, cancellationReason, silent, secrets } = validatedParameters;
    const language = languageInput || "en";
    console.groupEnd();
    console.debug("validateRequestParameters success");
    console.group("gettingEmailProps");
    if (!zapehrToken) {
      console.log("getting token");
      zapehrToken = await getAuth0Token(secrets);
    } else {
      console.log("already have token");
    }
    const oystehr = createOystehrClient(zapehrToken, secrets);
    const appointment = await getAppointmentResourceById(appointmentID, oystehr);
    if (!appointment) {
      throw APPOINTMENT_NOT_FOUND_ERROR;
    }
    if (!isEHRUser) {
      if (isPostTelemedAppointment(appointment)) {
        throw POST_TELEMED_APPOINTMENT_CANT_BE_CANCELED_ERROR;
      }
      console.log(`checking appointment with id ${appointmentID} is not checked in`);
      if (appointment.status !== "booked") {
        throw CANT_CANCEL_CHECKEDIN_APT_ERROR;
      }
    } else {
      console.log("cancelled by EHR user");
    }
    const formattedUserNumber = formatPhoneNumberDisplay(user?.name.replace("+1", ""));
    const cancelledBy = isEHRUser ? `Staff ${user?.email} via QRS` : `Patient${formattedUserNumber ? ` ${formattedUserNumber}` : ""}`;
    const criticalUpdateOp = getCriticalUpdateTagOp(appointment, cancelledBy);
    const appointmentPatchOperations = [
      criticalUpdateOp,
      {
        op: "replace",
        path: "/status",
        value: "cancelled"
      },
      {
        op: "add",
        path: "/cancelationReason",
        value: {
          coding: [
            {
              // todo reassess codes and reasons, just using custom codes atm
              system: `${FHIR_ZAPEHR_URL}/CodeSystem/appointment-cancellation-reason`,
              code: CancellationReasonCodesInPerson[cancellationReason],
              display: cancellationReason
            }
          ]
        }
      }
    ];
    console.log(`getting encounter details for appointment with id ${appointmentID}`);
    const { encounter, curStatusHistoryIdx, canceledHistoryIdx } = await getEncounterDetails(appointmentID, oystehr);
    console.log(`successfully retrieved encounter details for id ${encounter.id}`);
    const now2 = DateTime.now().setZone("UTC").toISO() || "";
    const encounterPatchOperations = [
      {
        op: "replace",
        path: "/status",
        value: "cancelled"
      }
    ];
    if (curStatusHistoryIdx >= 0) {
      encounterPatchOperations.push({
        op: "add",
        path: `/statusHistory/${curStatusHistoryIdx}/period/end`,
        value: now2
      });
    }
    if (canceledHistoryIdx === -1) {
      encounterPatchOperations.push({
        op: "add",
        path: `/statusHistory/-`,
        value: {
          status: "cancelled",
          period: {
            start: now2
          }
        }
      });
    }
    const appointmentPatchRequest = getPatchBinary({
      resourceType: "Appointment",
      resourceId: appointmentID,
      patchOperations: appointmentPatchOperations
    });
    const encounterPatchRequest = getPatchBinary({
      resourceType: "Encounter",
      resourceId: encounter.id || "Unknown",
      patchOperations: encounterPatchOperations
    });
    const getAppointmentRequest = {
      url: `/Appointment?_id=${appointmentID}&_include=Appointment:patient&_include=Appointment:actor`,
      method: "GET"
    };
    console.log("making transaction request for getAppointmentRequest, appointmentPatchRequest, encounterPatchRequest");
    const transactionBundle = await oystehr.fhir.transaction({
      requests: [getAppointmentRequest, appointmentPatchRequest, encounterPatchRequest]
    });
    console.log("getting appointment from transaction bundle");
    const {
      appointment: appointmentUpdated,
      scheduleResource,
      patient
    } = validateBundleAndExtractAppointment(transactionBundle);
    const { startTime, email, visitType } = await getCancellationDetails(appointmentUpdated, patient, scheduleResource);
    console.groupEnd();
    console.debug("gettingEmailProps success");
    console.log("building location information");
    const locationInformation = getLocationInformation(oystehr, scheduleResource);
    const response = {
      message: "Successfully canceled an appointment",
      appointment: appointmentUpdated.id ?? null,
      location: locationInformation,
      visitType
    };
    if (!silent) {
      if (email) {
        console.group("sendCancellationEmail");
        try {
          await sendInPersonCancellationEmail({
            email,
            startTime,
            secrets,
            scheduleResource,
            visitType,
            language
          });
        } catch (error) {
          console.error("error sending cancellation email", error);
        }
        console.groupEnd();
      } else {
        console.log("No email found. Skipping sending email.");
      }
      if (!isEHRUser) {
        console.group("Send cancel message request");
        const WEBSITE_URL = getSecret("WEBSITE_URL" /* WEBSITE_URL */, secrets);
        const url = `${WEBSITE_URL}/home`;
        const message = `Your visit for ${getPatientFirstName(
          patient
        )} has been canceled. Tap ${url} to book a new visit.`;
        const messageSpanish = `Su consulta para ${getPatientFirstName(
          patient
        )} ha sido cancelada. Toque ${url} para reservar una nueva consulta.`;
        let selectedMessage;
        switch (language.split("-")[0]) {
          case "es":
            selectedMessage = messageSpanish;
            break;
          case "en":
          default:
            selectedMessage = message;
            break;
        }
        const relatedPerson = await getRelatedPersonForPatient(patient.id || "", oystehr);
        if (relatedPerson) {
          try {
            await oystehr.transactionalSMS.send({
              resource: `RelatedPerson/${relatedPerson.id}`,
              message: selectedMessage
            });
          } catch (e) {
            console.log("failing silently, error sending cancellation text message");
          }
        } else {
          console.log(`No RelatedPerson found for patient ${patient.id} not sending text message`);
        }
        console.groupEnd();
      } else {
        console.log("cancelled by EHR user, not sending text");
      }
    } else {
      console.log("Cancelling silently. Skipping email and text.");
    }
    await createAuditEvent("cancel-appointment" /* appointmentCancel */, oystehr, input, patient.id || "", secrets);
    return {
      statusCode: 200,
      body: JSON.stringify(response)
    };
  } catch (error) {
    return topLevelCatch("cancel-appointment", error, input.secrets, captureSentryException);
  }
});
var getCancellationDetails = async (appointment, patient, scheduleResource) => {
  try {
    if (!appointment.start) {
      throw new Error(`These fields are required for the cancelation email: appointment.start`);
    }
    const email = getPatientContactEmail(patient);
    const timezone = scheduleResource.extension?.find(
      (extensionTemp) => extensionTemp.url === "http://hl7.org/fhir/StructureDefinition/timezone"
    )?.valueString;
    const visitType = appointment.appointmentType?.text ?? "Unknown";
    return {
      startTime: DateTime.fromISO(appointment.start).setZone(timezone).toFormat(DATETIME_FULL_NO_YEAR),
      email,
      patient,
      visitType
    };
  } catch (error) {
    throw new Error(`error getting cancellation email details: ${error}, ${JSON.stringify(error)}`);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  index
});
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=index.js.map
